<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>TIDAL Loudness DSP - Mobile</title>
    <style>
        :root {
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-dim: #666666;
            --tidal-cyan: #00D4D4;
            --tidal-hover: #00E8E8;
            --tidal-active: #00B8B8;
            --header-height: 56px;
            --border-color: rgba(255, 255, 255, 0.05);
            --success: #4CAF50;
            --warning: #FFA500;
            --danger: #FF6B6B;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            position: fixed;
            width: 100%;
            padding-top: var(--safe-area-inset-top);
            padding-bottom: var(--safe-area-inset-bottom);
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Ensure SVG icons are always visible */
        button svg {
            pointer-events: none;
        }
        
        /* Fix play/pause button visibility in mini player */
        .mini-player-button svg,
        .mini-player-button svg path {
            fill: #ffffff !important;
        }
        
        .mini-player-button:hover svg,
        .mini-player-button:hover svg path {
            fill: #ffffff !important;
        }
        
        /* Fix play/pause button visibility in full screen player */
        .control-button.primary {
            background: var(--tidal-cyan);
            color: #000000;
        }
        
        .control-button.primary:hover {
            background: #00c5c5; /* Lighter cyan for better contrast */
            color: #000000;
            box-shadow: 0 0 20px rgba(0, 212, 212, 0.5);
        }
        
        .control-button.primary svg,
        .control-button.primary svg path {
            fill: #000000 !important;
        }
        
        .control-button.primary:hover svg,
        .control-button.primary:hover svg path {
            fill: #000000 !important;
        }
        
        .control-button.primary:active {
            background: #009999; /* Darker on click */
            transform: scale(0.95);
        }
        
        .control-button:not(.primary) svg,
        .control-button:not(.primary) svg path {
            fill: #ffffff !important;
        }
        
        .control-button:not(.primary):hover svg,
        .control-button:not(.primary):hover svg path {
            fill: #ffffff !important;
        }
        
        .control-button:not(.primary):hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .control-button:not(.primary):active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }
        
        .control-button.secondary.active svg,
        .control-button.secondary.active svg path {
            fill: var(--tidal-cyan) !important;
        }

        /* App Container */
        .app-container {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            height: var(--header-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            position: relative;
            z-index: 100;
        }

        .header-title {
            font-size: 18px;
            font-weight: 600;
            flex: 1;
            text-align: center;
        }

        .header-button {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
        }

        .header-button:active {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 16px;
            padding-bottom: 80px;
        }

        /* DSP Section */
        .dsp-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .dsp-section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 51px;
            height: 31px;
        }

        .toggle-input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.2);
            transition: .3s;
            border-radius: 31px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 27px;
            width: 27px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        .toggle-input:checked + .toggle-slider {
            background-color: var(--tidal-cyan);
        }

        .toggle-input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        /* Control Group */
        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .control-value {
            color: var(--tidal-cyan);
            font-weight: 600;
        }

        /* Slider */
        .slider {
            width: 100%;
            height: 44px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-track {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: var(--tidal-cyan);
            border-radius: 50%;
            cursor: pointer;
            margin-top: -10px;
        }

        /* Easy Mode Section */
        .easy-mode-section {
            background: rgba(0, 212, 212, 0.1);
            border: 1px solid var(--tidal-cyan);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .easy-slider-container {
            text-align: center;
            margin-top: 20px;
        }

        .easy-phon-display {
            font-size: 36px;
            font-weight: 700;
            color: var(--tidal-cyan);
            margin-bottom: 8px;
        }

        .easy-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 12px;
            line-height: 1.5;
        }

        /* Button */
        .button {
            width: 100%;
            padding: 14px;
            background: var(--tidal-cyan);
            border: none;
            border-radius: 8px;
            color: var(--bg-primary);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .button:active {
            background: var(--tidal-active);
        }

        .button.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        /* File Input */
        .file-input-label {
            display: block;
            padding: 14px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 12px;
            transition: all 0.2s;
        }

        .file-input-label:active {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Status Messages */
        .status-message {
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 13px;
            line-height: 1.4;
        }

        .status-success {
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .status-warning {
            background: rgba(255, 165, 0, 0.1);
            color: var(--warning);
            border: 1px solid rgba(255, 165, 0, 0.3);
        }

        .status-error {
            background: rgba(255, 107, 107, 0.1);
            color: var(--danger);
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        /* Audio Player */
        .audio-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 100;
            transform: translateY(100%);
            transition: transform 0.3s;
        }

        .audio-player.active {
            transform: translateY(0);
        }

        .play-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--tidal-cyan);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
        }

        .play-button:active {
            transform: scale(0.95);
        }

        .play-button svg {
            fill: var(--bg-primary);
        }

        .audio-info {
            flex: 1;
            min-width: 0;
        }

        .audio-title {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .audio-status {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Hidden elements */
        .hidden {
            display: none !important;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            height: 50px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        
        .tab-navigation::-webkit-scrollbar {
            display: none;
        }
        
        .tab-button {
            flex: 0 0 auto;
            padding: 0 20px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            cursor: pointer;
            position: relative;
            transition: color 0.2s;
        }
        
        .tab-button:active {
            transform: scale(0.98);
        }
        
        .tab-button.active {
            color: var(--text-primary);
        }
        
        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 20px;
            right: 20px;
            height: 2px;
            background: var(--tidal-cyan);
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
            height: calc(100% - 50px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Search Section */
        .search-section {
            padding: 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .search-input {
            width: 100%;
            padding: 12px 40px 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--tidal-cyan);
        }
        
        /* List Items */
        .list-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .list-item:active {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .list-item-art {
            width: 48px;
            height: 48px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin-right: 12px;
            object-fit: cover;
        }
        
        .list-item-info {
            flex: 1;
            min-width: 0;
        }
        
        .list-item-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }
        
        .list-item-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .list-item-action {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        /* Mini Player */
        .mini-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            transform: translateY(100%);
            transition: transform 0.3s;
            z-index: 90;
            display: flex;
            flex-direction: column;
        }
        
        .mini-player.active {
            transform: translateY(0);
        }

        .mini-player.hidden {
            transform: translateY(100%);
        }
        
        /* Progress bar at top */
        .mini-player-progress {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }
        
        .mini-player-progress-fill {
            height: 100%;
            background: var(--tidal-cyan);
            width: 0%;
            transition: width 0.1s;
        }

        .mini-player-content {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            flex: 1;
        }
        
        /* Left side numbers */
        .mini-player-numbers {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-right: 12px;
            font-size: 10px;
            color: var(--text-secondary);
            min-width: 60px;
        }
        
        .mini-player-phon {
            color: var(--tidal-cyan);
            font-weight: 600;
        }
        
        .mini-player-headroom {
            font-size: 9px;
        }
        
        .mini-player-art {
            width: 40px;
            height: 40px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin-right: 12px;
            object-fit: cover;
            cursor: pointer;
        }
        
        .mini-player-info {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }
        
        .mini-player-title {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }
        
        .mini-player-artist {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .mini-player-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .mini-player-button {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.2s;
        }
        
        .mini-player-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        
        /* Loudness slider in mini player */
        .mini-player-loudness {
            padding: 0 16px 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .mini-player-loudness-label {
            font-size: 10px;
            color: var(--text-secondary);
            min-width: 40px;
        }
        
        .mini-player-loudness-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
            border-radius: 2px;
        }
        
        .mini-player-loudness-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--tidal-cyan);
            cursor: pointer;
            border-radius: 50%;
        }
        
        .mini-player-loudness-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--tidal-cyan);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        /* Toast */
        .toast {
            position: fixed;
            top: calc(var(--safe-area-inset-top) + 20px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            z-index: 1000;
            animation: slideDown 0.3s ease;
            max-width: 90%;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-secondary);
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-footer .button {
            flex: 1;
            max-width: 120px;
        }

        .calibration-step {
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .calibration-step:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .calibration-step h4 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--tidal-cyan);
        }

        .calibration-step p {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .number-input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            text-align: center;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--tidal-cyan);
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        .empty-state-text {
            font-size: 16px;
            margin-bottom: 8px;
        }
        
        .empty-state-subtext {
            font-size: 14px;
            color: var(--text-dim);
        }
        
        /* Loading State */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }
        
        .spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--tidal-cyan);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Playlist Item Actions */
        .playlist-item-actions {
            display: flex;
            gap: 8px;
        }
        
        .playlist-item-action {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
        }
        
        .playlist-item-action:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .playing-indicator {
            display: flex;
            gap: 2px;
            align-items: center;
            height: 16px;
        }
        
        .playing-indicator span {
            width: 3px;
            height: 100%;
            background: var(--tidal-cyan);
            animation: playingAnimation 1.2s ease-in-out infinite;
        }
        
        .playing-indicator span:nth-child(2) {
            animation-delay: -0.4s;
        }
        
        .playing-indicator span:nth-child(3) {
            animation-delay: -0.8s;
        }
        
        @keyframes playingAnimation {
            0%, 100% { transform: scaleY(0.3); }
            50% { transform: scaleY(1); }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 300px;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast-success {
            background: #28a745;
        }

        .toast-error {
            background: #dc3545;
        }

        .toast-warning {
            background: #ffc107;
            color: #000;
        }

        .toast-info {
            background: #17a2b8;
        }

        /* Loading indicator */
        .loading {
            text-align: center;
            padding: 20px;
            color: #999;
        }

        /* Empty states */
        .no-results, .empty-playlist {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            color: #dc3545;
            padding: 20px;
            text-align: center;
        }

        /* Search Results */
        .search-result {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-result:hover {
            background: var(--bg-tertiary);
        }

        .search-result:active {
            background: var(--bg-tertiary);
            opacity: 0.8;
        }

        .search-result .track-info {
            flex: 1;
            min-width: 0;
        }

        .search-result .track-title {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result .track-subtitle {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }

        .search-result .action-button {
            background: none;
            border: none;
            color: var(--tidal-cyan);
            font-size: 20px;
            padding: 8px;
            cursor: pointer;
            margin-left: 8px;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .search-result .action-button:hover {
            background: rgba(0, 212, 212, 0.1);
        }

        .search-result .action-button:active {
            background: rgba(0, 212, 212, 0.2);
        }

        /* Playing state indicator */
        .search-result.playing {
            background: rgba(0, 212, 212, 0.1);
            border: 1px solid var(--tidal-cyan);
        }

        .search-result.playing .track-title {
            color: var(--tidal-cyan);
        }

        /* Full Screen Player */
        .full-player {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .full-player.active {
            transform: translateY(0);
        }

        .full-player-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            height: 56px;
        }

        .full-player-close {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .full-player-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .full-player-header-title {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .full-player-header-spacer {
            width: 40px;
        }

        .full-player-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0 24px 24px;
            overflow-y: auto;
        }

        .full-player-art-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 24px 0;
        }

        .full-player-art {
            width: 100%;
            max-width: 320px;
            height: auto;
            aspect-ratio: 1;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .full-player-info {
            text-align: center;
            margin-bottom: 32px;
        }

        .full-player-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .full-player-artist {
            font-size: 16px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .full-player-progress {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 32px;
        }

        .progress-time {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 40px;
        }

        .progress-bar {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
        }

        .progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--tidal-cyan);
            border-radius: 50%;
            cursor: pointer;
        }

        .full-player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
        }

        .control-button {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .control-button.primary {
            background: var(--tidal-cyan);
            color: var(--bg-primary);
            padding: 16px;
        }

        .control-button.primary:hover {
            background: var(--tidal-cyan-hover);
        }
        

        .control-button.secondary {
            color: var(--text-secondary);
        }

        .control-button.secondary.active {
            color: var(--tidal-cyan);
        }
        
        
        /* Progress bar styling */
        .progress-bar {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
            border-radius: 2px;
        }
        
        .progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--tidal-cyan);
            cursor: pointer;
            border-radius: 50%;
        }
        
        .progress-bar::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--tidal-cyan);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        /* Login Styles */
        .login-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 10000;
        }
        
        .login-container.hidden {
            display: none;
        }
        
        .login-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 32px 24px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        .login-logo {
            text-align: center;
            margin-bottom: 32px;
        }
        
        .login-logo h1 {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -1px;
            margin-bottom: 8px;
        }
        
        .login-logo p {
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .auth-section {
            display: none;
        }
        
        .auth-section.active {
            display: block;
        }
        
        .device-auth-info {
            background: rgba(0, 212, 212, 0.1);
            border: 1px solid var(--tidal-cyan);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .user-code {
            font-size: 32px;
            font-weight: 700;
            color: var(--tidal-cyan);
            letter-spacing: 4px;
            margin: 16px 0;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .verification-url {
            color: var(--tidal-cyan);
            text-decoration: none;
            font-size: 16px;
            display: inline-block;
            margin: 16px 0;
            padding: 8px 16px;
            border: 1px solid var(--tidal-cyan);
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .verification-url:hover {
            background: var(--tidal-cyan);
            color: var(--bg-primary);
        }
        
        .auth-timer {
            color: var(--text-secondary);
            font-size: 14px;
            margin-top: 16px;
        }
        
        .auth-status {
            text-align: center;
            margin: 20px 0;
            font-size: 14px;
            padding: 12px;
            border-radius: 8px;
        }
        
        .auth-status.info {
            background: rgba(0, 212, 212, 0.1);
            color: var(--tidal-cyan);
        }
        
        .auth-status.success {
            background: rgba(76, 175, 80, 0.1);
            color: var(--success);
        }
        
        .auth-status.error {
            background: rgba(255, 107, 107, 0.1);
            color: var(--danger);
        }
        
        .auth-status.warning {
            background: rgba(255, 165, 0, 0.1);
            color: var(--warning);
        }
        
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            border-top-color: var(--tidal-cyan);
            animation: spin 1s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .token-input-section {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid var(--border-color);
        }
        
        .divider {
            text-align: center;
            margin: 24px 0;
            position: relative;
        }
        
        .divider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: var(--border-color);
        }
        
        .divider span {
            background: var(--bg-secondary);
            padding: 0 16px;
            position: relative;
            color: var(--text-secondary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .success-icon {
            font-size: 64px;
            margin-bottom: 24px;
            color: var(--success);
        }
    </style>
</head>
<body>
    <!-- Login Container -->
    <div class="login-container" id="loginContainer">
        <div class="login-card">
            <div class="login-logo">
                <h1>🎵 TIDAL Loudness DSP</h1>
                <p>Professional Equal-Loudness Compensation</p>
            </div>
            
            <!-- OAuth Device Flow Section -->
            <div id="oauthSection" class="auth-section active">
                <h3 style="text-align: center; margin-bottom: 24px; font-size: 20px;">Sign in to TIDAL</h3>
                
                <div id="corsNotice" style="background: rgba(0, 212, 212, 0.1); border: 1px solid var(--tidal-cyan); border-radius: 8px; padding: 12px; margin-bottom: 20px; font-size: 14px; text-align: center;">
                    <script>
                        if (window.location.protocol === 'file:') {
                            document.write('<strong>Local Mode</strong><br>Direct TIDAL API access enabled');
                        } else {
                            document.write('<strong>Web Version</strong><br>Will attempt to connect via CORS proxy');
                        }
                    </script>
                </div>
                
                <button class="button primary" id="startAuthBtn" onclick="startDeviceAuth()">
                    Connect with TIDAL
                </button>
                
                <div id="deviceAuthInfo" class="device-auth-info" style="display: none;">
                    <p style="margin-bottom: 16px;">Enter this code on your device:</p>
                    <div class="user-code" id="userCode">----</div>
                    <p style="margin: 16px 0;">Or visit:</p>
                    <a href="#" class="verification-url" id="verificationUrl" target="_blank">tidal.com/link</a>
                    <div class="auth-timer" id="authTimer">Expires in: --:--</div>
                </div>
                
                <div class="auth-status" id="authStatus" style="display: none;"></div>
                
                <div class="divider">
                    <span>OR</span>
                </div>
                
                <!-- Direct Token Input -->
                <div class="token-input-section">
                    <h4 style="text-align: center; margin-bottom: 16px; color: var(--text-secondary);">Use Access Token</h4>
                    <textarea id="directTokenInput" placeholder="Paste your TIDAL access token here..." 
                        style="width: 100%; padding: 12px; background: var(--bg-tertiary); 
                        border: 1px solid var(--border-color); border-radius: 8px; 
                        color: var(--text-primary); font-size: 14px; font-family: 'Monaco', 'Menlo', monospace; 
                        resize: vertical; min-height: 80px;"></textarea>
                    <button class="button secondary" onclick="useDirectToken()" style="margin-top: 12px;">
                        Use Token
                    </button>
                </div>
            </div>
            
            <!-- Success Section -->
            <div id="successSection" class="auth-section">
                <div style="text-align: center;">
                    <div class="success-icon">✓</div>
                    <h3 style="margin-bottom: 16px;">Successfully Connected!</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 32px;">
                        Loading your music...
                    </p>
                    <button class="button primary" onclick="continueToApp()">
                        Continue to App
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <button class="header-button" onclick="showInfo()">ℹ️</button>
            <h1 class="header-title">TIDAL Loudness DSP</h1>
            <button class="header-button" onclick="logout()" title="Logout">🚪</button>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab('search')">Search</button>
                <button class="tab-button" onclick="switchTab('playlist')">Playlist</button>
                <button class="tab-button" onclick="switchTab('dsp')">DSP Settings</button>
            </div>
            
            <!-- Search Tab -->
            <div class="tab-content active" id="searchTab">
                <div class="search-section">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="text" class="search-input" id="tidalSearchInput" placeholder="Search TIDAL tracks, albums, artists..." style="flex: 1; width: 100%;">
                        <button class="button" onclick="searchTidal()" style="width: 100px; padding: 8px 16px; flex-shrink: 0;">Search</button>
                    </div>
                </div>
                <div id="searchResults">
                    <div class="empty-state">
                        <div class="empty-state-icon">🔍</div>
                        <div class="empty-state-text">Search for music</div>
                        <div class="empty-state-subtext">Enter a track, album or artist name</div>
                    </div>
                </div>
            </div>
            
            <!-- Playlist Tab -->
            <div class="tab-content" id="playlistTab">
                <div id="playlistContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">🎵</div>
                        <div class="empty-state-text">Your playlist is empty</div>
                        <div class="empty-state-subtext">Search and add tracks to get started</div>
                    </div>
                </div>
            </div>
            
            <!-- DSP Settings Tab -->
            <div class="tab-content" id="dspTab">
            <!-- Easy Mode Section -->
            <div class="easy-mode-section" id="easyModeSection">
                <div class="dsp-section-title">
                    <span>🎵 Easy Loudness Control</span>
                    <label class="toggle-switch">
                        <input type="checkbox" class="toggle-input" id="easyModeToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div id="easyControls">
                    <div class="easy-slider-container">
                        <div class="easy-phon-display" id="easyPhonDisplay">55 phon</div>
                        <input type="range" class="slider" id="easyLoudnessSlider" min="0" max="100" value="50" step="1">
                        <div class="easy-info">
                            <div>SPL: <span id="easySPLDisplay">55 dB</span> <span id="easyHeadroomDisplay" style="color: var(--success); font-size: 11px;">/ -32.7 dB</span></div>
                            <div>Filter: <span id="easyFilterDisplay" style="color: var(--tidal-cyan);">55.0 → 62.0 phon</span></div>
                            <div>Compensation: <span id="easyCompDisplay">ON</span></div>
                            <div>Status: <span id="easyStatusDisplay" style="color: var(--success);">Safe Level</span></div>
                        </div>
                    </div>
                    
                    <!-- Bass Enhancement Control -->
                    <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 12px;">🎸 Bass Enhancement</div>
                        <div style="margin-top: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 13px;">Fall-off Rate (k)</span>
                                <span style="font-size: 13px; color: var(--tidal-cyan); font-weight: 600;" id="kParameterValue">22.0</span>
                            </div>
                            <input type="range" class="slider" id="kParameterSlider" min="0.1" max="26" value="22" step="0.1" style="width: 100%;">
                            <div style="display: flex; justify-content: space-between; margin-top: 4px;">
                                <span style="font-size: 11px; color: var(--text-secondary);">0.1 (Max Bass)</span>
                                <span style="font-size: 11px; color: var(--text-secondary);">26 (Flatter)</span>
                            </div>
                        </div>
                        
                        <div style="margin-top: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 13px;">Max Bass Boost (deltaMax)</span>
                                <span style="font-size: 13px; color: var(--tidal-cyan); font-weight: 600;" id="deltaMaxValue">26 dB</span>
                            </div>
                            <input type="range" class="slider" id="deltaMaxSlider" min="0" max="80" value="26" step="1" style="width: 100%;">
                            <div style="display: flex; justify-content: space-between; margin-top: 4px;">
                                <span style="font-size: 11px; color: var(--text-secondary);">0 dB</span>
                                <span style="font-size: 11px; color: var(--text-secondary);">80 dB</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Calibration Section -->
                    <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="font-size: 14px; font-weight: 600;">🎯 SPL Calibration</span>
                            <button class="button" style="padding: 8px 16px; font-size: 12px; background: var(--bg-tertiary);" onclick="showCalibrationModal()">
                                Setup
                            </button>
                        </div>
                        <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4;">
                            <div>Reference: <span id="calibrationSPLDisplay" style="color: var(--tidal-cyan);">80.0 dB</span> @ 80 phon</div>
                            <div>Target: <span id="desiredSPLDisplay" style="color: var(--tidal-cyan);">70.0 dB</span> SPL</div>
                            <div>Master Gain: <span id="preampDisplay" style="color: var(--tidal-cyan);">-10.0 dB</span></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced Controls (Hidden in Easy Mode) -->
            <div id="advancedControls" class="hidden">
                <!-- Loudness Compensation -->
                <div class="dsp-section">
                    <div class="dsp-section-title">
                        <span>🔊 Loudness Compensation</span>
                        <label class="toggle-switch">
                            <input type="checkbox" class="toggle-input" id="loudnessToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label">
                            <span>Target Level</span>
                            <span class="control-value" id="targetPhonValue">70.0 phon</span>
                        </div>
                        <input type="range" class="slider" id="targetPhonSlider" min="20" max="100" value="70" step="0.1">
                    </div>
                    
                    <div class="control-group">
                        <div class="control-label">
                            <span>Reference Level</span>
                            <span class="control-value" id="referencePhonValue">80.0 phon</span>
                        </div>
                        <input type="range" class="slider" id="referencePhonSlider" min="20" max="100" value="80" step="0.1">
                    </div>
                    
                </div>
            </div>

            <!-- Headphone EQ -->
            <div class="dsp-section">
                <div class="dsp-section-title">
                    <span>🎧 Headphone EQ</span>
                    <label class="toggle-switch">
                        <input type="checkbox" class="toggle-input" id="headphoneEqToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <label class="file-input-label" for="eqFileInput">
                    📁 Load AutoEQ File
                </label>
                <input type="file" id="eqFileInput" accept=".txt" style="display: none;">
                
                <div id="eqStatus" class="status-message hidden"></div>
            </div>

            <!-- Audio File Section -->
            <div class="dsp-section">
                <div class="dsp-section-title">
                    <span>🎵 Test Audio</span>
                </div>
                
                <label class="file-input-label" for="audioFileInput">
                    📂 Select Audio File
                </label>
                <input type="file" id="audioFileInput" accept="audio/*" style="display: none;">
                
                <button class="button secondary" onclick="generateTestTone()">
                    🔊 Generate 1kHz Test Tone
                </button>
                
                <button class="button secondary" onclick="testDiracDelta()" style="margin-top: 8px;">
                    🔬 Test Dirac Delta (Debug)
                </button>
            </div>

            <!-- Master Gain Control -->
            <div class="dsp-section">
                <div class="dsp-section-title">
                    <span>🎚️ Master Gain</span>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Volume Adjustment</span>
                        <span class="control-value" id="masterGainValue">-20.0 dB</span>
                    </div>
                    <input type="range" class="slider" id="masterGainSlider" min="-30" max="40" value="-20" step="0.5">
                </div>
                
                <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                    <div>⚠️ Use high gain values (+20 dB and above) with caution</div>
                    <div>🎯 Default: -10 dB (safe for most content)</div>
                    <div>🔊 Range: -30 dB to +40 dB for extreme adjustments</div>
                </div>
            </div>
            
            <!-- System Status -->
            <div class="dsp-section">
                <div class="dsp-section-title">
                    <span>📊 System Status</span>
                </div>
                
                <div style="font-size: 13px; line-height: 1.8;">
                    <div>Audio Context: <span id="audioContextStatus" style="color: var(--warning);">Not initialized</span></div>
                    <div>Sample Rate: <span id="sampleRateDisplay">--</span></div>
                    <div>Loudness Filter: <span id="loudnessFilterStatus">--</span></div>
                    <div>Headphone EQ: <span id="headphoneEqStatus">--</span></div>
                    <div>Total Gain: <span id="totalGainDisplay">0.0 dB</span></div>
                </div>
                
                <!-- Audio Signal Path -->
                <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 12px;">🎚️ Audio Signal Path</h4>
                    <div class="signal-path" id="signalPath" style="font-family: monospace; font-size: 12px; line-height: 1.6;">
                        <div>Loading...</div>
                    </div>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Mini Player -->
        <div class="mini-player" id="miniPlayer">
            <!-- Progress bar at top -->
            <div class="mini-player-progress" onclick="event.stopPropagation(); seekFromMiniPlayer(event)">
                <div class="mini-player-progress-fill" id="miniPlayerProgressFill"></div>
            </div>
            
            <div class="mini-player-content">
                <!-- Left side numbers -->
                <div class="mini-player-numbers">
                    <div class="mini-player-phon" id="miniPlayerPhon">55 phon</div>
                    <div class="mini-player-spl" id="miniPlayerSPL">55 dB</div>
                    <div class="mini-player-headroom" id="miniPlayerHeadroom">-32.7 dB</div>
                </div>
                
                <img class="mini-player-art" id="miniPlayerArt" onclick="expandPlayer()" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%232a2a2a'/%3E%3C/svg%3E">
                <div class="mini-player-info" onclick="expandPlayer()">
                    <div class="mini-player-title" id="miniPlayerTitle">No track</div>
                    <div class="mini-player-artist" id="miniPlayerArtist">-</div>
                </div>
                
                <div class="mini-player-controls">
                    <button class="mini-player-button" onclick="event.stopPropagation(); previousTrack()">
                        <svg width="18" height="18" viewBox="0 0 24 24">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                        </svg>
                    </button>
                    <button class="mini-player-button" onclick="event.stopPropagation(); togglePlayPause()">
                        <svg width="20" height="20" viewBox="0 0 24 24" id="miniPlayIcon">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <svg width="20" height="20" viewBox="0 0 24 24" id="miniPauseIcon" style="display: none;">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                    <button class="mini-player-button" onclick="event.stopPropagation(); nextTrack()">
                        <svg width="18" height="18" viewBox="0 0 24 24">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Loudness control slider -->
            <div class="mini-player-loudness">
                <span class="mini-player-loudness-label">Loudness</span>
                <input type="range" class="mini-player-loudness-slider" id="miniPlayerLoudnessSlider" min="0" max="100" value="50" step="1" onclick="event.stopPropagation()">
            </div>
        </div>

        <!-- Audio Player -->
        <div class="audio-player" id="audioPlayer">
            <button class="play-button" id="playButton" onclick="togglePlayPause()">
                <svg width="24" height="24" viewBox="0 0 24 24" id="playIcon">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg width="24" height="24" viewBox="0 0 24 24" id="pauseIcon" style="display: none;">
                    <path d="M6 6h4v12H6zm8 0h4v12h-4z"/>
                </svg>
            </button>
            <div class="audio-info">
                <div class="audio-title" id="audioTitle">No audio loaded</div>
                <div class="audio-status" id="audioStatus">Select an audio file to test</div>
            </div>
        </div>
    </div>

    <!-- Full Screen Player -->
    <div class="full-player" id="fullPlayer">
        <div class="full-player-header">
            <button class="full-player-close" onclick="collapsePlayer()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
                </svg>
            </button>
            <div class="full-player-header-title">NOW PLAYING</div>
            <div class="full-player-header-spacer"></div>
        </div>
        
        <div class="full-player-content">
            <div class="full-player-art-container">
                <img class="full-player-art" id="fullPlayerArt" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%232a2a2a'/%3E%3C/svg%3E">
            </div>
            
            <div class="full-player-info">
                <div class="full-player-title" id="fullPlayerTitle">No track</div>
                <div class="full-player-artist" id="fullPlayerArtist">-</div>
            </div>
            
            <div class="full-player-progress">
                <div class="progress-time" id="currentTime">0:00</div>
                <input type="range" class="progress-bar" id="progressBar" min="0" max="100" value="0">
                <div class="progress-time" id="duration">0:00</div>
            </div>
            
            <div class="full-player-controls">
                <button class="control-button secondary" onclick="toggleShuffle()">
                    <svg width="24" height="24" viewBox="0 0 24 24" id="shuffleIcon">
                        <path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>
                    </svg>
                </button>
                
                <button class="control-button" onclick="previousTrack()">
                    <svg width="32" height="32" viewBox="0 0 24 24">
                        <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                    </svg>
                </button>
                
                <button class="control-button primary" onclick="togglePlayPause()">
                    <svg width="48" height="48" viewBox="0 0 24 24" id="fullPlayIcon">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    <svg width="48" height="48" viewBox="0 0 24 24" id="fullPauseIcon" style="display: none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                    </svg>
                </button>
                
                <button class="control-button" onclick="nextTrack()">
                    <svg width="32" height="32" viewBox="0 0 24 24">
                        <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                    </svg>
                </button>
                
                <button class="control-button secondary" onclick="toggleRepeat()">
                    <svg width="24" height="24" viewBox="0 0 24 24" id="repeatIcon">
                        <path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>
                    </svg>
                </button>
            </div>
            
            <!-- Easy Loudness Control in Full Player -->
            <div style="margin-top: 24px; padding: 16px; background: rgba(0, 212, 212, 0.05); border-radius: 12px;">
                <div style="text-align: center; margin-bottom: 12px;">
                    <div style="font-size: 24px; font-weight: 600; color: var(--tidal-cyan);" id="fullPlayerPhonDisplay">55 phon</div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">Easy Loudness Control</div>
                </div>
                <input type="range" class="slider" id="fullPlayerLoudnessSlider" min="0" max="100" value="50" step="1" style="width: 100%;">
                <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 11px; color: var(--text-secondary);">
                    <span>Quiet (40 phon)</span>
                    <span style="text-align: center;">
                        <span id="fullPlayerSPLDisplay" style="color: var(--tidal-cyan);">55 dB SPL</span>
                        <span id="fullPlayerHeadroomDisplay" style="color: var(--success); margin-left: 8px;">/ -32.7 dB</span>
                    </span>
                    <span>Loud (90 phon)</span>
                </div>
                <div style="text-align: center; margin-top: 8px;">
                    <span id="fullPlayerStatusDisplay" style="font-size: 12px; color: var(--success);">Safe Level</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden audio element -->
    <audio id="audioElement" crossorigin="anonymous"></audio>
    
    <!-- TIDAL Settings Modal -->
    <div id="tidalSettingsModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>⚙️ TIDAL Settings</h3>
                <button class="modal-close" onclick="hideTidalSettings()">×</button>
            </div>
            <div class="modal-body">
                <div class="control-group">
                    <label style="font-size: 14px; margin-bottom: 8px; display: block;">Access Token</label>
                    <input type="text" id="tidalTokenInput" class="search-input" placeholder="Enter your TIDAL access token" style="margin-bottom: 16px;">
                </div>
                
                <div class="control-group">
                    <label style="font-size: 14px; margin-bottom: 8px; display: block;">Client ID</label>
                    <input type="text" id="clientIdInput" class="search-input" placeholder="zU4XHVVkc2tDPo4t (default)" style="margin-bottom: 16px;">
                </div>
                
                <div class="control-group">
                    <label style="font-size: 14px; margin-bottom: 8px; display: block;">Country Code</label>
                    <input type="text" id="countryCodeInput" class="search-input" placeholder="US" value="US" style="margin-bottom: 16px;">
                </div>
                
                <div style="font-size: 12px; color: var(--text-secondary); line-height: 1.4; margin-bottom: 16px;">
                    <div>💡 How to get your token:</div>
                    <div>1. Use tidal-dl-ng or similar tools</div>
                    <div>2. Or extract from TIDAL web/app</div>
                    <div>3. Tokens expire after ~1 week</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="button secondary" onclick="clearTidalSettings()">Clear</button>
                <button class="button" onclick="saveTidalSettings()">Save</button>
            </div>
        </div>
    </div>

    <!-- Calibration Modal -->
    <div id="calibrationModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🎯 SPL Calibration Setup</h3>
                <button class="modal-close" onclick="hideCalibrationModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="calibration-step">
                    <h4>Step 1: Generate Test Tone</h4>
                    <p>Play pink noise at 80 phon reference level</p>
                    <button class="button" onclick="generateCalibrationTone()" id="calibrationToneBtn">
                        🔊 Play Calibration Tone
                    </button>
                </div>
                
                <div class="calibration-step">
                    <h4>Step 2: Measure SPL</h4>
                    <p>Use a sound level meter (C-weighted, slow) to measure the actual SPL</p>
                    <div class="control-group">
                        <label>Measured SPL (dB):</label>
                        <input type="number" id="measuredSPLInput" min="50" max="120" step="0.1" value="80.0" class="number-input">
                    </div>
                </div>
                
                <div class="calibration-step">
                    <h4>Step 3: Set Target SPL</h4>
                    <p>Choose your preferred listening level</p>
                    <div class="control-group">
                        <label>Target SPL (dB):</label>
                        <input type="number" id="targetSPLInput" min="50" max="90" step="0.1" value="70.0" class="number-input">
                    </div>
                </div>
                
                <div class="calibration-result" id="calibrationResult" style="margin-top: 16px; padding: 12px; background: rgba(0,212,212,0.1); border-radius: 8px; display: none;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Calibration Result:</div>
                    <div>System Offset: <span id="systemOffsetDisplay">0.0 dB</span></div>
                    <div>Master Gain: <span id="autoPreampDisplay">-10.0 dB</span></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="button secondary" onclick="resetCalibration()">Reset</button>
                <button class="button" onclick="applyCalibration()">Apply Calibration</button>
            </div>
        </div>
    </div>

    <script>
        // TIDAL Loudness DSP - Mobile Single File Implementation
        // Core DSP features from the Electron app
        
        // =====================================================
        // OAuth Login Implementation
        // =====================================================
        
        // TIDAL API Configuration
        const TIDAL_API_URL = 'https://api.tidal.com/v1';
        const TIDAL_AUTH_URL = 'https://auth.tidal.com/v1';
        
        // CORS Proxy for web access (optional)
        const USE_CORS_PROXY = false; // Disabled by default due to CORS limitations
        const CORS_PROXY = 'https://cors-anywhere.herokuapp.com/';
        
        // Check if running locally (file:// protocol)
        const IS_LOCAL = window.location.protocol === 'file:';
        
        // Demo mode - only for web hosted versions
        const DEMO_MODE = false;
        
        // Available CORS proxy options (only needed for web)
        const CORS_PROXIES = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/raw?url=',
            'https://cors.bridged.cc/',
            'https://cors-anywhere.herokuapp.com/' // Often rate-limited
        ];
        
        let currentProxyIndex = 0;
        
        // Smart fetch that handles CORS based on environment
        async function fetchWithCORS(url, options = {}) {
            // For local files, always use direct fetch
            if (IS_LOCAL) {
                return fetch(url, options);
            }
            
            // For web, first try direct fetch
            try {
                const response = await fetch(url, options);
                if (response.ok) return response;
            } catch (e) {
                console.log('Direct fetch failed, trying CORS proxies...');
            }
            
            // Try each CORS proxy for web only
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                const proxyIndex = (currentProxyIndex + i) % CORS_PROXIES.length;
                const proxy = CORS_PROXIES[proxyIndex];
                
                try {
                    console.log(`Trying proxy ${proxyIndex}: ${proxy}`);
                    const proxyUrl = proxy + encodeURIComponent(url);
                    const response = await fetch(proxyUrl, {
                        ...options,
                        headers: {
                            ...options.headers,
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    });
                    
                    if (response.ok) {
                        currentProxyIndex = proxyIndex; // Remember working proxy
                        return response;
                    }
                } catch (error) {
                    console.log(`Proxy ${proxyIndex} failed:`, error.message);
                }
            }
            
            throw new Error('All CORS proxies failed');
        }
        
        function getAuthUrl(path) {
            if (USE_CORS_PROXY && typeof window !== 'undefined' && window.location.protocol.startsWith('http')) {
                return CORS_PROXY + TIDAL_AUTH_URL + path;
            }
            return TIDAL_AUTH_URL + path;
        }
        
        function getApiUrl(path) {
            if (USE_CORS_PROXY && typeof window !== 'undefined' && window.location.protocol.startsWith('http')) {
                return CORS_PROXY + TIDAL_API_URL + path;
            }
            return TIDAL_API_URL + path;
        }
        
        // Client credentials from tidal-dl-ng
        const CLIENT_ID = 'zU4XHVVkc2tDPo4t';
        const CLIENT_SECRET = 'VJKhDFqJPqvsPVNBV6ukXTJmwlvbttP7wlMlrc72se4=';
        const FIRETV_CLIENT_ID = 'OmDtrzFgyVVL6uW56OnFA2COiabqm';
        
        // Auth state
        let deviceAuthData = null;
        let authInterval = null;
        let expiryInterval = null;
        let currentClientId = CLIENT_ID;
        let currentClientSecret = CLIENT_SECRET;
        
        // Storage keys for authentication
        const AUTH_STORAGE_KEYS = {
            TOKEN: 'tidalToken',
            REFRESH_TOKEN: 'tidalRefreshToken',
            TOKEN_EXPIRY: 'tidalTokenExpiry',
            USER_ID: 'tidalUserId',
            COUNTRY_CODE: 'tidalCountryCode',
            CLIENT_ID: 'tidalClientId'
        };

        // Initialize on page load
        window.addEventListener('load', () => {
            checkAuthStatus();
            // initTIDAL will be called after tidalState is defined
        });

        // Check if user is already authenticated
        function checkAuthStatus() {
            const token = localStorage.getItem(AUTH_STORAGE_KEYS.TOKEN);
            const tokenExpiry = parseInt(localStorage.getItem(AUTH_STORAGE_KEYS.TOKEN_EXPIRY) || '0');
            
            if (token && tokenExpiry > Date.now()) {
                // Valid token exists
                showApp();
                setupTokenRefresh();
            } else if (token) {
                // Token expired, try to refresh
                refreshAuthToken().then(() => {
                    showApp();
                    setupTokenRefresh();
                }).catch(() => {
                    // Refresh failed, show login
                    clearAuthData();
                });
            }
        }

        // Start OAuth device flow
        async function startDeviceAuth(useFireTv = false) {
            console.log('Starting device auth...', useFireTv ? 'Fire TV' : 'Android Auto');
            try {
                const btn = document.getElementById('startAuthBtn');
                if (!btn) {
                    console.error('Start auth button not found');
                    return;
                }
                btn.disabled = true;
                btn.innerHTML = '<span class="loading-spinner"></span>Connecting...';
                
                // Switch client credentials if needed
                if (useFireTv) {
                    currentClientId = FIRETV_CLIENT_ID;
                    currentClientSecret = '';
                } else {
                    currentClientId = CLIENT_ID;
                    currentClientSecret = CLIENT_SECRET;
                }
                
                console.log('Using client ID:', currentClientId);
                
                // Try real API with CORS proxies
                try {
                    const authUrl = TIDAL_AUTH_URL + '/oauth2/device_authorization';
                    const response = await fetchWithCORS(authUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: new URLSearchParams({
                            client_id: currentClientId,
                            scope: 'r_usr+w_usr+w_sub'
                        })
                    });
                    
                    console.log('Response received:', response.status);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Response error:', errorText);
                        throw new Error(`Failed to start device authorization: ${response.status}`);
                    }
                    
                    deviceAuthData = await response.json();
                } catch (apiError) {
                    console.log('API failed, falling back to demo mode:', apiError.message);
                    
                    // Fallback to demo mode
                    deviceAuthData = {
                        deviceCode: 'DEMO-DEVICE-CODE',
                        userCode: 'DEMO-1234',
                        verificationUri: 'tidal.com/link',
                        verificationUriComplete: 'tidal.com/link/DEMO-1234',
                        expiresIn: 300
                    };
                    
                    updateAuthStatus('Using demo mode (CORS proxies failed)', 'warning');
                }
                
                console.log('Device auth data:', deviceAuthData);
                
                // Show device auth info
                document.getElementById('deviceAuthInfo').style.display = 'block';
                document.getElementById('userCode').textContent = deviceAuthData.userCode;
                document.getElementById('verificationUrl').href = 'https://' + deviceAuthData.verificationUriComplete;
                
                // Start expiry countdown
                startExpiryTimer(deviceAuthData.expiresIn);
                
                // Start polling for authorization
                startPolling(deviceAuthData.deviceCode);
                
                // Update status
                updateAuthStatus('Waiting for authorization...', 'info');
                
                // Hide start button
                btn.style.display = 'none';
                
            } catch (error) {
                console.error('Device auth error:', error);
                
                // Try Fire TV credentials if Android Auto fails
                if (!useFireTv) {
                    updateAuthStatus('Trying alternative authentication...', 'warning');
                    setTimeout(() => startDeviceAuth(true), 1000);
                } else {
                    updateAuthStatus('Failed to start authentication', 'error');
                    const btn = document.getElementById('startAuthBtn');
                    btn.disabled = false;
                    btn.innerHTML = 'Connect with TIDAL';
                }
            }
        }

        // Poll for auth completion
        function startPolling(deviceCode) {
            let attempts = 0;
            const maxAttempts = 120;
            let errorCount = 0;
            const maxErrors = 3;
            
            authInterval = setInterval(async () => {
                attempts++;
                
                try {
                    let data;
                    let responseStatus;
                    
                    if (IS_LOCAL) {
                        // Local mode - direct API call
                        const headers = {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        };
                        
                        if (currentClientSecret) {
                            headers['Authorization'] = 'Basic ' + btoa(`${currentClientId}:${currentClientSecret}`);
                        }
                        
                        const response = await fetch(TIDAL_AUTH_URL + '/oauth2/token', {
                            method: 'POST',
                            headers: headers,
                            body: new URLSearchParams({
                                grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
                                device_code: deviceCode,
                                client_id: currentClientId,
                                scope: 'r_usr+w_usr+w_sub'
                            })
                        });
                        
                        data = await response.json();
                        responseStatus = response.status;
                    } else {
                        const headers = {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        };
                        
                        if (currentClientSecret) {
                            headers['Authorization'] = 'Basic ' + btoa(`${currentClientId}:${currentClientSecret}`);
                        }
                        
                        const response = await fetch(getAuthUrl('/oauth2/token'), {
                            method: 'POST',
                            headers: headers,
                            body: new URLSearchParams({
                                grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
                                device_code: deviceCode,
                                client_id: currentClientId,
                                scope: 'r_usr+w_usr+w_sub'
                            })
                        });
                        
                        data = await response.json();
                        responseStatus = response.status;
                    }
                    
                    // Reset error count on successful request
                    errorCount = 0;
                    
                    if (responseStatus === 200) {
                        // Success!
                        clearInterval(authInterval);
                        clearInterval(expiryInterval);
                        
                        // Save tokens
                        saveAuthData(data);
                        
                        // Fetch user session
                        await fetchUserSession(data.access_token);
                        
                        updateAuthStatus('Authentication successful!', 'success');
                        setTimeout(showAuthSuccess, 1000);
                    } else if (data.error === 'authorization_pending') {
                        // Still waiting
                        updateAuthStatus(`Waiting for authorization... (${attempts}/${maxAttempts})`, 'info');
                    } else if (data.error === 'expired_token') {
                        // Expired
                        clearInterval(authInterval);
                        clearInterval(expiryInterval);
                        updateAuthStatus('Authorization expired. Please try again.', 'error');
                        resetAuthUI();
                    }
                } catch (error) {
                    console.error('Polling error:', error);
                    errorCount++;
                    
                    if (errorCount >= maxErrors) {
                        clearInterval(authInterval);
                        clearInterval(expiryInterval);
                        updateAuthStatus('Too many errors during authorization. Please try again.', 'error');
                        resetAuthUI();
                    } else {
                        updateAuthStatus(`Network error. Retrying... (${errorCount}/${maxErrors})`, 'warning');
                    }
                }
                
                if (attempts >= maxAttempts) {
                    clearInterval(authInterval);
                    clearInterval(expiryInterval);
                    updateAuthStatus('Authorization timed out. Please try again.', 'error');
                    resetAuthUI();
                }
            }, 5000);
        }

        // Expiry timer
        function startExpiryTimer(expiresIn) {
            let remaining = expiresIn;
            
            function updateTimer() {
                const minutes = Math.floor(remaining / 60);
                const seconds = remaining % 60;
                document.getElementById('authTimer').textContent = 
                    `Expires in: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                remaining--;
                if (remaining < 0) {
                    clearInterval(expiryInterval);
                    clearInterval(authInterval);
                    updateAuthStatus('Authorization expired. Please try again.', 'error');
                    resetAuthUI();
                }
            }
            
            updateTimer();
            expiryInterval = setInterval(updateTimer, 1000);
        }

        // Use direct token
        async function useDirectToken() {
            const token = document.getElementById('directTokenInput').value.trim();
            
            if (!token) {
                updateAuthStatus('Please enter a token', 'error');
                return;
            }
            
            try {
                if (DEMO_MODE && token === 'DEMO') {
                    // Demo mode - accept "DEMO" as valid token
                    saveAuthData({
                        access_token: 'DEMO-TOKEN-' + Date.now(),
                        expires_in: 86400,
                        userId: 'DEMO-USER',
                        countryCode: 'US'
                    });
                    
                    updateAuthStatus('Demo token accepted!', 'success');
                    setTimeout(showAuthSuccess, 1000);
                } else if (!DEMO_MODE) {
                    // Validate token
                    const response = await fetch(getApiUrl('/sessions?countryCode=US'), {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });
                    
                    if (response.ok) {
                        const sessionData = await response.json();
                        
                        // Save token with 24-hour expiry
                        saveAuthData({
                            access_token: token,
                            expires_in: 86400,
                            userId: sessionData.userId,
                            countryCode: sessionData.countryCode
                        });
                        
                        updateAuthStatus('Token validated successfully!', 'success');
                        setTimeout(showAuthSuccess, 1000);
                    } else {
                        updateAuthStatus('Invalid token. Please check and try again.', 'error');
                    }
                } else {
                    updateAuthStatus('In demo mode, use "DEMO" as token', 'error');
                }
            } catch (error) {
                console.error('Token validation error:', error);
                updateAuthStatus('Failed to validate token', 'error');
            }
        }

        // Fetch user session
        async function fetchUserSession(token) {
            try {
                const apiUrl = IS_LOCAL ? TIDAL_API_URL + '/sessions?countryCode=US' : getApiUrl('/sessions?countryCode=US');
                const response = await fetch(apiUrl, {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        localStorage.setItem(AUTH_STORAGE_KEYS.USER_ID, data.userId);
                        localStorage.setItem(AUTH_STORAGE_KEYS.COUNTRY_CODE, data.countryCode);
                        
                        // Update TIDAL state with new values
                        if (typeof tidalState !== 'undefined') {
                            tidalState.countryCode = data.countryCode;
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to fetch user session:', error);
            }
        }

        // Save authentication data
        function saveAuthData(data) {
            localStorage.setItem(AUTH_STORAGE_KEYS.TOKEN, data.access_token);
            if (data.refresh_token) {
                localStorage.setItem(AUTH_STORAGE_KEYS.REFRESH_TOKEN, data.refresh_token);
            }
            localStorage.setItem(AUTH_STORAGE_KEYS.TOKEN_EXPIRY, Date.now() + (data.expires_in * 1000));
            localStorage.setItem(AUTH_STORAGE_KEYS.CLIENT_ID, currentClientId);
            
            // Update TIDAL state token
            if (typeof tidalState !== 'undefined') {
                tidalState.token = data.access_token;
                tidalState.clientId = currentClientId;
            }
        }

        // Clear authentication
        function clearAuthData() {
            Object.values(AUTH_STORAGE_KEYS).forEach(key => localStorage.removeItem(key));
        }

        // Refresh token
        async function refreshAuthToken() {
            const refreshToken = localStorage.getItem(AUTH_STORAGE_KEYS.REFRESH_TOKEN);
            const savedClientId = localStorage.getItem(AUTH_STORAGE_KEYS.CLIENT_ID) || CLIENT_ID;
            
            if (!refreshToken) {
                throw new Error('No refresh token available');
            }
            
            const clientSecret = savedClientId === FIRETV_CLIENT_ID ? '' : CLIENT_SECRET;
            const headers = {
                'Content-Type': 'application/x-www-form-urlencoded'
            };
            
            if (clientSecret) {
                headers['Authorization'] = 'Basic ' + btoa(`${savedClientId}:${clientSecret}`);
            }
            
            const response = await fetch(getAuthUrl('/oauth2/token'), {
                method: 'POST',
                headers: headers,
                body: new URLSearchParams({
                    grant_type: 'refresh_token',
                    refresh_token: refreshToken,
                    client_id: savedClientId
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to refresh token');
            }
            
            const data = await response.json();
            saveAuthData(data);
            return data.access_token;
        }

        // Setup automatic token refresh
        function setupTokenRefresh() {
            setInterval(async () => {
                const tokenExpiry = parseInt(localStorage.getItem(AUTH_STORAGE_KEYS.TOKEN_EXPIRY) || '0');
                const refreshToken = localStorage.getItem(AUTH_STORAGE_KEYS.REFRESH_TOKEN);
                
                // Refresh if expires in less than 10 minutes
                if (refreshToken && tokenExpiry > 0 && tokenExpiry - Date.now() < 10 * 60 * 1000) {
                    try {
                        await refreshAuthToken();
                        console.log('Token refreshed successfully');
                    } catch (error) {
                        console.error('Failed to refresh token:', error);
                    }
                }
            }, 5 * 60 * 1000); // Check every 5 minutes
        }

        // Update status message
        function updateAuthStatus(message, type = 'info') {
            const statusEl = document.getElementById('authStatus');
            statusEl.style.display = 'block';
            statusEl.className = `auth-status ${type}`;
            statusEl.innerHTML = type === 'info' ? `<span class="loading-spinner"></span>${message}` : message;
        }

        // Show success screen
        function showAuthSuccess() {
            document.getElementById('oauthSection').classList.remove('active');
            document.getElementById('successSection').classList.add('active');
        }

        // Continue to app
        function continueToApp() {
            showApp();
        }

        // Show main app
        function showApp() {
            document.getElementById('loginContainer').classList.add('hidden');
            // Initialize app after showing
            if (typeof initializeApp === 'function') {
                initializeApp();
            }
        }

        // Reset auth UI
        function resetAuthUI() {
            document.getElementById('startAuthBtn').style.display = 'block';
            document.getElementById('startAuthBtn').disabled = false;
            document.getElementById('startAuthBtn').innerHTML = 'Connect with TIDAL';
            document.getElementById('deviceAuthInfo').style.display = 'none';
            clearInterval(authInterval);
            clearInterval(expiryInterval);
        }

        // Logout function
        function logout() {
            if (confirm('Are you sure you want to log out?')) {
                clearAuthData();
                location.reload();
            }
        }
        
        // ISO 226:2003 data
        const ISO_FREQ = [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160,
                         200, 250, 315, 400, 500, 630, 800, 1000, 1250, 1600,
                         2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000];

        const ISO_CURVES = {
            20: [74.3,64.4,56.3,49.5,44.7,40.6,37.5,35.0,33.1,31.6,30.2,28.9,27.7,26.6,25.6,
                 24.7,23.8,22.5,21.2,20.3,19.1,18.1,17.2,16.3,15.0,13.4,11.5,10.4,10.1,11.2,13.4],
            30: [86.3,75.3,66.2,58.4,52.7,48.0,44.4,41.3,39.2,37.3,35.7,34.2,32.9,31.7,30.6,
                 29.5,28.4,27.1,25.8,24.7,23.3,22.1,21.0,19.9,18.2,16.1,14.6,13.6,13.3,14.6,17.1],
            40: [96.9,85.4,76.3,68.3,62.1,57.0,52.5,48.7,46.2,44.0,42.1,40.4,38.9,37.5,36.3,
                 35.1,33.9,32.6,31.2,29.9,28.4,27.1,25.9,24.7,22.9,20.7,19.0,17.8,17.3,18.6,21.4],
            50: [107.6,95.6,86.4,78.3,71.1,65.0,60.1,56.1,53.4,51.0,48.9,47.1,45.4,43.8,42.3,
                 40.9,39.4,38.1,36.6,35.1,33.4,32.0,30.6,29.2,27.4,25.1,23.4,22.1,21.6,22.8,25.8],
            60: [118.6,106.1,96.8,88.4,81.3,75.0,69.2,65.1,62.2,59.6,57.3,55.3,53.5,51.7,50.1,
                 48.6,47.0,45.6,44.0,42.3,40.5,38.9,37.3,35.6,33.7,31.3,29.6,28.3,27.9,29.1,32.3],
            70: [129.5,116.9,107.1,98.3,91.2,84.7,78.5,74.2,71.1,68.2,65.7,63.5,61.5,59.6,57.9,
                 56.2,54.5,53.0,51.3,49.5,47.6,45.8,44.1,42.3,40.1,37.7,35.9,34.6,34.3,35.4,38.7],
            80: [139.9,127.3,117.5,108.6,101.4,94.8,88.4,83.9,80.7,77.6,74.9,72.6,70.4,68.3,66.4,
                 64.6,62.8,61.1,59.3,57.4,55.3,53.4,51.4,49.5,47.2,44.8,43.0,41.7,41.2,42.2,45.6],
            90: [150.2,137.5,127.7,118.7,111.4,104.8,98.4,93.8,90.4,87.1,84.2,81.7,79.4,77.1,75.1,
                 73.3,71.4,69.6,67.6,65.6,63.5,61.5,59.5,57.4,55.1,52.7,50.8,49.4,48.8,49.8,53.2],
            100:[160.4,147.6,137.8,128.8,121.4,114.8,108.3,103.7,100.3,96.9,93.9,91.4,88.9,86.6,84.5,
                 82.5,80.5,78.6,76.6,74.5,72.4,70.3,68.3,66.2,63.9,61.4,59.5,58.1,57.5,58.5,62.0]
        };

        // Application state
        const state = {
            audioContext: null,
            sourceNode: null,
            gainNode: null,
            loudnessConvolver: null,
            eqFilters: [],
            eqPreampNode: null,
            
            isPlaying: false,
            audioLoaded: false,
            audioElement: null,
            
            // Playback modes
            repeatMode: 'off', // 'off', 'all', 'one'
            shuffleEnabled: false,
            
            // Settings
            easyMode: true,
            loudnessEnabled: true,
            headphoneEqEnabled: false,
            headphoneCorrectionMode: 'fir', // Default to FIR mode
            autoPreampEnabled: true, // Auto preamp calculation
            
            // Calibration parameters (from desktop)
            calibrationSPL: 80.0, // SPL at reference 80/80 setting
            desiredSPL: 70.0, // User's desired listening SPL
            systemOffset: 0.0, // Measured SPL - Expected SPL
            isCalibrated: false, // Whether user has calibrated the system
            
            // Loudness parameters
            easyLoudness: 50, // 0-100 scale (default to middle for better volume)
            targetPhon: 70.0,
            referencePhon: 80.0,
            kParameter: 20, // Bass enhancement fall-off rate (0.1-26 range)
            deltaMaxParameter: 20, // Max bass boost (0-80 dB)
            
            // Gain compensation
            masterGain: -30.0, // Master gain in dB (increased headroom for k=20, deltaMax=20)
            preampGain: 0.0,   // Additional preamp gain
            
            // Interpolated ISO data
            fineGrainedISO226: null,
            
            // Filter parameters
            filterTaps: 2047, // Reduced for mobile performance
            deltaMax: 20,
            k: 16
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize ISO data first
            state.fineGrainedISO226 = interpISO(ISO_CURVES, 0.1);
            
            // Then initialize UI
            initializeUI();
            
            // Initialize audio on first user interaction
            document.addEventListener('touchstart', initAudioContext, { once: true });
            document.addEventListener('click', initAudioContext, { once: true });
        });

        // Initialize UI event listeners
        function initializeUI() {
            // Easy mode toggle
            document.getElementById('easyModeToggle').addEventListener('change', (e) => {
                state.easyMode = e.target.checked;
                updateUIMode();
                updateLoudnessFromEasy();
            });
            
            // Easy loudness slider
            document.getElementById('easyLoudnessSlider').addEventListener('input', (e) => {
                state.easyLoudness = parseInt(e.target.value);
                updateEasyDisplay();
                updateLoudnessFromEasy();
                // Sync with other sliders
                const fullPlayerSlider = document.getElementById('fullPlayerLoudnessSlider');
                if (fullPlayerSlider) {
                    fullPlayerSlider.value = state.easyLoudness;
                }
                const miniPlayerSlider = document.getElementById('miniPlayerLoudnessSlider');
                if (miniPlayerSlider) {
                    miniPlayerSlider.value = state.easyLoudness;
                }
            });
            
            // Full player loudness slider
            const fullPlayerLoudnessSlider = document.getElementById('fullPlayerLoudnessSlider');
            if (fullPlayerLoudnessSlider) {
                fullPlayerLoudnessSlider.addEventListener('input', (e) => {
                    state.easyLoudness = parseInt(e.target.value);
                    updateEasyDisplay();
                    updateFullPlayerLoudnessDisplay();
                    updateLoudnessFromEasy();
                    // Sync with other sliders
                    document.getElementById('easyLoudnessSlider').value = state.easyLoudness;
                    const miniSlider = document.getElementById('miniPlayerLoudnessSlider');
                    if (miniSlider) miniSlider.value = state.easyLoudness;
                });
            }
            
            // K parameter slider (bass enhancement)
            document.getElementById('kParameterSlider').addEventListener('input', (e) => {
                state.kParameter = parseFloat(e.target.value);
                document.getElementById('kParameterValue').textContent = state.kParameter.toFixed(1);
                updateEasyDisplay();
                updateLoudnessFromEasy();
            });
            
            // DeltaMax slider (max bass boost)
            document.getElementById('deltaMaxSlider').addEventListener('input', (e) => {
                state.deltaMaxParameter = parseFloat(e.target.value);
                document.getElementById('deltaMaxValue').textContent = state.deltaMaxParameter.toFixed(0) + ' dB';
                updateEasyDisplay();
                updateLoudnessFromEasy();
            });
            
            // Advanced controls
            document.getElementById('loudnessToggle').addEventListener('change', (e) => {
                state.loudnessEnabled = e.target.checked;
                updateAudioGraph();
            });
            
            document.getElementById('targetPhonSlider').addEventListener('input', (e) => {
                state.targetPhon = parseFloat(e.target.value);
                document.getElementById('targetPhonValue').textContent = state.targetPhon.toFixed(1) + ' phon';
                updateLoudnessFilter();
            });
            
            document.getElementById('referencePhonSlider').addEventListener('input', (e) => {
                state.referencePhon = parseFloat(e.target.value);
                document.getElementById('referencePhonValue').textContent = state.referencePhon.toFixed(1) + ' phon';
                updateLoudnessFilter();
            });
            
            
            // Headphone EQ
            document.getElementById('headphoneEqToggle').addEventListener('change', (e) => {
                state.headphoneEqEnabled = e.target.checked;
                updateAudioGraph();
            });
            
            document.getElementById('eqFileInput').addEventListener('change', handleEqFileLoad);
            
            // Audio file input
            document.getElementById('audioFileInput').addEventListener('change', handleAudioFileLoad);
            
            // Master gain slider
            document.getElementById('masterGainSlider').addEventListener('input', (e) => {
                state.masterGain = parseFloat(e.target.value);
                document.getElementById('masterGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                updateMasterGain();
            });
            
            // Set initial UI state
            updateUIMode();
            updateEasyDisplay();
            updateCalibrationDisplay();
            
            // Initialize full player loudness slider value
            const fullPlayerSlider = document.getElementById('fullPlayerLoudnessSlider');
            if (fullPlayerSlider) {
                fullPlayerSlider.value = state.easyLoudness;
            }
            
            // Initialize mini player loudness slider value
            const miniPlayerSlider = document.getElementById('miniPlayerLoudnessSlider');
            if (miniPlayerSlider) {
                miniPlayerSlider.value = state.easyLoudness;
                miniPlayerSlider.addEventListener('input', (e) => {
                    state.easyLoudness = parseInt(e.target.value);
                    updateEasyDisplay();
                    updateMiniPlayerDisplay();
                    updateFullPlayerLoudnessDisplay();
                    updateLoudnessFromEasy();
                    // Sync with other sliders
                    document.getElementById('easyLoudnessSlider').value = state.easyLoudness;
                    const fullSlider = document.getElementById('fullPlayerLoudnessSlider');
                    if (fullSlider) fullSlider.value = state.easyLoudness;
                });
            }
        }

        // Initialize Web Audio API
        async function initAudioContext() {
            if (state.audioContext) return;
            
            try {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create nodes
                state.gainNode = state.audioContext.createGain();
                updateMasterGain(); // Apply master gain setting
                state.gainNode.connect(state.audioContext.destination);
                
                // Update status
                document.getElementById('audioContextStatus').textContent = 'Ready';
                document.getElementById('audioContextStatus').style.color = 'var(--success)';
                document.getElementById('sampleRateDisplay').textContent = state.audioContext.sampleRate + ' Hz';
                
                // Create initial loudness filter if in easy mode
                if (state.easyMode && state.fineGrainedISO226) {
                    await updateLoudnessFilter();
                }
                
                showToast('Audio system initialized');
            } catch (error) {
                console.error('Failed to initialize audio:', error);
                showToast('Failed to initialize audio', 'error');
            }
        }

        // Update UI based on Easy Mode
        function updateUIMode() {
            const advancedControls = document.getElementById('advancedControls');
            if (state.easyMode) {
                advancedControls.classList.add('hidden');
            } else {
                advancedControls.classList.remove('hidden');
            }
        }

        // Update Easy Mode display
        function updateEasyDisplay() {
            const phon = easyToPhon(state.easyLoudness);
            const spl = phonToSPL(phon);
            
            // Calculate total gain for headroom
            const loudnessPreamp = state.loudnessEnabled ? calculateSPLPreamp(state.targetPhon) : 0;
            const bassBoost = state.loudnessEnabled && state.easyMode ? 
                (state.deltaMaxParameter * Math.exp(-(state.targetPhon - 40) / state.kParameter)) : 0;
            const totalLoudnessGain = loudnessPreamp + (bassBoost > 1 ? Math.log10(bassBoost) * 20 : 0);
            const totalGain = state.masterGain + totalLoudnessGain;
            const headroom = -totalGain; // Negative of total gain = headroom to 0dBFS
            
            document.getElementById('easyPhonDisplay').textContent = phon.toFixed(0) + ' phon';
            document.getElementById('easySPLDisplay').textContent = spl.toFixed(0) + ' dB';
            
            // Update headroom display
            const headroomDisplay = document.getElementById('easyHeadroomDisplay');
            if (headroomDisplay) {
                headroomDisplay.textContent = `/ ${headroom > 0 ? '-' : '+'}${Math.abs(headroom).toFixed(1)} dB`;
                // Color based on headroom
                if (headroom < 3) {
                    headroomDisplay.style.color = 'var(--danger)'; // Red - clipping risk
                } else if (headroom < 6) {
                    headroomDisplay.style.color = 'var(--warning)'; // Yellow - caution
                } else {
                    headroomDisplay.style.color = 'var(--success)'; // Green - safe
                }
            }
            
            // Update filter display
            const params = calculateLoudnessAwareParameters(phon);
            const gap = params.gap;
            const filterDisplay = document.getElementById('easyFilterDisplay');
            if (filterDisplay) {
                if (phon >= 85) {
                    filterDisplay.textContent = 'OFF (No compensation needed)';
                    filterDisplay.style.color = 'var(--text-secondary)';
                } else {
                    filterDisplay.textContent = `${phon.toFixed(1)} → ${(phon + gap).toFixed(1)} phon`;
                    filterDisplay.style.color = 'var(--tidal-cyan)';
                }
            }
            
            // Update compensation status with enhanced bass
            if (gap > 5) {
                document.getElementById('easyCompDisplay').textContent = 'ON (Gap: ' + gap.toFixed(0) + ' phon)';
            } else if (phon >= 85) {
                document.getElementById('easyCompDisplay').textContent = 'OFF';
            } else {
                document.getElementById('easyCompDisplay').textContent = 'Minimal';
            }
            
            // Update safety status
            const statusDisplay = document.getElementById('easyStatusDisplay');
            if (spl <= 70) {
                statusDisplay.textContent = 'Safe Level';
                statusDisplay.style.color = 'var(--success)';
            } else if (spl <= 85) {
                statusDisplay.textContent = 'Moderate Level';
                statusDisplay.style.color = 'var(--warning)';
            } else {
                statusDisplay.textContent = 'Loud - Use Caution';
                statusDisplay.style.color = 'var(--danger)';
            }
            
            // Also update other displays
            updateFullPlayerLoudnessDisplay();
            updateMiniPlayerDisplay();
        }
        
        // Update Full Player Loudness display
        function updateFullPlayerLoudnessDisplay() {
            const phon = easyToPhon(state.easyLoudness);
            const spl = phonToSPL(phon);
            
            // Calculate total gain for headroom
            const loudnessPreamp = state.loudnessEnabled ? calculateSPLPreamp(state.targetPhon) : 0;
            const bassBoost = state.loudnessEnabled && state.easyMode ? 
                (state.deltaMaxParameter * Math.exp(-(state.targetPhon - 40) / state.kParameter)) : 0;
            const totalLoudnessGain = loudnessPreamp + (bassBoost > 1 ? Math.log10(bassBoost) * 20 : 0);
            const totalGain = state.masterGain + totalLoudnessGain;
            const headroom = -totalGain; // Negative of total gain = headroom to 0dBFS
            
            const phonDisplay = document.getElementById('fullPlayerPhonDisplay');
            const splDisplay = document.getElementById('fullPlayerSPLDisplay');
            const headroomDisplay = document.getElementById('fullPlayerHeadroomDisplay');
            const statusDisplay = document.getElementById('fullPlayerStatusDisplay');
            
            if (phonDisplay) {
                phonDisplay.textContent = phon.toFixed(0) + ' phon';
            }
            
            if (splDisplay) {
                splDisplay.textContent = spl.toFixed(0) + ' dB SPL';
            }
            
            if (headroomDisplay) {
                headroomDisplay.textContent = `/ ${headroom > 0 ? '-' : '+'}${Math.abs(headroom).toFixed(1)} dB`;
                // Color based on headroom
                if (headroom < 3) {
                    headroomDisplay.style.color = 'var(--danger)'; // Red - clipping risk
                } else if (headroom < 6) {
                    headroomDisplay.style.color = 'var(--warning)'; // Yellow - caution
                } else {
                    headroomDisplay.style.color = 'var(--success)'; // Green - safe
                }
            }
            
            if (statusDisplay) {
                if (spl <= 70) {
                    statusDisplay.textContent = 'Safe Level';
                    statusDisplay.style.color = 'var(--success)';
                } else if (spl <= 85) {
                    statusDisplay.textContent = 'Moderate Level';
                    statusDisplay.style.color = 'var(--warning)';
                } else {
                    statusDisplay.textContent = 'Loud - Use Caution';
                    statusDisplay.style.color = 'var(--danger)';
                }
            }
        }

        // Convert Easy slider (0-100) to phon using desktop's enhanced algorithm
        function easyToPhon(easyValue) {
            // Desktop enhanced parameters
            const Lmin = 40;  // Minimum SPL 
            const Lmax = 90;  // Maximum SPL
            
            // Linear mapping from slider to phon range
            const targetPhon = Lmin + (easyValue / 100) * (Lmax - Lmin);
            return targetPhon;
        }

        // Convert phon to calibrated SPL
        function phonToSPL(phon) {
            // Use calibration: if we're at calibrationSPL phon, output should be calibrationSPL dB SPL
            // This accounts for the user's specific listening setup
            return phon;
        }

        // Calculate SPL-based preamp for calibration
        function calculateSPLPreamp(targetPhon) {
            if (!state.isCalibrated) return 0;
            
            // Calculate the preamp needed based on calibration
            // If we measured 85 dB when expecting 80 dB, systemOffset = +5 dB
            // If user wants to listen at 70 dB, we need to reduce by additional amount
            const targetSPL = state.desiredSPL;
            const referenceSPL = state.calibrationSPL;
            
            // Basic SPL difference
            const splDifference = targetSPL - referenceSPL;
            
            // Apply system offset correction
            const preamp = splDifference - state.systemOffset;
            
            console.log(`[SPL Preamp] Target SPL: ${targetSPL}, Reference SPL: ${referenceSPL}, System Offset: ${state.systemOffset}, Preamp: ${preamp}`);
            
            return preamp;
        }

        // Calculate loudness parameters using enhanced bass algorithm with adjustable k
        function calculateLoudnessAwareParameters(targetPhon) {
            // Enhanced bass parameters (ChatGPT-o3 recommendation)
            const Lmin = 40;      // Minimum SPL
            const Lmax = 90;      // Maximum SPL  
            const k = state.kParameter;  // User-adjustable fall-off rate (0.1-26)
            const deltaMax = state.deltaMaxParameter;  // User-adjustable max bass boost (0-80 dB)
            const deltaMin = 1;   // Minimum phon gap
            
            const L = targetPhon;
            
            // Option A + B Combined: Adaptive parameters + headroom protection
            // Step 1: Adjust k and deltaMax based on phon range (Option A)
            let adaptiveK = k;
            let adaptiveDeltaMax = deltaMax;
            
            if (L < 55) {
                adaptiveK = 18;
                adaptiveDeltaMax = 20;
            } else if (L < 60) {
                adaptiveK = 18;
                adaptiveDeltaMax = 16;
            } else if (L < 65) {
                adaptiveK = 26;
                adaptiveDeltaMax = 8;
            } else if (L < 70) {
                adaptiveK = 30;
                adaptiveDeltaMax = 6;
            } else if (L < 80) {
                adaptiveK = 35;
                adaptiveDeltaMax = 4;
            } else {
                // 80+ phon: rapid fade out
                adaptiveK = 40;
                adaptiveDeltaMax = 3;
            }
            
            // Enhanced exponential decay with adaptive parameters
            const gapRaw = deltaMin + (adaptiveDeltaMax - deltaMin) * Math.exp(-(L - Lmin) / adaptiveK);
            
            // Step 2: Apply headroom protection (Option B)
            const crest = 6;    // Programme peaks in dB (worst case)
            const safety = 1;   // True-peak guard in dB
            const masterGainMagnitude = Math.abs(state.masterGain); // e.g., 30 for -30 dB
            const maxAllowedBoost = masterGainMagnitude - crest - safety; // e.g., 30-6-1 = 23 dB
            
            // Scale down the gap if it would exceed headroom
            const headroomScale = Math.min(1, maxAllowedBoost / gapRaw);
            
            // Step 3: Smooth fade-out for high SPL (80-85 phon)
            let fadeScale = 1;
            if (L >= 80) {
                // Smooth fade from 80 to 85 phon (complete off at 85)
                fadeScale = Math.max(0, 1 - (L - 80) / 5);
            }
            
            // Apply both scales
            const gap = gapRaw * headroomScale * fadeScale;
            
            // Log detailed info
            if (headroomScale < 1 || fadeScale < 1) {
                console.log(`[Adaptive Loudness] L=${L.toFixed(1)}, k=${adaptiveK}, δMax=${adaptiveDeltaMax}, ` +
                           `Raw=${gapRaw.toFixed(1)}dB, Headroom=${headroomScale.toFixed(2)}, ` +
                           `Fade=${fadeScale.toFixed(2)}, Final=${gap.toFixed(1)}dB`);
            }
            
            // Calculate reference phon
            let referencePhon = L + gap;
            
            // Desktop-style master gain calculation (bypasses auto preamp)
            const targetMasterGain = targetPhon - state.calibrationSPL + state.systemOffset;
            
            // Log bass enhancement level for debugging
            console.log(`[Bass Enhancement] k=${k.toFixed(1)}, Target=${L.toFixed(1)} phon, Gap=${gap.toFixed(1)} phon`);
            
            return {
                targetPhon: targetPhon,
                referencePhon: referencePhon,
                masterGain: targetMasterGain,
                gap: gap
            };
        }

        // Update loudness parameters from Easy Mode (desktop logic)
        function updateLoudnessFromEasy() {
            if (state.easyMode) {
                const targetPhon = easyToPhon(state.easyLoudness);
                
                // Get adaptive k and deltaMax based on targetPhon
                let adaptiveK = 20;
                let adaptiveDeltaMax = 20;
                
                if (targetPhon < 55) {
                    adaptiveK = 18;
                    adaptiveDeltaMax = 20;
                } else if (targetPhon < 60) {
                    adaptiveK = 18;
                    adaptiveDeltaMax = 16;
                } else if (targetPhon < 65) {
                    adaptiveK = 22;
                    adaptiveDeltaMax = 12;
                } else if (targetPhon < 70) {
                    adaptiveK = 24;
                    adaptiveDeltaMax = 10;
                } else if (targetPhon < 80) {
                    adaptiveK = 30;
                    adaptiveDeltaMax = 6;
                } else {
                    adaptiveK = 40;
                    adaptiveDeltaMax = 3;
                }
                
                // Update k and deltaMax sliders dynamically
                state.kParameter = adaptiveK;
                state.deltaMaxParameter = adaptiveDeltaMax;
                
                // Update UI sliders
                const kSlider = document.getElementById('kParameterSlider');
                const deltaMaxSlider = document.getElementById('deltaMaxSlider');
                if (kSlider) {
                    kSlider.value = adaptiveK;
                    document.getElementById('kParameterValue').textContent = adaptiveK.toFixed(1);
                }
                if (deltaMaxSlider) {
                    deltaMaxSlider.value = adaptiveDeltaMax;
                    document.getElementById('deltaMaxValue').textContent = adaptiveDeltaMax + ' dB';
                }
                
                const params = calculateLoudnessAwareParameters(targetPhon);
                
                // Update state with calculated parameters
                state.targetPhon = params.targetPhon;
                state.referencePhon = params.referencePhon;
                
                // Desktop-style: disable auto preamp, use direct master gain calculation
                state.autoPreampEnabled = false;
                state.masterGain = params.masterGain;
                
                // Update advanced sliders (even if hidden)
                document.getElementById('targetPhonSlider').value = state.targetPhon;
                document.getElementById('targetPhonValue').textContent = state.targetPhon.toFixed(1) + ' phon';
                document.getElementById('referencePhonSlider').value = state.referencePhon;
                document.getElementById('referencePhonValue').textContent = state.referencePhon.toFixed(1) + ' phon';
                
                // Update master gain slider and display
                document.getElementById('masterGainSlider').value = state.masterGain;
                document.getElementById('masterGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                
                console.log(`[Easy Mode] Target: ${params.targetPhon.toFixed(1)} phon, Reference: ${params.referencePhon.toFixed(1)} phon, Gap: ${params.gap.toFixed(1)}, Master gain: ${params.masterGain.toFixed(1)} dB`);
                
                // Only update loudness filter if audio context is ready
                if (state.audioContext) {
                    updateLoudnessFilter();
                }
                updateMasterGain(); // Apply the calculated master gain
            }
        }

        // ISO-226 interpolation
        function interpISO(curves, step = 0.1) {
            const fine = {};
            const keys = Object.keys(curves).map(Number).sort((a, b) => a - b);
            
            for (let p = keys[0]; p <= keys[keys.length - 1]; p += step) {
                p = Math.round(p * 10) / 10;
                if (curves[p]) {
                    fine[p] = curves[p].slice();
                    continue;
                }
                
                const lo = Math.max(...keys.filter(k => k <= p));
                const hi = Math.min(...keys.filter(k => k >= p));
                const w = (p - lo) / (hi - lo);
                
                fine[p] = curves[lo].map((v, i) => v * (1 - w) + curves[hi][i] * w);
            }
            
            return fine;
        }

        // Calculate ISO gain (exactly like desktop version)
        function isoGain(targetPhon, refPhon, fineData) {
            const T = fineData[Math.round(targetPhon * 10) / 10];   // 목표
            const R = fineData[Math.round(refPhon * 10) / 10];      // 기준
            
            if (!T || !R) {
                console.error('Invalid phon values:', targetPhon, refPhon);
                return new Array(ISO_FREQ.length).fill(0);
            }
            
            const oneKhzIdx = ISO_FREQ.indexOf(1000);
            const anchorT = T[oneKhzIdx];
            const anchorR = R[oneKhzIdx];
            
            // 목표 – 기준  (1 kHz에서는 항상 0 dB)
            const result = T.map((v, i) => (v - anchorT) - (R[i] - anchorR));
            
            // Debug logging for unusual cases
            if (Math.abs(targetPhon - refPhon) < 0.1) {
                console.log(`[isoGain] Same levels: ${targetPhon} → ${refPhon}`);
                console.log(`  1kHz delta: ${result[oneKhzIdx].toFixed(2)} dB`);
                console.log(`  Max gain: ${Math.max(...result).toFixed(6)} dB`);
                console.log(`  Min gain: ${Math.min(...result).toFixed(6)} dB`);
                console.log(`  All gains:`, result.slice(0, 10).map(g => g.toFixed(3)));
                console.log(`  TEST: Should all be zero for 70→70!`);
            }
            
            return result;
        }

        // Linear interpolation similar to numpy.interp
        function interp(x, xp, fp) {
            const result = new Float32Array(x.length);
            
            for (let i = 0; i < x.length; i++) {
                const xi = x[i];
                
                // Find the right place in the xp array
                let j = 0;
                while (j < xp.length - 1 && xp[j + 1] < xi) {
                    j++;
                }
                
                if (j === xp.length - 1) {
                    result[i] = fp[fp.length - 1];
                } else if (xi <= xp[0]) {
                    result[i] = fp[0];
                } else {
                    // Linear interpolation
                    const x0 = xp[j];
                    const x1 = xp[j + 1];
                    const y0 = fp[j];
                    const y1 = fp[j + 1];
                    const t = (xi - x0) / (x1 - x0);
                    result[i] = y0 * (1 - t) + y1 * t;
                }
            }
            
            return result;
        }

        // Get window function
        function getWindow(window, numtaps) {
            const win = new Float32Array(numtaps);
            
            switch (window) {
                case 'hamming':
                    for (let n = 0; n < numtaps; n++) {
                        win[n] = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (numtaps - 1));
                    }
                    break;
                case 'hann':
                case 'hanning':
                    for (let n = 0; n < numtaps; n++) {
                        win[n] = 0.5 - 0.5 * Math.cos(2 * Math.PI * n / (numtaps - 1));
                    }
                    break;
                default:
                    win.fill(1.0);
            }
            
            return win;
        }


        // FIR filter design using the window method (firwin2)
        function firwin2(numtaps, freq, gain, options = {}) {
            const { window = 'hamming', fs = 2 } = options;
            const nyq = 0.5 * fs;
            
            // Normalize frequencies to [0, 1] where 1 is Nyquist
            const freqNorm = freq.map(f => f / nyq);
            
            // Check inputs
            if (freq.length !== gain.length) {
                throw new Error('freq and gain must be of same length');
            }
            
            if (freqNorm[0] !== 0 || freqNorm[freqNorm.length - 1] !== 1) {
                throw new Error('freq must start with 0 and end with fs/2');
            }
            
            // For even-length filters, force gain at Nyquist to 0
            const ftype = numtaps % 2 === 0 ? 2 : 1;
            if (ftype === 2 && gain[gain.length - 1] !== 0) {
                gain = gain.slice();
                gain[gain.length - 1] = 0;
            }
            
            // Determine nfreqs (power of 2 + 1, larger than numtaps)
            const nfreqs = 1 + Math.pow(2, Math.ceil(Math.log2(numtaps)));
            
            // Create uniform frequency grid from 0 to Nyquist
            const x = new Float32Array(nfreqs);
            for (let i = 0; i < nfreqs; i++) {
                x[i] = i / (nfreqs - 1);  // 0 to 1
            }
            
            // Linearly interpolate the desired magnitude response
            const fx = interp(x, freqNorm, gain);
            
            // Create complex array with linear phase shift (exactly like desktop)
            const fx2 = new Array(nfreqs);
            for (let i = 0; i < nfreqs; i++) {
                const phase = -(numtaps - 1) / 2 * Math.PI * x[i];
                fx2[i] = {
                    real: fx[i] * Math.cos(phase),
                    imag: fx[i] * Math.sin(phase)
                };
            }
            
            // Use inverse real FFT to get time domain coefficients
            const out_full = irfft(fx2);
            
            // Apply window
            const wind = getWindow(window, numtaps);
            
            // Keep only the first numtaps coefficients and multiply by window
            const out = new Float32Array(numtaps);
            for (let i = 0; i < numtaps; i++) {
                out[i] = out_full[i] * wind[i];
            }
            
            return out;
        }
        
        // IRFFT implementation (exactly like desktop)
        function irfft(fx2) {
            const n = (fx2.length - 1) * 2;
            const result = new Float32Array(n);
            
            // Reconstruct the full complex spectrum from the positive frequencies
            const fullSpectrum = new Float32Array(n * 2); // Real and imaginary parts interleaved
            
            // Copy positive frequencies
            for (let i = 0; i < fx2.length; i++) {
                fullSpectrum[i * 2] = fx2[i].real || fx2[i];
                fullSpectrum[i * 2 + 1] = fx2[i].imag || 0;
            }
            
            // Mirror negative frequencies (conjugate symmetry)
            for (let i = 1; i < fx2.length - 1; i++) {
                const idx = n - i;
                fullSpectrum[idx * 2] = fullSpectrum[i * 2]; // Real part stays the same
                fullSpectrum[idx * 2 + 1] = -fullSpectrum[i * 2 + 1]; // Imaginary part negated
            }
            
            // Perform IFFT
            for (let k = 0; k < n; k++) {
                let real = 0;
                for (let j = 0; j < n; j++) {
                    const angle = 2 * Math.PI * j * k / n;
                    real += fullSpectrum[j * 2] * Math.cos(angle) - fullSpectrum[j * 2 + 1] * Math.sin(angle);
                }
                result[k] = real / n;
            }
            
            return result;
        }

        // Design FIR filter using proper firwin2
        function designFIR(targetPhon, refPhon, taps = 721, fs = 48000) {
            if (taps % 2 === 0) taps += 1;
            
            // Ensure ISO data is available
            if (!state.fineGrainedISO226) {
                throw new Error('ISO data not initialized');
            }
            
            const gDb = isoGain(targetPhon, refPhon, state.fineGrainedISO226);
            
            console.log('ISO gain (dB):', gDb.slice(0, 10).map(g => g.toFixed(2))); // First 10 values
            console.log('1kHz gain (dB):', gDb[ISO_FREQ.indexOf(1000)].toFixed(3));
            
            // Check if this is essentially a flat response (70-70 case)
            const maxGain = Math.max(...gDb);
            const minGain = Math.min(...gDb);
            const gainRange = maxGain - minGain;
            
            console.log(`Gain range: ${gainRange.toFixed(3)} dB (max: ${maxGain.toFixed(2)}, min: ${minGain.toFixed(2)})`);
            
            // If the gain variation is very small, create a unity filter
            if (gainRange < 0.1) {
                console.log('Creating unity filter (flat response)');
                const fir = new Float32Array(taps);
                fir[Math.floor(taps / 2)] = 1.0; // Unity impulse at center
                return fir;
            }
            
            // Convert to linear scale (부호 반전)
            const gainLinear = gDb.map(g => Math.pow(10, -g / 20));
            
            const nyq = fs / 2;
            
            // Build frequency and gain arrays for firwin2 (20Hz부터 시작)
            const freq = [0, 20];
            const gain = [gainLinear[ISO_FREQ.indexOf(20)], gainLinear[ISO_FREQ.indexOf(20)]];
            
            // Add ISO frequencies that are below Nyquist
            for (let i = 0; i < ISO_FREQ.length; i++) {
                if (ISO_FREQ[i] < nyq) {
                    freq.push(ISO_FREQ[i]);
                    gain.push(gainLinear[i]);
                }
            }
            
            // Add Nyquist frequency
            freq.push(nyq);
            gain.push(gainLinear[gainLinear.length - 1]);
            
            // Debug logging
            console.log('FIR Design Parameters:');
            console.log('  Target phon:', targetPhon);
            console.log('  Reference phon:', refPhon);
            console.log('  Sample rate:', fs);
            console.log('  Filter taps:', taps);
            console.log('  Gain at key frequencies:');
            const keyFreqs = [20, 100, 1000, 10000, 20000];
            for (let i = 0; i < freq.length; i++) {
                if (keyFreqs.includes(freq[i])) {
                    console.log(`    ${freq[i]} Hz: ${(20 * Math.log10(gain[i])).toFixed(2)} dB`);
                }
            }
            
            // Design filter using firwin2
            const fir = firwin2(taps, freq, gain, {
                fs: fs,
                window: 'hamming'
            });
            
            // Normalize at 1 kHz
            const w = 2 * Math.PI * 1000 / fs;
            let h_at_1k = 0;
            for (let n = 0; n < fir.length; n++) {
                h_at_1k += fir[n] * Math.cos(w * n);
            }
            
            // Normalize with gain compensation
            const normFactor = 1 / Math.abs(h_at_1k);
            
            // Normalize (exactly like desktop version - no extra gain boost)
            for (let i = 0; i < fir.length; i++) {
                fir[i] *= normFactor;
            }
            
            // Verify the filter response at key frequencies
            const sumCoeff = fir.reduce((a, b) => a + b, 0);
            console.log('Filter verification:');
            console.log('  Target phon:', targetPhon, 'Reference phon:', refPhon);
            console.log('  Peak coefficient:', Math.max(...fir.map(Math.abs)).toFixed(6));
            console.log('  Sum of coefficients:', sumCoeff.toFixed(6));
            console.log('  Center tap value:', fir[Math.floor(taps / 2)].toFixed(6));
            console.log(`  TEST: For 70→70, sum should be 1.0, got ${sumCoeff.toFixed(6)}`);
            
            // Check frequency response at key frequencies
            const testFreqs = [100, 1000, 3000, 10000];
            console.log('  Frequency response:');
            for (const freq of testFreqs) {
                const omega = 2 * Math.PI * freq / fs;
                let real = 0, imag = 0;
                for (let n = 0; n < fir.length; n++) {
                    real += fir[n] * Math.cos(omega * n);
                    imag -= fir[n] * Math.sin(omega * n);
                }
                const magnitude = Math.sqrt(real * real + imag * imag);
                const magDB = 20 * Math.log10(magnitude);
                console.log(`    ${freq} Hz: ${magDB.toFixed(2)} dB (linear: ${magnitude.toFixed(4)})`);
            }
            
            return fir;
        }

        // Update loudness filter
        async function updateLoudnessFilter() {
            if (!state.audioContext) return;
            
            // Ensure ISO data is initialized
            if (!state.fineGrainedISO226) {
                console.warn('ISO data not yet initialized, initializing now...');
                state.fineGrainedISO226 = interpISO(ISO_CURVES, 0.1);
            }
            
            try {
                const fir = designFIR(state.targetPhon, state.referencePhon, 
                                    state.filterTaps, state.audioContext.sampleRate);
                
                // Create convolver buffer
                const filterBuffer = state.audioContext.createBuffer(1, fir.length, state.audioContext.sampleRate);
                const channelData = filterBuffer.getChannelData(0);
                channelData.set(fir);
                
                // Create new convolver
                const newConvolver = state.audioContext.createConvolver();
                newConvolver.normalize = false; // CRITICAL: Disable automatic normalization!
                newConvolver.buffer = filterBuffer;
                
                // Replace old convolver
                const oldConvolver = state.loudnessConvolver;
                state.loudnessConvolver = newConvolver;
                
                // Reconnect audio graph
                updateAudioGraph();
                
                // Clean up old convolver
                if (oldConvolver) {
                    try {
                        oldConvolver.disconnect();
                    } catch (e) {}
                }
                
                // Update status
                document.getElementById('loudnessFilterStatus').textContent = 
                    `${state.targetPhon.toFixed(1)} → ${state.referencePhon.toFixed(1)} phon`;
                
                updateTotalGain();
            } catch (error) {
                console.error('Failed to update loudness filter:', error);
                console.error('Error details:', {
                    targetPhon: state.targetPhon,
                    referencePhon: state.referencePhon,
                    filterTaps: state.filterTaps,
                    sampleRate: state.audioContext?.sampleRate,
                    audioContextState: state.audioContext?.state,
                    fineGrainedISO226: state.fineGrainedISO226 ? 'initialized' : 'not initialized'
                });
                showToast('Failed to update loudness filter: ' + error.message, 'error');
            }
        }

        // Parse AutoEQ file
        function parseEqFile(content) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith(';'));
            
            let preamp = 0;
            const filters = [];
            
            for (const line of lines) {
                if (line.startsWith('Preamp:')) {
                    preamp = parseFloat(line.split(':')[1]) || 0;
                } else if (line.startsWith('Filter')) {
                    const parts = line.split(/\s+/);
                    if (parts.length >= 6) {
                        const type = parts[2];
                        const freq = parseFloat(parts[4]);
                        const gain = parseFloat(parts[6]);
                        let q = 1.0;
                        
                        if (parts.length >= 8) {
                            q = parseFloat(parts[8]) || 1.0;
                        }
                        
                        filters.push({ type, freq, gain, q });
                    }
                }
            }
            
            return { preamp, filters };
        }

        // Handle EQ file load
        function handleEqFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    const { preamp, filters } = parseEqFile(content);
                    
                    if (filters.length === 0) {
                        showToast('No valid EQ filters found', 'error');
                        return;
                    }
                    
                    applyParametricEQ(preamp, filters);
                    
                    // Update status
                    const statusEl = document.getElementById('eqStatus');
                    statusEl.textContent = `Loaded: ${file.name} (${filters.length} filters, Preamp: ${preamp.toFixed(1)} dB)`;
                    statusEl.className = 'status-message status-success';
                    statusEl.classList.remove('hidden');
                    
                    document.getElementById('headphoneEqStatus').textContent = `${filters.length} filters`;
                    
                    showToast('EQ profile loaded successfully');
                } catch (error) {
                    console.error('Failed to parse EQ file:', error);
                    showToast('Failed to parse EQ file', 'error');
                }
            };
            
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // Apply parametric EQ
        function applyParametricEQ(preamp, filters) {
            if (!state.audioContext) return;
            
            try {
                // Clear existing EQ
                state.eqFilters.forEach(node => {
                    try { node.disconnect(); } catch (e) {}
                });
                state.eqFilters = [];
                
                // Create preamp gain node
                if (state.eqPreampNode) {
                    try { state.eqPreampNode.disconnect(); } catch (e) {}
                }
                state.eqPreampNode = state.audioContext.createGain();
                const preampValue = parseFloat(preamp) || 0;
                state.eqPreampNode.gain.value = Math.pow(10, preampValue / 20);
                
                // Create filter nodes
                filters.forEach(filter => {
                    const filterNode = state.audioContext.createBiquadFilter();
                    
                    switch (filter.type.toUpperCase()) {
                        case 'PK':
                        case 'PEAK':
                            filterNode.type = 'peaking';
                            break;
                        case 'HS':
                        case 'HIGHSHELF':
                            filterNode.type = 'highshelf';
                            break;
                        case 'LS':
                        case 'LOWSHELF':
                            filterNode.type = 'lowshelf';
                            break;
                        default:
                            filterNode.type = 'peaking';
                    }
                    
                    const freq = parseFloat(filter.freq);
                    const gain = parseFloat(filter.gain);
                    const q = parseFloat(filter.q);
                    
                    if (!isNaN(freq) && isFinite(freq)) {
                        filterNode.frequency.value = Math.max(20, Math.min(20000, freq));
                    }
                    if (!isNaN(gain) && isFinite(gain)) {
                        filterNode.gain.value = gain;
                    }
                    if (!isNaN(q) && isFinite(q)) {
                        filterNode.Q.value = Math.max(0.1, Math.min(30, q));
                    }
                    
                    state.eqFilters.push(filterNode);
                });
                
                // Connect filters in series
                for (let i = 0; i < state.eqFilters.length - 1; i++) {
                    state.eqFilters[i].connect(state.eqFilters[i + 1]);
                }
                
                // Update audio graph
                updateAudioGraph();
                updateTotalGain();
                
            } catch (error) {
                console.error('Failed to apply EQ:', error);
                showToast('Failed to apply EQ', 'error');
            }
        }

        // Update audio graph connections
        function updateAudioGraph() {
            if (!state.sourceNode || !state.audioContext) return;
            
            try {
                // Disconnect everything
                state.sourceNode.disconnect();
                if (state.loudnessConvolver) state.loudnessConvolver.disconnect();
                if (state.eqPreampNode) state.eqPreampNode.disconnect();
                state.eqFilters.forEach(node => {
                    try { node.disconnect(); } catch (e) {}
                });
                
                let currentNode = state.sourceNode;
                
                // Apply loudness compensation
                if (state.loudnessEnabled && state.loudnessConvolver) {
                    currentNode.connect(state.loudnessConvolver);
                    currentNode = state.loudnessConvolver;
                }
                
                // Apply headphone EQ
                if (state.headphoneEqEnabled && state.eqPreampNode && state.eqFilters.length > 0) {
                    currentNode.connect(state.eqPreampNode);
                    state.eqPreampNode.connect(state.eqFilters[0]);
                    
                    for (let i = 0; i < state.eqFilters.length - 1; i++) {
                        state.eqFilters[i].connect(state.eqFilters[i + 1]);
                    }
                    
                    currentNode = state.eqFilters[state.eqFilters.length - 1];
                }
                
                // Connect to output
                currentNode.connect(state.gainNode);
                
            } catch (error) {
                console.error('Error updating audio graph:', error);
            }
        }

        // Handle audio file load
        function handleAudioFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const audio = document.getElementById('audioElement');
            const url = URL.createObjectURL(file);
            
            audio.src = url;
            state.audioLoaded = true;
            state.audioElement = audio; // Set state.audioElement for playback controls
            
            // Update UI
            document.getElementById('audioTitle').textContent = file.name;
            document.getElementById('audioStatus').textContent = 'Ready to play';
            document.getElementById('audioPlayer').classList.add('active');
            
            // Initialize audio context if needed
            if (!state.audioContext) {
                initAudioContext();
            }
            
            // Create source node
            if (!state.sourceNode) {
                state.sourceNode = state.audioContext.createMediaElementSource(audio);
                updateAudioGraph();
            }
            
            showToast('Audio file loaded');
            event.target.value = ''; // Reset input
        }

        // Generate test tone
        function generateTestTone() {
            if (!state.audioContext) {
                initAudioContext();
            }
            
            // Create oscillator
            const oscillator = state.audioContext.createOscillator();
            const gainNode = state.audioContext.createGain();
            
            oscillator.frequency.value = 1000; // 1 kHz
            gainNode.gain.value = 0.316; // -10 dB
            
            // Connect through processing chain
            oscillator.connect(gainNode);
            
            let currentNode = gainNode;
            
            // Apply loudness compensation
            if (state.loudnessEnabled && state.loudnessConvolver) {
                currentNode.connect(state.loudnessConvolver);
                currentNode = state.loudnessConvolver;
            }
            
            // Apply headphone EQ
            if (state.headphoneEqEnabled && state.eqPreampNode && state.eqFilters.length > 0) {
                currentNode.connect(state.eqPreampNode);
                state.eqPreampNode.connect(state.eqFilters[0]);
                currentNode = state.eqFilters[state.eqFilters.length - 1];
            }
            
            currentNode.connect(state.gainNode);
            
            // Play for 1 second
            oscillator.start();
            oscillator.stop(state.audioContext.currentTime + 1);
            
            // Update UI
            document.getElementById('audioTitle').textContent = '1 kHz Test Tone';
            document.getElementById('audioStatus').textContent = 'Playing...';
            document.getElementById('audioPlayer').classList.add('active');
            
            setTimeout(() => {
                document.getElementById('audioStatus').textContent = 'Finished';
            }, 1000);
            
            showToast('Playing 1 kHz test tone');
        }

        // Test function: Generate Dirac delta impulse for ConvolverNode test
        function testDiracDelta() {
            if (!state.audioContext) {
                initAudioContext();
                return;
            }
            
            console.log('=== DIRAC DELTA TEST ===');
            
            // Create Dirac delta: [1, 0, 0, 0, ...]
            const taps = 8192;
            const dirac = new Float32Array(taps);
            dirac[Math.floor(taps / 2)] = 1.0; // Unity impulse at center
            
            // Create buffer
            const buffer = state.audioContext.createBuffer(1, taps, state.audioContext.sampleRate);
            buffer.getChannelData(0).set(dirac);
            
            // Test with normalize = true (default)
            const convolverNorm = state.audioContext.createConvolver();
            convolverNorm.normalize = true;
            convolverNorm.buffer = buffer;
            
            // Test with normalize = false
            const convolverNoNorm = state.audioContext.createConvolver();
            convolverNoNorm.normalize = false;
            convolverNoNorm.buffer = buffer;
            
            console.log('Dirac delta created:', dirac[Math.floor(taps / 2)]);
            console.log('Sum of Dirac:', dirac.reduce((a, b) => a + b, 0));
            console.log('TEST: Play pink noise through both convolvers and compare levels');
            
            showToast('Dirac delta test prepared - check console');
        }

        // Toggle play/pause
        function togglePlayPause() {
            const audio = document.getElementById('audioElement');
            
            if (!state.audioLoaded) {
                showToast('Please select an audio file first', 'warning');
                return;
            }
            
            if (state.isPlaying) {
                audio.pause();
                state.isPlaying = false;
                document.getElementById('playIcon').classList.remove('hidden');
                document.getElementById('pauseIcon').classList.add('hidden');
                document.getElementById('audioStatus').textContent = 'Paused';
            } else {
                audio.play().then(() => {
                    state.isPlaying = true;
                    document.getElementById('playIcon').classList.add('hidden');
                    document.getElementById('pauseIcon').classList.remove('hidden');
                    document.getElementById('audioStatus').textContent = 'Playing';
                }).catch(error => {
                    console.error('Playback failed:', error);
                    showToast('Playback failed', 'error');
                });
            }
        }

        // Update total gain display
        function updateTotalGain() {
            let totalGain = state.masterGain; // Use actual master gain
            
            // Add loudness compensation gain (approximate)
            if (state.loudnessEnabled) {
                const compensationGain = (state.referencePhon - state.targetPhon) * 0.3; // Simplified
                totalGain += compensationGain;
            }
            
            // Add EQ preamp gain
            if (state.headphoneEqEnabled && state.eqPreampNode) {
                const preampGain = 20 * Math.log10(state.eqPreampNode.gain.value);
                totalGain += preampGain;
            }
            
            document.getElementById('totalGainDisplay').textContent = totalGain.toFixed(1) + ' dB';
            
            // Update signal path visualization
            updateSignalPath();
        }
        
        // Update signal path visualization
        function updateSignalPath() {
            const signalPathEl = document.getElementById('signalPath');
            if (!signalPathEl) return;
            
            // Calculate gains at each stage
            const loudnessPreamp = state.loudnessEnabled ? calculateSPLPreamp(state.targetPhon) : 0;
            const bassBoost = state.loudnessEnabled && state.easyMode ? 
                (state.deltaMaxParameter * Math.exp(-(state.targetPhon - 40) / state.kParameter)) : 0;
            const totalLoudnessGain = loudnessPreamp + (bassBoost > 1 ? Math.log10(bassBoost) * 20 : 0);
            
            // Build signal path visualization
            let pathHTML = `
                <div style="color: #888;">🎵 Audio Source</div>
                <div style="margin-left: 20px;">↓ <span style="color: #666;">0.0 dB</span></div>
            `;
            
            if (state.loudnessEnabled) {
                pathHTML += `
                    <div style="color: ${state.loudnessEnabled ? '#00d4d4' : '#666'};">🎛️ Loudness Compensation ${state.loudnessEnabled ? '(ON)' : '(OFF)'}</div>
                    <div style="margin-left: 20px;">├─ Target: ${state.targetPhon.toFixed(1)} phon</div>
                    <div style="margin-left: 20px;">├─ Reference: ${state.referencePhon.toFixed(1)} phon</div>
                    <div style="margin-left: 20px;">├─ Preamp: <span style="color: ${loudnessPreamp > 0 ? '#ffc107' : '#28a745'};">${loudnessPreamp > 0 ? '+' : ''}${loudnessPreamp.toFixed(1)} dB</span></div>
                `;
                
                if (state.easyMode) {
                    pathHTML += `
                        <div style="margin-left: 20px;">├─ Bass Enhancement: k=${state.kParameter.toFixed(1)}, δMax=${state.deltaMaxParameter} dB</div>
                        <div style="margin-left: 20px;">└─ Bass Boost: <span style="color: #ff9800;">+${bassBoost.toFixed(1)} dB @ low freq</span></div>
                    `;
                }
                
                pathHTML += `<div style="margin-left: 20px;">↓ <span style="color: ${totalLoudnessGain > 0 ? '#ffc107' : '#28a745'};">${totalLoudnessGain > 0 ? '+' : ''}${totalLoudnessGain.toFixed(1)} dB</span></div>`;
            }
            
            if (state.headphoneEqEnabled) {
                pathHTML += `
                    <div style="color: ${state.headphoneEqEnabled ? '#00d4d4' : '#666'};">🎧 Headphone EQ ${state.headphoneEqEnabled ? '(ON)' : '(OFF)'}</div>
                    <div style="margin-left: 20px;">├─ Mode: ${state.headphoneCorrectionMode || 'FIR'}</div>
                    <div style="margin-left: 20px;">└─ Gain: <span style="color: #28a745;">0.0 dB</span> (normalized)</div>
                    <div style="margin-left: 20px;">↓ <span style="color: #666;">0.0 dB</span></div>
                `;
            }
            
            pathHTML += `
                <div style="color: #888;">🎚️ Master Gain</div>
                <div style="margin-left: 20px;">↓ <span style="color: ${state.masterGain < 0 ? '#28a745' : '#dc3545'};">${state.masterGain > 0 ? '+' : ''}${state.masterGain.toFixed(1)} dB</span></div>
                <div style="color: #888;">🔊 Output</div>
                <div style="margin-left: 20px; margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                    <strong>Total Gain: <span style="color: ${(state.masterGain + totalLoudnessGain) > 0 ? '#ffc107' : '#28a745'};">${(state.masterGain + totalLoudnessGain).toFixed(1)} dB</span></strong>
                </div>
            `;
            
            signalPathEl.innerHTML = pathHTML;
        }

        // Show info dialog
        function showInfo() {
            alert('TIDAL Loudness DSP - Mobile Edition\n\n' +
                  'Core DSP features:\n' +
                  '• ISO 226:2003 loudness compensation\n' +
                  '• Enhanced bass response (ΔMax=60, k=20-24 adjustable)\n' +
                  '• AutoEQ headphone correction\n' +
                  '• Easy loudness control with bass enhancement\n' +
                  '• SPL calibration with RMS-based preamp\n\n' +
                  'Bass Enhancement: Adjust k parameter for taste\n' +
                  '• k=20: Maximum bass boost\n' +
                  '• k=23: Balanced (default)\n' +
                  '• k=24: Flatter response\n\n' +
                  'Created with Claude AI Assistant');
        }

        // Reset settings
        function resetSettings() {
            if (confirm('Reset all settings to default?')) {
                // Reset state
                state.easyMode = true;
                state.easyLoudness = 50;
                state.targetPhon = 70.0;
                state.referencePhon = 80.0;
                state.loudnessEnabled = true;
                state.headphoneEqEnabled = false;
                state.kParameter = 23; // Reset k to default
                
                // Reset UI
                document.getElementById('easyModeToggle').checked = true;
                document.getElementById('easyLoudnessSlider').value = 50;
                document.getElementById('loudnessToggle').checked = true;
                document.getElementById('headphoneEqToggle').checked = false;
                document.getElementById('targetPhonSlider').value = 70;
                document.getElementById('referencePhonSlider').value = 80;
                document.getElementById('masterGainSlider').value = -20;
                document.getElementById('masterGainValue').textContent = '-20.0 dB';
                document.getElementById('kParameterSlider').value = 23;
                document.getElementById('kParameterValue').textContent = '23.0';
                document.getElementById('deltaMaxSlider').value = 60;
                document.getElementById('deltaMaxValue').textContent = '60 dB';
                
                // Update state
                state.masterGain = -20.0;
                state.kParameter = 23;
                state.deltaMaxParameter = 60;
                
                // Update master gain
                updateMasterGain();
                
                // Clear EQ
                state.eqFilters.forEach(node => {
                    try { node.disconnect(); } catch (e) {}
                });
                state.eqFilters = [];
                if (state.eqPreampNode) {
                    try { state.eqPreampNode.disconnect(); } catch (e) {}
                    state.eqPreampNode = null;
                }
                
                document.getElementById('eqStatus').classList.add('hidden');
                document.getElementById('headphoneEqStatus').textContent = '--';
                
                // Update displays
                updateUIMode();
                updateEasyDisplay();
                updateLoudnessFromEasy();
                updateAudioGraph();
                updateTotalGain();
                
                showToast('Settings reset to default');
            }
        }

        // Update master gain
        function updateMasterGain() {
            if (state.gainNode) {
                const linearGain = Math.pow(10, state.masterGain / 20);
                state.gainNode.gain.value = linearGain;
                console.log('Master gain updated:', state.masterGain, 'dB =', linearGain);
                updateTotalGain();
            }
        }
        

        // Handle audio ended
        document.getElementById('audioElement').addEventListener('ended', () => {
            state.isPlaying = false;
            document.getElementById('playIcon').classList.remove('hidden');
            document.getElementById('pauseIcon').classList.add('hidden');
            document.getElementById('audioStatus').textContent = 'Finished';
        });

        // === CALIBRATION FUNCTIONS ===

        // Update calibration display
        function updateCalibrationDisplay() {
            const calibrationSPLEl = document.getElementById('calibrationSPLDisplay');
            const desiredSPLEl = document.getElementById('desiredSPLDisplay');
            const preampEl = document.getElementById('preampDisplay');
            
            if (calibrationSPLEl) {
                calibrationSPLEl.textContent = state.calibrationSPL.toFixed(1) + ' dB';
                // Update status color based on calibration
                if (state.isCalibrated) {
                    calibrationSPLEl.style.color = 'var(--success)';
                } else {
                    calibrationSPLEl.style.color = 'var(--warning)';
                }
            }
            
            if (desiredSPLEl) {
                desiredSPLEl.textContent = state.desiredSPL.toFixed(1) + ' dB';
            }
            
            // Show master gain instead of preamp (desktop style)
            if (preampEl) {
                preampEl.textContent = state.masterGain.toFixed(1) + ' dB';
            }
        }

        // Show calibration modal
        function showCalibrationModal() {
            document.getElementById('calibrationModal').classList.remove('hidden');
            
            // Set current values
            document.getElementById('measuredSPLInput').value = state.calibrationSPL.toFixed(1);
            document.getElementById('targetSPLInput').value = state.desiredSPL.toFixed(1);
            
            // Hide result initially
            document.getElementById('calibrationResult').style.display = 'none';
            
            // Update calculations when inputs change
            document.getElementById('measuredSPLInput').addEventListener('input', updateCalibrationResult);
            document.getElementById('targetSPLInput').addEventListener('input', updateCalibrationResult);
        }

        // Hide calibration modal
        function hideCalibrationModal() {
            document.getElementById('calibrationModal').classList.add('hidden');
            
            // Remove event listeners
            document.getElementById('measuredSPLInput').removeEventListener('input', updateCalibrationResult);
            document.getElementById('targetSPLInput').removeEventListener('input', updateCalibrationResult);
        }

        // Generate calibration tone (pink noise at 80 phon reference)
        function generateCalibrationTone() {
            if (!state.audioContext) {
                initAudioContext();
                return;
            }

            // Create pink noise buffer (simplified)
            const bufferSize = state.audioContext.sampleRate * 3; // 3 seconds
            const buffer = state.audioContext.createBuffer(1, bufferSize, state.audioContext.sampleRate);
            const channelData = buffer.getChannelData(0);
            
            // Generate pink noise (simplified 1/f approximation)
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                channelData[i] = pink * 0.1; // Normalize to reasonable level (0 dB pink noise)
                b6 = white * 0.115926;
            }

            // Create and play the calibration tone
            const source = state.audioContext.createBufferSource();
            const gainNode = state.audioContext.createGain();
            
            source.buffer = buffer;
            gainNode.gain.value = 1.0; // 0 dB pink noise for calibration reference
            
            source.connect(gainNode);
            
            // Apply current loudness filter if enabled
            let currentNode = gainNode;
            if (state.loudnessEnabled && state.loudnessConvolver) {
                currentNode.connect(state.loudnessConvolver);
                currentNode = state.loudnessConvolver;
            }
            
            currentNode.connect(state.gainNode);
            
            // Update button state
            const btn = document.getElementById('calibrationToneBtn');
            btn.textContent = '🔊 Playing...';
            btn.disabled = true;
            
            source.start();
            source.stop(state.audioContext.currentTime + 3);
            
            source.onended = () => {
                btn.textContent = '🔊 Play Calibration Tone';
                btn.disabled = false;
            };
            
            showToast('Playing calibration tone for 3 seconds');
        }

        // Update calibration result preview
        function updateCalibrationResult() {
            const measuredSPL = parseFloat(document.getElementById('measuredSPLInput').value) || 80.0;
            const targetSPL = parseFloat(document.getElementById('targetSPLInput').value) || 70.0;
            
            // Calculate system offset: measured - expected
            const systemOffset = measuredSPL - 80.0; // Expected 80 dB at 80 phon reference
            
            // Calculate master gain using current easy mode settings
            const currentTargetPhon = easyToPhon(state.easyLoudness);
            const masterGain = currentTargetPhon - measuredSPL + systemOffset;
            
            // Update display
            document.getElementById('systemOffsetDisplay').textContent = systemOffset.toFixed(1) + ' dB';
            document.getElementById('autoPreampDisplay').textContent = masterGain.toFixed(1) + ' dB';
            
            // Show result
            document.getElementById('calibrationResult').style.display = 'block';
        }

        // Apply calibration settings
        function applyCalibration() {
            const measuredSPL = parseFloat(document.getElementById('measuredSPLInput').value) || 80.0;
            const targetSPL = parseFloat(document.getElementById('targetSPLInput').value) || 70.0;
            
            // Update state
            state.calibrationSPL = measuredSPL;
            state.desiredSPL = targetSPL;
            state.systemOffset = measuredSPL - 80.0;
            state.isCalibrated = true;
            
            // Update UI
            updateCalibrationDisplay();
            updateLoudnessFromEasy(); // Recalculate preamp
            
            hideCalibrationModal();
            showToast('Calibration applied successfully', 'success');
            
            console.log('Calibration updated:', {
                calibrationSPL: state.calibrationSPL,
                desiredSPL: state.desiredSPL,
                systemOffset: state.systemOffset,
                calculatedPreamp: calculateSPLPreamp(state.targetPhon)
            });
        }

        // Reset calibration to defaults
        function resetCalibration() {
            state.calibrationSPL = 80.0;
            state.desiredSPL = 70.0;
            state.systemOffset = 0.0;
            state.isCalibrated = false;
            
            updateCalibrationDisplay();
            updateLoudnessFromEasy();
            
            showToast('Calibration reset to defaults', 'warning');
        }

        // =====================================================
        // TIDAL Integration
        // =====================================================
        
        // TIDAL state
        const tidalState = {
            clientId: localStorage.getItem('tidalClientId') || 'zU4XHVVkc2tDPo4t', // Default Android Auto client ID
            token: localStorage.getItem('tidalToken') || '',
            countryCode: localStorage.getItem('tidalCountryCode') || 'US',
            currentTrackId: null,
            currentTrack: null,
            playlist: JSON.parse(localStorage.getItem('tidalPlaylist') || '[]'),
            playlistIndex: -1,
            searchResults: []
        };

        // TIDAL API configuration is already defined above

        // Initialize TIDAL settings from localStorage
        function initTIDAL() {
            // No need to update settings UI since we use OAuth now
            // Just update playlist UI
            updatePlaylistUI();
        }

        // Show/hide TIDAL settings modal
        function showTidalSettings() {
            document.getElementById('tidalSettingsModal').classList.remove('hidden');
        }

        function hideTidalSettings() {
            document.getElementById('tidalSettingsModal').classList.add('hidden');
        }

        // Save TIDAL settings
        function saveTidalSettings() {
            tidalState.clientId = document.getElementById('clientIdInput').value.trim();
            tidalState.token = document.getElementById('tidalTokenInput').value.trim();
            tidalState.countryCode = document.getElementById('countryCodeInput').value.trim();
            
            localStorage.setItem('tidalClientId', tidalState.clientId);
            localStorage.setItem('tidalToken', tidalState.token);
            localStorage.setItem('tidalCountryCode', tidalState.countryCode);
            
            hideTidalSettings();
            showToast('TIDAL settings saved', 'success');
        }

        // Clear TIDAL settings
        function clearTidalSettings() {
            document.getElementById('clientIdInput').value = '';
            document.getElementById('tidalTokenInput').value = '';
            document.getElementById('countryCodeInput').value = 'US';
            
            tidalState.clientId = '';
            tidalState.token = '';
            tidalState.countryCode = 'US';
            
            localStorage.removeItem('tidalClientId');
            localStorage.removeItem('tidalToken');
            localStorage.setItem('tidalCountryCode', 'US');
            
            showToast('TIDAL settings cleared', 'warning');
        }

        // Tab switching
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Add active class to selected button
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
        }

        // TIDAL API helper
        async function tidalAPIRequest(endpoint, params = {}) {
            if (!tidalState.token) {
                throw new Error('TIDAL access token not configured. Please add your token in settings.');
            }

            const url = new URL(`${TIDAL_API_URL}${endpoint}`);
            
            // Add default countryCode if not provided in params
            if (!params.countryCode) {
                params.countryCode = tidalState.countryCode || 'US';
            }
            
            Object.keys(params).forEach(key => {
                url.searchParams.append(key, params[key]);
            });

            console.log('API Request URL:', url.toString());
            console.log('API Headers:', {
                'Authorization': `Bearer ${tidalState.token.substring(0, 10)}...`,
                'X-Tidal-Token': tidalState.clientId
            });

            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${tidalState.token}`,
                    'X-Tidal-Token': tidalState.clientId
                }
            });

            if (!response.ok) {
                const error = await response.text();
                console.error('API Error Response:', error);
                throw new Error(`TIDAL API error: ${response.status} - ${error}`);
            }

            return response.json();
        }

        // Search functionality
        async function searchTidal() {
            const query = document.getElementById('tidalSearchInput').value.trim();
            if (!query) return;

            console.log('Searching for:', query);
            console.log('Using token:', tidalState.token ? 'Yes' : 'No');
            console.log('Using client ID:', tidalState.clientId);

            try {
                const results = document.getElementById('searchResults');
                results.innerHTML = '<div class="loading">Searching...</div>';

                const data = await tidalAPIRequest('/search/tracks', {
                    query: query,
                    limit: 20,
                    offset: 0,
                    countryCode: tidalState.countryCode || 'US'
                });

                console.log('Search response:', data);
                tidalState.searchResults = data.items || [];
                displaySearchResults();

            } catch (error) {
                console.error('Search error:', error);
                document.getElementById('searchResults').innerHTML = 
                    `<div class="error">Search failed: ${error.message}</div>`;
                showToast('Search failed: ' + error.message, 'error');
            }
        }

        // Display search results
        function displaySearchResults() {
            const container = document.getElementById('searchResults');
            
            if (!tidalState.searchResults.length) {
                container.innerHTML = '<div class="no-results">No results found</div>';
                return;
            }

            container.innerHTML = tidalState.searchResults.map((track, index) => `
                <div class="search-result" onclick="playTrack(${index})">
                    <div class="track-info">
                        <div class="track-title">${track.title}</div>
                        <div class="track-subtitle">${track.album ? track.album.title + ' - ' : ''}${track.artist.name}</div>
                    </div>
                    <button class="action-button" onclick="event.stopPropagation(); addToPlaylist(${index})" title="Add to playlist">
                        ➕
                    </button>
                </div>
            `).join('');
        }

        // Play track from search results
        async function playTrack(index) {
            const track = tidalState.searchResults[index];
            if (!track) return;

            try {
                // Get stream URL
                const streamData = await tidalAPIRequest(`/tracks/${track.id}/playbackinfopostpaywall`, {
                    playbackmode: 'STREAM',
                    assetpresentation: 'FULL',
                    audioquality: 'HIGH'
                });

                // Decode manifest if it's base64 encoded
                let streamUrl = streamData.manifest;
                if (streamData.manifestMimeType && streamData.manifest) {
                    try {
                        // Check if manifest is base64 encoded
                        let decodedManifest = streamData.manifest;
                        try {
                            // Try to decode base64
                            decodedManifest = atob(streamData.manifest);
                        } catch (e) {
                            // Not base64 encoded, use as is
                            decodedManifest = streamData.manifest;
                        }
                        
                        // Check if manifest is XML (DASH MPD)
                        if (streamData.manifestMimeType.includes('dash+xml') || decodedManifest.startsWith('<?xml')) {
                            // For DASH manifests, we can't use them directly
                            // Use the direct URL if available
                            console.log('DASH manifest detected, looking for direct URL');
                            if (streamData.urls && streamData.urls[0]) {
                                streamUrl = streamData.urls[0];
                            } else {
                                throw new Error('DASH manifest without direct URL');
                            }
                        } else {
                            // Try to parse as JSON
                            const manifest = JSON.parse(decodedManifest);
                            if (manifest.urls && manifest.urls.length > 0) {
                                streamUrl = manifest.urls[0];
                            }
                        }
                    } catch (e) {
                        console.error('Failed to decode manifest:', e);
                        // Use fallback URL if available
                        if (streamData.urls && streamData.urls[0]) {
                            streamUrl = streamData.urls[0];
                        } else {
                            throw new Error('No playable URL found');
                        }
                    }
                }
                
                // Update current track
                tidalState.currentTrack = track;
                tidalState.currentTrackId = track.id;

                // Load and play
                await loadAudioFromURL(streamUrl);
                playAudio();

                // Update mini player
                updateMiniPlayer();

            } catch (error) {
                console.error('Playback error:', error);
                showToast('Failed to play track: ' + error.message, 'error');
            }
        }

        // Add track to playlist
        function addToPlaylist(index) {
            const track = tidalState.searchResults[index];
            if (!track) return;

            // Check if already in playlist
            if (tidalState.playlist.some(t => t.id === track.id)) {
                showToast('Track already in playlist', 'warning');
                return;
            }

            tidalState.playlist.push(track);
            localStorage.setItem('tidalPlaylist', JSON.stringify(tidalState.playlist));
            
            updatePlaylistUI();
            showToast('Added to playlist', 'success');
        }

        // Update playlist UI
        function updatePlaylistUI() {
            const container = document.getElementById('playlistContainer');
            
            if (!tidalState.playlist.length) {
                container.innerHTML = '<div class="empty-playlist">Playlist is empty</div>';
                return;
            }

            container.innerHTML = tidalState.playlist.map((track, index) => `
                <div class="search-result ${index === tidalState.playlistIndex ? 'playing' : ''}" onclick="playFromPlaylist(${index})">
                    <div class="track-info">
                        <div class="track-title">${track.title}</div>
                        <div class="track-subtitle">${track.album ? track.album.title + ' - ' : ''}${track.artist.name}</div>
                    </div>
                    <button class="action-button" onclick="event.stopPropagation(); removeFromPlaylist(${index})" title="Remove">
                        ❌
                    </button>
                </div>
            `).join('');
        }

        // Play from playlist
        async function playFromPlaylist(index) {
            if (index < 0 || index >= tidalState.playlist.length) return;

            tidalState.playlistIndex = index;
            const track = tidalState.playlist[index];

            try {
                // Get stream URL
                const streamData = await tidalAPIRequest(`/tracks/${track.id}/playbackinfopostpaywall`, {
                    playbackmode: 'STREAM',
                    assetpresentation: 'FULL',
                    audioquality: 'HIGH'
                });

                // Decode manifest if it's base64 encoded
                let streamUrl = streamData.manifest;
                if (streamData.manifestMimeType && streamData.manifest) {
                    try {
                        // Check if manifest is XML (DASH MPD)
                        if (streamData.manifestMimeType.includes('dash+xml') || streamData.manifest.startsWith('<?xml')) {
                            // For DASH manifests, we need to parse the MPD
                            // For now, skip DASH and use fallback URL
                            console.log('DASH manifest detected, using fallback');
                            streamUrl = streamData.urls && streamData.urls[0] ? streamData.urls[0] : streamData.manifest;
                        } else {
                            // Try to decode as base64 JSON
                            const manifestJson = atob(streamData.manifest);
                            const manifest = JSON.parse(manifestJson);
                            if (manifest.urls && manifest.urls.length > 0) {
                                streamUrl = manifest.urls[0];
                            }
                        }
                    } catch (e) {
                        console.error('Failed to decode manifest:', e);
                        // Use fallback URL if available
                        if (streamData.urls && streamData.urls[0]) {
                            streamUrl = streamData.urls[0];
                        }
                    }
                }
                
                // Update current track
                tidalState.currentTrack = track;
                tidalState.currentTrackId = track.id;

                // Load and play
                await loadAudioFromURL(streamUrl);
                playAudio();

                // Update UI
                updateMiniPlayer();
                updatePlaylistUI();

            } catch (error) {
                console.error('Playback error:', error);
                showToast('Failed to play track: ' + error.message, 'error');
            }
        }

        // Remove from playlist
        function removeFromPlaylist(index) {
            tidalState.playlist.splice(index, 1);
            localStorage.setItem('tidalPlaylist', JSON.stringify(tidalState.playlist));
            
            // Adjust playlist index if needed
            if (tidalState.playlistIndex >= index) {
                tidalState.playlistIndex--;
            }
            
            updatePlaylistUI();
            showToast('Removed from playlist', 'success');
        }

        // Clear playlist
        function clearPlaylist() {
            if (confirm('Clear entire playlist?')) {
                tidalState.playlist = [];
                tidalState.playlistIndex = -1;
                localStorage.setItem('tidalPlaylist', JSON.stringify(tidalState.playlist));
                updatePlaylistUI();
                showToast('Playlist cleared', 'success');
            }
        }

        // Update mini player
        function updateMiniPlayer() {
            const miniPlayer = document.getElementById('miniPlayer');
            
            if (tidalState.currentTrack) {
                document.getElementById('miniPlayerTitle').textContent = tidalState.currentTrack.title;
                const albumInfo = tidalState.currentTrack.album ? tidalState.currentTrack.album.title + ' - ' : '';
                document.getElementById('miniPlayerArtist').textContent = albumInfo + tidalState.currentTrack.artist.name;
                
                // Show mini player
                miniPlayer.classList.add('active');
                
                // Update full player info
                updateFullPlayer();
                
                // Update play/pause UI
                updatePlayPauseUI();
            } else {
                document.getElementById('miniPlayerTitle').textContent = 'No track selected';
                document.getElementById('miniPlayerArtist').textContent = '';
            }
        }

        // Update full player
        function updateFullPlayer() {
            if (tidalState.currentTrack) {
                document.getElementById('fullPlayerTitle').textContent = tidalState.currentTrack.title;
                const albumInfo = tidalState.currentTrack.album ? tidalState.currentTrack.album.title + ' - ' : '';
                document.getElementById('fullPlayerArtist').textContent = albumInfo + tidalState.currentTrack.artist.name;
                
                // Update album art if available
                if (tidalState.currentTrack.album && tidalState.currentTrack.album.cover) {
                    const coverUrl = `https://resources.tidal.com/images/${tidalState.currentTrack.album.cover.replace(/-/g, '/')}/640x640.jpg`;
                    document.getElementById('miniPlayerArt').src = coverUrl;
                    document.getElementById('fullPlayerArt').src = coverUrl;
                }
            }
        }

        // Expand player to full screen
        function expandPlayer() {
            const fullPlayer = document.getElementById('fullPlayer');
            const miniPlayer = document.getElementById('miniPlayer');
            
            fullPlayer.classList.add('active');
            miniPlayer.classList.add('hidden');
            
            // Initialize full player loudness slider
            const fullPlayerSlider = document.getElementById('fullPlayerLoudnessSlider');
            if (fullPlayerSlider) {
                fullPlayerSlider.value = state.easyLoudness;
                updateFullPlayerLoudnessDisplay();
            }
            
            // Start progress updates
            startProgressUpdates();
        }

        // Collapse player to mini
        function collapsePlayer() {
            const fullPlayer = document.getElementById('fullPlayer');
            const miniPlayer = document.getElementById('miniPlayer');
            
            fullPlayer.classList.remove('active');
            miniPlayer.classList.remove('hidden');
            
            // Stop progress updates
            stopProgressUpdates();
        }

        // Progress bar updates
        let progressInterval = null;

        function startProgressUpdates() {
            if (progressInterval) return;
            
            progressInterval = setInterval(() => {
                if (state.audioElement && !state.audioElement.paused) {
                    const currentTime = state.audioElement.currentTime;
                    const duration = state.audioElement.duration;
                    
                    if (!isNaN(duration)) {
                        const progress = (currentTime / duration) * 100;
                        document.getElementById('progressBar').value = progress;
                        document.getElementById('currentTime').textContent = formatTime(currentTime);
                        document.getElementById('duration').textContent = formatTime(duration);
                    }
                }
            }, 100);

            // Add progress bar interaction
            const progressBar = document.getElementById('progressBar');
            progressBar.addEventListener('input', handleProgressChange);
        }

        function stopProgressUpdates() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }

        function handleProgressChange(e) {
            if (state.audioElement && !isNaN(state.audioElement.duration)) {
                const progress = e.target.value;
                const time = (progress / 100) * state.audioElement.duration;
                state.audioElement.currentTime = time;
            }
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Shuffle and repeat states
        let shuffleEnabled = false;
        let repeatMode = 'off'; // 'off', 'all', 'one'

        function toggleShuffle() {
            shuffleEnabled = !shuffleEnabled;
            const shuffleIcon = document.getElementById('shuffleIcon');
            if (shuffleEnabled) {
                shuffleIcon.parentElement.classList.add('active');
            } else {
                shuffleIcon.parentElement.classList.remove('active');
            }
        }

        function toggleRepeat() {
            const modes = ['off', 'all', 'one'];
            const currentIndex = modes.indexOf(repeatMode);
            repeatMode = modes[(currentIndex + 1) % modes.length];
            
            const repeatIcon = document.getElementById('repeatIcon');
            const button = repeatIcon.parentElement;
            
            if (repeatMode === 'off') {
                button.classList.remove('active');
                repeatIcon.innerHTML = '<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>';
            } else if (repeatMode === 'all') {
                button.classList.add('active');
                repeatIcon.innerHTML = '<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>';
            } else if (repeatMode === 'one') {
                button.classList.add('active');
                repeatIcon.innerHTML = '<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v4H13z"/>';
            }
        }

        // Playback controls
        function togglePlayPause() {
            if (state.isPlaying) {
                pauseAudio();
            } else {
                playAudio();
            }
            updateMiniPlayer();
        }

        function previousTrack() {
            if (tidalState.playlistIndex > 0) {
                playFromPlaylist(tidalState.playlistIndex - 1);
            }
        }

        function nextTrack() {
            if (state.shuffleEnabled && tidalState.playlist.length > 1) {
                // Shuffle mode - play random track
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * tidalState.playlist.length);
                } while (newIndex === tidalState.playlistIndex);
                playFromPlaylist(newIndex);
            } else if (tidalState.playlistIndex < tidalState.playlist.length - 1) {
                // Normal mode - play next track
                playFromPlaylist(tidalState.playlistIndex + 1);
            } else if (state.repeatMode === 'all' && tidalState.playlist.length > 0) {
                // At end of playlist with repeat all - go to beginning
                playFromPlaylist(0);
            }
        }

        // Keep track of current blob URL to clean up
        let currentBlobUrl = null;

        // Load audio from URL
        async function loadAudioFromURL(url) {
            try {
                if (!state.audioContext) {
                    await initAudioContext();
                }

                // Stop current playback
                if (state.audioElement) {
                    state.audioElement.pause();
                    state.audioElement.currentTime = 0;
                    // Remove src to fully reset the element
                    state.audioElement.src = '';
                    state.audioElement.load();
                }
                
                // Disconnect source node if it exists
                if (state.sourceNode) {
                    try {
                        state.sourceNode.disconnect();
                    } catch (e) {
                        // Ignore error if already disconnected
                    }
                    state.sourceNode = null;
                }

                // Clean up previous blob URL
                if (currentBlobUrl) {
                    URL.revokeObjectURL(currentBlobUrl);
                    currentBlobUrl = null;
                }

                // Always create a new audio element for each track to avoid reuse issues
                let oldAudio = document.getElementById('audioElement');
                if (oldAudio) {
                    oldAudio.remove();
                }
                
                let audio = document.createElement('audio');
                audio.id = 'audioElement';
                audio.crossOrigin = 'anonymous';
                document.body.appendChild(audio);

                // For TIDAL URLs, fetch as blob to bypass CORS
                if (url.includes('tidal.com')) {
                    try {
                        console.log('Fetching TIDAL stream as blob...');
                        const response = await fetch(url);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const blob = await response.blob();
                        currentBlobUrl = URL.createObjectURL(blob);
                        audio.src = currentBlobUrl;
                    } catch (fetchError) {
                        console.error('Blob fetch failed, trying direct URL:', fetchError);
                        // Fallback to direct URL (might work in Electron with --disable-web-security)
                        audio.src = url;
                    }
                } else {
                    // Local files or other URLs
                    audio.src = url;
                }

                // Create media element source - always create new since we have a new audio element
                try {
                    state.sourceNode = state.audioContext.createMediaElementSource(audio);
                } catch (e) {
                    console.error('Failed to create media element source:', e);
                    throw e;
                }
                state.audioElement = audio;

                // Add event listener for when track ends
                audio.addEventListener('ended', () => {
                    console.log('Track ended, playing next');
                    if (state.repeatMode === 'one') {
                        // Repeat current track
                        audio.currentTime = 0;
                        audio.play();
                    } else {
                        // Play next track
                        nextTrack();
                    }
                });

                // Add event listener for time updates
                audio.addEventListener('timeupdate', updateProgressBar);

                // Connect to audio graph
                updateAudioGraph();

                state.audioLoaded = true;
                showToast('Track loaded', 'success');

            } catch (error) {
                console.error('Error loading audio:', error);
                showToast('Failed to load audio: ' + error.message, 'error');
            }
        }

        // Clean up blob URLs on page unload
        window.addEventListener('beforeunload', () => {
            if (currentBlobUrl) {
                URL.revokeObjectURL(currentBlobUrl);
            }
        });

        // Modified play/pause functions for streaming
        function playAudio() {
            if (state.audioElement && state.audioLoaded) {
                state.audioElement.play();
                state.isPlaying = true;
                updatePlayPauseUI();
            }
        }

        function pauseAudio() {
            if (state.audioElement) {
                state.audioElement.pause();
                state.isPlaying = false;
                updatePlayPauseUI();
            }
        }

        // Update progress bar
        function updateProgressBar() {
            if (!state.audioElement) return;
            
            const progress = document.querySelector('.progress');
            const currentTimeSpan = document.querySelector('.current-time');
            const durationSpan = document.querySelector('.duration');
            
            if (progress) {
                const percentage = (state.audioElement.currentTime / state.audioElement.duration) * 100;
                progress.style.width = percentage + '%';
            }
            
            if (currentTimeSpan) {
                currentTimeSpan.textContent = formatTime(state.audioElement.currentTime);
            }
            
            if (durationSpan && !isNaN(state.audioElement.duration)) {
                durationSpan.textContent = formatTime(state.audioElement.duration);
            }
        }
        
        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        // Update play/pause UI
        function updatePlayPauseUI() {
            // Update mini player icon
            const miniPlayIcon = document.getElementById('miniPlayIcon');
            const miniPauseIcon = document.getElementById('miniPauseIcon');
            
            if (miniPlayIcon && miniPauseIcon) {
                if (state.isPlaying) {
                    miniPlayIcon.style.display = 'none';
                    miniPauseIcon.style.display = 'block';
                } else {
                    miniPlayIcon.style.display = 'block';
                    miniPauseIcon.style.display = 'none';
                }
            }
            
            // Update full player icon
            const fullPlayIcon = document.getElementById('fullPlayIcon');
            const fullPauseIcon = document.getElementById('fullPauseIcon');
            
            if (fullPlayIcon && fullPauseIcon) {
                if (state.isPlaying) {
                    fullPlayIcon.style.display = 'none';
                    fullPauseIcon.style.display = 'block';
                } else {
                    fullPlayIcon.style.display = 'block';
                    fullPauseIcon.style.display = 'none';
                }
            }
            
            // Update main player icon
            const playIcon = document.getElementById('playIcon');
            const pauseIcon = document.getElementById('pauseIcon');
            
            if (playIcon && pauseIcon) {
                if (state.isPlaying) {
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                } else {
                    playIcon.classList.remove('hidden');
                    pauseIcon.classList.add('hidden');
                }
            }
        }

        // Initialize app after authentication check
        function initializeApp() {
            initTIDAL();
            
            // Set initial tab
            switchTab('search');
            
            // Add search on Enter key
            document.getElementById('tidalSearchInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchTidal();
                }
            });
            
            // Add audio event listeners
            const audio = document.getElementById('audioElement');
            if (audio) {
                // Track ended
                audio.addEventListener('ended', () => {
                    handleTrackEnded();
                });
                
                // Update progress
                audio.addEventListener('timeupdate', () => {
                    updateProgress();
                });
                
                // Track loaded
                audio.addEventListener('loadedmetadata', () => {
                    updateDuration();
                });
                
                // Play/pause events
                audio.addEventListener('play', () => {
                    state.isPlaying = true;
                    updatePlayPauseUI();
                });
                
                audio.addEventListener('pause', () => {
                    state.isPlaying = false;
                    updatePlayPauseUI();
                });
            }
            
            // Progress bar interaction
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.addEventListener('input', (e) => {
                    seekToPosition(e.target.value);
                });
            }
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Don't handle if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        togglePlayPause();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        if (state.audioElement) {
                            state.audioElement.currentTime = Math.min(
                                state.audioElement.currentTime + 5,
                                state.audioElement.duration || 0
                            );
                        }
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        if (state.audioElement) {
                            state.audioElement.currentTime = Math.max(
                                state.audioElement.currentTime - 5,
                                0
                            );
                        }
                        break;
                    case 'KeyN':
                        e.preventDefault();
                        nextTrack();
                        break;
                    case 'KeyP':
                        e.preventDefault();
                        previousTrack();
                        break;
                    case 'KeyR':
                        e.preventDefault();
                        toggleRepeat();
                        break;
                    case 'KeyS':
                        e.preventDefault();
                        toggleShuffle();
                        break;
                }
            });
        }

        // === PLAYBACK CONTROL FUNCTIONS ===
        
        // Handle track ended
        function handleTrackEnded() {
            if (state.repeatMode === 'one') {
                // Repeat current track
                state.audioElement.currentTime = 0;
                state.audioElement.play();
            } else if (tidalState.playlistIndex < tidalState.playlist.length - 1) {
                // Play next track
                nextTrack();
            } else if (state.repeatMode === 'all' && tidalState.playlist.length > 0) {
                // Repeat playlist from beginning
                playFromPlaylist(0);
            } else {
                // Stop playback
                state.isPlaying = false;
                updatePlayPauseUI();
            }
        }
        
        // Update progress bar and time
        function updateProgress() {
            if (!state.audioElement) return;
            
            const current = state.audioElement.currentTime;
            const duration = state.audioElement.duration;
            
            if (!isNaN(duration) && duration > 0) {
                const percentage = (current / duration) * 100;
                
                // Update full player progress bar
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.value = percentage;
                }
                
                // Update mini player progress bar
                const miniProgressFill = document.getElementById('miniPlayerProgressFill');
                if (miniProgressFill) {
                    miniProgressFill.style.width = percentage + '%';
                }
                
                // Update time displays
                const currentTimeEl = document.getElementById('currentTime');
                const durationEl = document.getElementById('duration');
                
                if (currentTimeEl) {
                    currentTimeEl.textContent = formatTime(current);
                }
                
                if (durationEl) {
                    durationEl.textContent = formatTime(duration);
                }
            }
        }
        
        // Update duration display
        function updateDuration() {
            if (!state.audioElement) return;
            
            const duration = state.audioElement.duration;
            const durationEl = document.getElementById('duration');
            
            if (durationEl && !isNaN(duration)) {
                durationEl.textContent = formatTime(duration);
            }
        }
        
        // Seek to position
        function seekToPosition(percentage) {
            if (!state.audioElement || !state.audioElement.duration) return;
            
            const time = (percentage / 100) * state.audioElement.duration;
            state.audioElement.currentTime = time;
        }
        
        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Toggle shuffle
        function toggleShuffle() {
            state.shuffleEnabled = !state.shuffleEnabled;
            
            const shuffleIcon = document.getElementById('shuffleIcon');
            if (shuffleIcon) {
                shuffleIcon.parentElement.classList.toggle('active', state.shuffleEnabled);
            }
            
            showToast(`Shuffle ${state.shuffleEnabled ? 'on' : 'off'}`);
        }
        
        // Toggle repeat
        function toggleRepeat() {
            const modes = ['off', 'all', 'one'];
            const currentIndex = modes.indexOf(state.repeatMode);
            state.repeatMode = modes[(currentIndex + 1) % modes.length];
            
            const repeatIcon = document.getElementById('repeatIcon');
            if (repeatIcon && repeatIcon.parentElement) {
                const button = repeatIcon.parentElement;
                button.classList.toggle('active', state.repeatMode !== 'off');
                
                // Update icon based on mode
                if (state.repeatMode === 'one') {
                    repeatIcon.innerHTML = '<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zM12 10v8l-1-1v-6h-1v6l-1 1v-8h3z"/>';
                } else {
                    repeatIcon.innerHTML = '<path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>';
                }
            }
            
            let message = 'Repeat off';
            if (state.repeatMode === 'all') message = 'Repeat all';
            if (state.repeatMode === 'one') message = 'Repeat one';
            
            showToast(message);
        }
        
        // Previous track
        function previousTrack() {
            if (state.audioElement && state.audioElement.currentTime > 3) {
                // If more than 3 seconds played, restart current track
                state.audioElement.currentTime = 0;
            } else if (tidalState.playlistIndex > 0) {
                // Otherwise go to previous track
                playFromPlaylist(tidalState.playlistIndex - 1);
            }
        }
        
        // Add volume control
        function setVolume(value) {
            if (state.gainNode) {
                // Convert 0-100 to 0-1 range
                const volume = value / 100;
                // Apply logarithmic scale for better perception
                const logVolume = Math.pow(volume, 2);
                state.gainNode.gain.value = logVolume * Math.pow(10, state.masterGain / 20);
            }
        }
        
        // Update mini player display
        function updateMiniPlayerDisplay() {
            const phon = easyToPhon(state.easyLoudness);
            const spl = phonToSPL(phon);
            
            // Calculate total gain for headroom
            const loudnessPreamp = state.loudnessEnabled ? calculateSPLPreamp(state.targetPhon) : 0;
            const bassBoost = state.loudnessEnabled && state.easyMode ? 
                (state.deltaMaxParameter * Math.exp(-(state.targetPhon - 40) / state.kParameter)) : 0;
            const totalLoudnessGain = loudnessPreamp + (bassBoost > 1 ? Math.log10(bassBoost) * 20 : 0);
            const totalGain = state.masterGain + totalLoudnessGain;
            const headroom = -totalGain;
            
            // Update displays
            const phonEl = document.getElementById('miniPlayerPhon');
            const splEl = document.getElementById('miniPlayerSPL');
            const headroomEl = document.getElementById('miniPlayerHeadroom');
            
            if (phonEl) {
                phonEl.textContent = phon.toFixed(0) + ' phon';
            }
            
            if (splEl) {
                splEl.textContent = spl.toFixed(0) + ' dB';
            }
            
            if (headroomEl) {
                headroomEl.textContent = (headroom > 0 ? '-' : '+') + Math.abs(headroom).toFixed(1) + ' dB';
                // Color based on headroom
                if (headroom < 3) {
                    headroomEl.style.color = 'var(--danger)';
                } else if (headroom < 6) {
                    headroomEl.style.color = 'var(--warning)';
                } else {
                    headroomEl.style.color = 'var(--success)';
                }
            }
        }
        
        // Seek from mini player progress bar
        function seekFromMiniPlayer(event) {
            if (!state.audioElement || !state.audioElement.duration) return;
            
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const percentage = (x / rect.width) * 100;
            const time = (percentage / 100) * state.audioElement.duration;
            
            state.audioElement.currentTime = time;
        }
        
        // Show toast notification
        function showToast(message, type = 'info') {
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            
            // Add to document
            document.body.appendChild(toast);
            
            // Show toast
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
    </script>
</body>
</html>