<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Music Player</title>
    <!-- Music Metadata Browser for ID3 tags and album art -->
    <script type="module">
        import * as musicMetadata from 'https://cdn.jsdelivr.net/npm/music-metadata-browser@2/dist/music-metadata-browser.min.js';
        window.parseAudioMetadata = musicMetadata.parseBlob;
    </script>
    <style>
        :root {
            --bg-primary: #000000;
            --bg-secondary: #121212;
            --bg-tertiary: #181818;
            --bg-elevated: #282828;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --text-dim: #717171;
            --accent: #34c759;
            --accent-hover: #30d158;
            --danger: #ff4444;
            --border: rgba(255, 255, 255, 0.1);
            --player-height: 90px;
            --sidebar-width: 360px;
            --header-height: 60px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Container Layout */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            height: var(--header-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 24px;
            position: relative;
            z-index: 10;
        }

        .header-title {
            flex: 1;
            font-size: 24px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .icon-button {
            width: 40px;
            height: 40px;
            border: none;
            background: none;
            color: var(--text-secondary);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 20px;
        }

        .icon-button:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .icon-button.active {
            color: var(--accent);
            background: rgba(255, 0, 0, 0.1);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Now Playing - Main Content */
        .now-playing-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            background: radial-gradient(ellipse at center top, var(--bg-tertiary) 0%, var(--bg-primary) 50%);
        }

        .album-art-large {
            width: min(480px, 70vw);
            height: min(480px, 70vw);
            background: var(--bg-elevated);
            border-radius: 8px;
            margin-bottom: 48px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 120px;
            color: var(--text-dim);
            overflow: hidden;
            position: relative;
        }

        .album-art-large img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .track-info-large {
            text-align: center;
            max-width: 600px;
        }

        .track-title-large {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .track-artist-large {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .add-files-link {
            color: var(--accent);
            text-decoration: none;
            transition: opacity 0.2s;
        }
        
        .add-files-link:hover {
            opacity: 0.8;
        }

        /* Playlist Sidebar */
        .playlist-sidebar {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s;
        }

        .playlist-header {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .playlist-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .playlist-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .add-button {
            color: var(--accent) !important;
        }
        
        .add-button:hover {
            background: rgba(52, 199, 89, 0.1) !important;
        }

        .playlist-items {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            list-style: none;
        }

        .playlist-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 2px;
            gap: 12px;
        }

        .playlist-item:hover {
            background: var(--bg-tertiary);
        }

        .playlist-item.active {
            background: var(--bg-elevated);
        }

        .playlist-item-index {
            width: 24px;
            color: var(--text-dim);
            font-size: 14px;
            text-align: center;
        }

        .playlist-item.active .playlist-item-index {
            color: var(--accent);
            font-weight: 600;
        }

        .playlist-item-thumb {
            width: 40px;
            height: 40px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: var(--text-dim);
            overflow: hidden;
        }

        .playlist-item-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .playlist-item-info {
            flex: 1;
            min-width: 0;
        }

        .playlist-item-title {
            font-size: 14px;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playlist-item-duration {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Player Bar */
        .player-bar {
            height: var(--player-height);
            background: var(--bg-elevated);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            position: relative;
            z-index: 20;
        }

        /* Player sections */
        .player-left {
            flex: 0 0 300px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .player-album-art {
            width: 56px;
            height: 56px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: var(--text-dim);
            overflow: hidden;
        }

        .player-album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .player-track-details {
            flex: 1;
            min-width: 0;
        }

        .player-track-title {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .player-track-artist {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-center {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            max-width: 600px;
            margin: 0 auto;
        }

        .playback-buttons {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .playback-button {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .playback-button:hover {
            transform: scale(1.1);
        }

        .playback-button.primary {
            width: 40px;
            height: 40px;
            background: var(--text-primary);
            color: var(--bg-primary);
        }

        .playback-button.primary:hover {
            transform: scale(1.05);
        }

        .progress-bar {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .time-display {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 40px;
        }

        .progress-slider {
            flex: 1;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .progress-fill {
            height: 100%;
            background: var(--text-primary);
            border-radius: 2px;
            position: relative;
            width: 0%;
            transition: width 0.1s;
        }

        .progress-slider:hover .progress-fill {
            background: var(--accent);
        }

        .player-right {
            flex: 0 0 400px; /* Fixed width */
            display: flex;
            align-items: center;
            gap: 16px;
            justify-content: flex-end;
        }

        /* Smart controls in player bar */
        .smart-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            margin-right: 16px;
            border: 1px solid var(--accent);
            border-radius: 24px;
            background: rgba(52, 199, 89, 0.05);
            min-width: 180px;
        }

        .smart-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .smart-indicator.active {
            display: flex;
            color: #34c759;
        }

        .env-monitor {
            display: none;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--text-dim);
        }

        .env-monitor.active {
            display: flex;
            color: var(--text-secondary);
        }
        
        /* Compact toggle for playbar */
        .smart-controls .toggle-switch {
            width: 36px;
            height: 20px;
        }
        
        .smart-controls .toggle-slider:before {
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
        }
        
        .smart-controls input:checked + .toggle-slider:before {
            transform: translateX(16px);
        }
        
        .smart-control-label {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
            min-width: 120px; /* Fixed width to prevent shifting */
        }
        
        .smart-status-info {
            font-size: 10px;
            color: var(--text-dim);
            line-height: 1.3;
            opacity: 0;
            transition: opacity 0.3s;
            height: 36px; /* Fixed height to prevent layout shift */
            overflow: hidden;
        }
        
        .smart-status-info.active {
            opacity: 1;
        }
        
        .smart-status-line {
            white-space: nowrap;
        }

        /* Volume control */
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-slider {
            width: 100px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-slider.smart-mode {
            background: var(--accent);
        }

        .volume-slider.smart-mode::-webkit-slider-thumb {
            background: #ffffff;
            box-shadow: 0 0 0 2px var(--accent);
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 400px;
            background: var(--bg-secondary);
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
            transform: translateX(100%);
            transition: transform 0.3s;
            z-index: 100;
            overflow-y: auto;
        }

        .settings-panel.open {
            transform: translateX(0);
        }

        .settings-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .settings-title {
            font-size: 20px;
            font-weight: 600;
        }

        .settings-content {
            padding: 20px;
        }

        .settings-section {
            margin-bottom: 30px;
            padding-bottom: 30px;
            border-bottom: 1px solid var(--border);
        }

        .settings-section:last-child {
            border-bottom: none;
        }

        .settings-section h3 {
            font-size: 16px;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        /* Form controls */
        .toggle-switch {
            position: relative;
            width: 48px;
            height: 26px;
            margin-bottom: 5px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: .3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #34c759; /* iOS green */
        }

        input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .range-control {
            margin-bottom: 20px;
        }

        .range-control label {
            display: block;
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .range-with-value {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .range-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            outline: none;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }

        .range-slider::-webkit-slider-thumb:hover {
            background: var(--accent);
        }

        .range-value {
            min-width: 45px;
            text-align: right;
            font-size: 14px;
            font-weight: 600;
        }

        .simple-control {
            margin-bottom: 20px;
        }

        .simple-control label {
            display: block;
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        /* File input */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .playlist-sidebar {
                position: fixed;
                right: 0;
                top: var(--header-height);
                bottom: var(--player-height);
                transform: translateX(100%);
                z-index: 50;
            }

            .playlist-sidebar.open {
                transform: translateX(0);
                box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
            }

            .smart-controls {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .player-left {
                flex: 0 0 auto;
            }

            .volume-control {
                display: none;
            }

            .settings-panel {
                width: 100%;
            }
        }

        /* Utilities */
        .hidden {
            display: none !important;
        }

        /* Mute indicator */
        .volume-control.muted .icon-button {
            color: var(--danger);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <h1 class="header-title">Smart Music</h1>
            <div class="header-buttons">
                <button class="icon-button" id="playlistToggle" title="Toggle Playlist">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/>
                    </svg>
                </button>
                <button class="icon-button" id="settingsBtn" title="Settings">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.08-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                    </svg>
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Now Playing -->
            <div class="now-playing-container">
                <div class="album-art-large" id="albumArtLarge">
                    <span>üéµ</span>
                </div>
                <div class="track-info-large">
                    <h2 class="track-title-large" id="trackTitleLarge">No Track Selected</h2>
                    <p class="track-artist-large" id="trackArtistLarge">
                        <a href="#" class="add-files-link" id="addFilesLink">Select a file to play</a>
                    </p>
                </div>
            </div>

            <!-- Playlist Sidebar -->
            <aside class="playlist-sidebar" id="playlistSidebar">
                <div class="playlist-header">
                    <h2 class="playlist-title">Playlist</h2>
                    <div class="playlist-controls">
                        <button class="icon-button add-button" id="addFilesBtn" title="Add Files">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                            </svg>
                        </button>
                        <button class="icon-button" id="shuffleBtn" title="Shuffle">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>
                            </svg>
                        </button>
                        <button class="icon-button" id="repeatBtn" title="Repeat">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <!-- Hidden file input -->
                <input type="file" id="fileInput" multiple accept="audio/*" style="display: none;">
                <ul class="playlist-items" id="playlistItems">
                    <!-- Playlist items will be added here dynamically -->
                </ul>
            </aside>
        </div>

        <!-- Player Bar -->
        <div class="player-bar">
            <!-- Track Info -->
            <div class="player-left">
                <div class="player-album-art" id="playerAlbumArt">
                    <span>üéµ</span>
                </div>
                <div class="player-track-details">
                    <div class="player-track-title" id="playerTrackTitle">No Track</div>
                    <div class="player-track-artist" id="playerTrackArtist">-</div>
                </div>
            </div>

            <!-- Playback Controls -->
            <div class="player-center">
                <div class="playback-buttons">
                    <button class="playback-button" id="prevBtn" title="Previous">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                        </svg>
                    </button>
                    <button class="playback-button primary" id="playBtn" title="Play/Pause">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </button>
                    <button class="playback-button" id="nextBtn" title="Next">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                        </svg>
                    </button>
                </div>
                <div class="progress-bar">
                    <span class="time-display" id="currentTime">0:00</span>
                    <div class="progress-slider" id="progressBar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <span class="time-display" id="totalTime">0:00</span>
                </div>
            </div>

            <!-- Right Controls -->
            <div class="player-right">
                <!-- Smart Controls -->
                <div class="smart-controls">
                    <!-- Smart Volume Toggle (includes mic) -->
                    <label class="toggle-switch" style="margin: 0;">
                        <input type="checkbox" id="smartVolumeToggle">
                        <span class="toggle-slider"></span>
                    </label>
                    <div class="smart-control-label">
                        <span style="font-size: 11px; color: var(--accent); font-weight: 500;">Mic On/Smart Vol</span>
                        <div class="smart-status-info" id="smartStatusInfo">
                            <div class="smart-status-line">Noise Level <span id="noiseLevel">-- dB</span></div>
                            <div class="smart-status-line">Headroom <span id="headroom">-- dBFS</span></div>
                            <div class="smart-status-line">EQ Curve <span id="eqCurve">--‚Üí-- phon</span></div>
                        </div>
                    </div>
                </div>

                <!-- Volume Control -->
                <div class="volume-control">
                    <button class="icon-button" id="muteBtn">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="volumeIcon">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                    </button>
                    <input type="range" class="volume-slider" id="volumeSlider" 
                           min="0" max="100" value="100">
                </div>
            </div>
        </div>

        <!-- Settings Panel -->
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-header">
                <h2 class="settings-title">Advanced Settings</h2>
                <button class="icon-button" id="closeSettings">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </button>
            </div>
            <div class="settings-content">
                <div class="settings-section">
                    <h3>üéõÔ∏è Smart Volume Settings</h3>
                    <div class="range-control">
                        <label>Volume Above Noise</label>
                        <div class="range-with-value">
                            <input type="range" class="range-slider" id="snrSlider" 
                                   min="0" max="50" value="20" step="1">
                            <span class="range-value" id="snrValue">+20 dB</span>
                        </div>
                        <div style="font-size: 11px; color: var(--text-dim); margin-top: 4px;">
                            How much louder than ambient noise
                        </div>
                    </div>
                    <div class="simple-control">
                        <label>Environmental Monitor</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="micToggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>üéµ Loudness Compensation</h3>
                    <div class="range-control">
                        <label>Target Music Level</label>
                        <div class="range-with-value">
                            <input type="range" class="range-slider" id="targetPhon" 
                                   min="20" max="80" value="60" step="1">
                            <span class="range-value" id="targetPhonValue">60 phon</span>
                        </div>
                    </div>
                    <div class="range-control">
                        <label>Reference Level</label>
                        <div class="range-with-value">
                            <input type="range" class="range-slider" id="referencePhon" 
                                   min="60" max="100" value="80" step="1">
                            <span class="range-value" id="referencePhonValue">80 phon</span>
                        </div>
                    </div>
                    <div class="simple-control">
                        <label>Equal Loudness Compensation</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="equalLoudnessToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>üé§ Microphone Settings</h3>
                    <div class="range-control">
                        <label>Manual Threshold</label>
                        <div class="range-with-value">
                            <input type="range" class="range-slider" id="manualThreshold" 
                                   min="20" max="80" value="45" step="1">
                            <span class="range-value" id="thresholdValue">45 dB</span>
                        </div>
                    </div>
                    <div class="range-control">
                        <label>Microphone Sensitivity</label>
                        <div class="range-with-value">
                            <input type="range" class="range-slider" id="micSensitivity" 
                                   min="0.5" max="5" value="2" step="0.1">
                            <span class="range-value" id="micSensitivityValue">2.0x</span>
                        </div>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>üéß Audio Enhancement</h3>
                    <div class="simple-control">
                        <label>Extra Bass/Treble Boost</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="extraBoostToggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="range-control">
                        <label>Quiet Enhancement</label>
                        <div class="range-with-value">
                            <input type="range" class="range-slider" id="quietEnhancement" 
                                   min="0" max="100" value="100" step="10">
                            <span class="range-value" id="quietEnhancementValue">100%</span>
                        </div>
                    </div>
                    <div class="range-control">
                        <label>Bass Adaptation</label>
                        <div class="range-with-value">
                            <input type="range" class="range-slider" id="bassAdaptation" 
                                   min="0" max="20" value="8" step="1">
                            <span class="range-value" id="bassAdaptationValue">8 dB</span>
                        </div>
                    </div>
                    <div class="range-control">
                        <label>Treble Clarity</label>
                        <div class="range-with-value">
                            <input type="range" class="range-slider" id="trebleClarity" 
                                   min="0" max="10" value="4" step="1">
                            <span class="range-value" id="trebleClarityValue">4 dB</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Smart player logic -->
    <script>
        // ISO 226 data
        const ISO_FREQ_LOCAL = [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160,
                               200, 250, 315, 400, 500, 630, 800, 1000, 1250, 1600,
                               2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000];
        
        const ISO_CURVES_LOCAL = {
            20: [76.90, 68.70, 59.50, 51.10, 44.00, 37.50, 31.50, 26.50, 22.10, 17.90,
                 14.40, 11.40, 8.60, 6.20, 4.40, 3.00, 2.20, 2.40, 3.50, 1.70,
                 -1.30, -4.20, -6.00, -5.40, -1.50, 6.00, 12.60, 13.90, 12.30, 18.40, 48.40],
            40: [57.20, 48.40, 39.60, 31.90, 24.90, 18.40, 12.30, 7.20, 3.00, -0.90,
                 -4.30, -7.30, -9.90, -11.90, -13.30, -14.10, -14.40, -13.70, -12.10, -11.30,
                 -10.90, -11.20, -11.00, -9.00, -4.50, 3.00, 10.40, 13.10, 11.30, 17.20, 47.20],
            60: [41.70, 32.40, 23.90, 16.40, 10.00, 4.10, -1.30, -5.70, -9.30, -12.30,
                 -14.70, -16.50, -17.70, -18.30, -18.50, -18.20, -17.30, -15.80, -13.60, -11.70,
                 -10.10, -8.70, -7.10, -4.50, -0.30, 5.20, 11.50, 14.30, 12.40, 18.10, 48.10],
            80: [31.80, 22.40, 14.10, 7.10, 1.30, -3.80, -8.30, -11.80, -14.50, -16.30,
                 -17.40, -17.80, -17.70, -17.00, -15.80, -14.00, -11.60, -8.50, -5.10, -2.50,
                 -0.50, 1.10, 2.70, 5.10, 8.60, 13.10, 18.00, 20.80, 18.80, 24.80, 54.80]
        };

        // Smart Music Player Class
        class SmartMusicPlayer {
            constructor() {
                // Audio context and nodes
                this.audioContext = null;
                this.audioElement = null;
                this.source = null;
                this.analyser = null;
                
                // DSP nodes
                this.dryGain = null;
                this.wetGainA = null;
                this.wetGainB = null;
                this.masterGain = null;
                this.compensationGain = null;
                this.volumeGainA = null;
                this.volumeGainB = null;
                this.firFilterA = null;
                this.firFilterB = null;
                
                // FIR filter properties
                this.numTaps = 513;
                this.firCoeffsA = null;
                this.firCoeffsB = null;
                this.currentFilterNode = 'A';
                this.currentVolumeNode = 'A';
                
                // Player state
                this.isPlaying = false;
                this.currentFile = null;
                this.playlist = [];
                this.currentTrackIndex = -1;
                this.isPlaylistMode = false;
                this.shuffleMode = false;
                this.repeatMode = 'off'; // off, all, one
                this.shuffleQueue = [];
                this.isMuted = false;
                this.previousVolume = 100;
                
                // Smart volume parameters
                this.smartMode = false;
                this.isListening = false;
                this.targetPhon = 60;
                this.referencePhon = 80;
                this.snrTarget = 20;
                this.manualThreshold = 45;
                this.micSensitivity = 2;
                this.noiseLevel = 35;
                this.autoGain = 0;
                this.normalizationOffset = 0;
                this.dynamicHeadroomReserve = 6;
                this.targetVolumeValue = 1.0;
                
                // Loudness compensation
                this.equalLoudnessEnabled = true;
                this.extraBoostEnabled = false;
                this.quietEnhancement = 100;
                this.bassAdaptation = 8;
                this.trebleClarity = 4;
                
                // ISO data
                this.fineGrainedISO226 = null;
                
                // Microphone processing
                this.micStream = null;
                this.micSource = null;
                this.micAnalyser = null;
                this.micProcessor = null;
                
                // Album art cache
                this.albumArtCache = new Map();
                
                // Initialize
                this.init();
            }
            
            async init() {
                // Initialize audio context
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create audio element
                this.audioElement = new Audio();
                this.audioElement.crossOrigin = "anonymous";
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Load saved settings
                this.loadSettings();
                
                // Initialize UI
                this.updateUI();
            }
            
            setupEventListeners() {
                // Audio element events
                this.audioElement.addEventListener('ended', () => this.handleTrackEnded());
                this.audioElement.addEventListener('timeupdate', () => this.updateProgress());
                this.audioElement.addEventListener('loadedmetadata', () => this.updateDuration());
                
                // Playback controls
                document.getElementById('playBtn').addEventListener('click', () => this.togglePlayPause());
                document.getElementById('prevBtn').addEventListener('click', () => this.playPrevious());
                document.getElementById('nextBtn').addEventListener('click', () => this.playNext());
                
                // Progress bar
                const progressBar = document.getElementById('progressBar');
                progressBar.addEventListener('click', (e) => this.seekTo(e));
                
                // Volume control
                document.getElementById('muteBtn').addEventListener('click', () => this.toggleMute());
                document.getElementById('volumeSlider').addEventListener('input', (e) => this.updateMasterVolume());
                
                // Smart controls
                // Smart Volume toggle (includes mic)
                document.getElementById('smartVolumeToggle').addEventListener('change', async (e) => {
                    if (e.target.checked) {
                        // Enable mic first, then smart volume
                        await this.toggleMicrophone(true);
                        this.toggleSmartVolume();
                    } else {
                        // Disable both
                        this.toggleSmartVolume();
                        this.toggleMicrophone(false);
                    }
                });
                
                // Sync settings panel mic toggle
                document.getElementById('micToggle').addEventListener('change', (e) => {
                    document.getElementById('smartVolumeToggle').checked = e.target.checked && this.smartMode;
                });
                
                // Playlist controls
                document.getElementById('shuffleBtn').addEventListener('click', () => this.toggleShuffle());
                document.getElementById('repeatBtn').addEventListener('click', () => this.toggleRepeat());
                document.getElementById('playlistToggle').addEventListener('click', () => this.togglePlaylistSidebar());
                
                // File input
                document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileSelect(e));
                document.getElementById('addFilesBtn').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });
                document.getElementById('addFilesLink').addEventListener('click', (e) => {
                    e.preventDefault();
                    document.getElementById('fileInput').click();
                });
                
                // Settings
                document.getElementById('settingsBtn').addEventListener('click', () => this.openSettings());
                document.getElementById('closeSettings').addEventListener('click', () => this.closeSettings());
                
                // Settings controls
                this.setupSettingsListeners();
            }
            
            setupSettingsListeners() {
                // Smart volume
                document.getElementById('snrSlider').addEventListener('input', (e) => {
                    this.snrTarget = parseInt(e.target.value);
                    document.getElementById('snrValue').textContent = `+${this.snrTarget} dB`;
                    this.updateSmartFilters();
                });
                
                // Loudness compensation
                document.getElementById('targetPhon').addEventListener('input', (e) => {
                    this.targetPhon = parseInt(e.target.value);
                    document.getElementById('targetPhonValue').textContent = `${this.targetPhon} phon`;
                    this.updateSmartFilters();
                });
                
                document.getElementById('referencePhon').addEventListener('input', (e) => {
                    this.referencePhon = parseInt(e.target.value);
                    document.getElementById('referencePhonValue').textContent = `${this.referencePhon} phon`;
                    this.updateSmartFilters();
                });
                
                document.getElementById('equalLoudnessToggle').addEventListener('change', (e) => {
                    this.equalLoudnessEnabled = e.target.checked;
                    this.updateSmartFilters();
                });
                
                // Microphone settings
                document.getElementById('manualThreshold').addEventListener('input', (e) => {
                    this.manualThreshold = parseInt(e.target.value);
                    document.getElementById('thresholdValue').textContent = `${this.manualThreshold} dB`;
                });
                
                document.getElementById('micSensitivity').addEventListener('input', (e) => {
                    this.micSensitivity = parseFloat(e.target.value);
                    document.getElementById('micSensitivityValue').textContent = `${this.micSensitivity.toFixed(1)}x`;
                });
                
                // Audio enhancement
                document.getElementById('extraBoostToggle').addEventListener('change', (e) => {
                    this.extraBoostEnabled = e.target.checked;
                    this.updateSmartFilters();
                });
                
                document.getElementById('quietEnhancement').addEventListener('input', (e) => {
                    this.quietEnhancement = parseInt(e.target.value);
                    document.getElementById('quietEnhancementValue').textContent = `${this.quietEnhancement}%`;
                    this.updateSmartFilters();
                });
                
                document.getElementById('bassAdaptation').addEventListener('input', (e) => {
                    this.bassAdaptation = parseInt(e.target.value);
                    document.getElementById('bassAdaptationValue').textContent = `${this.bassAdaptation} dB`;
                    this.updateSmartFilters();
                });
                
                document.getElementById('trebleClarity').addEventListener('input', (e) => {
                    this.trebleClarity = parseInt(e.target.value);
                    document.getElementById('trebleClarityValue').textContent = `${this.trebleClarity} dB`;
                    this.updateSmartFilters();
                });
            }
            
            async handleFileSelect(event) {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;
                
                // Clear playlist and add new files
                this.playlist = [];
                this.albumArtCache.clear();
                
                for (const file of files) {
                    // Extract metadata including album art
                    let metadata = null;
                    let albumArt = null;
                    
                    try {
                        if (window.parseAudioMetadata) {
                            metadata = await window.parseAudioMetadata(file);
                            
                            // Extract album art if available
                            if (metadata.common && metadata.common.picture && metadata.common.picture.length > 0) {
                                const picture = metadata.common.picture[0];
                                const blob = new Blob([picture.data], { type: picture.format });
                                albumArt = URL.createObjectURL(blob);
                                this.albumArtCache.set(file.name, albumArt);
                            }
                        }
                    } catch (error) {
                        console.warn('Error parsing metadata:', error);
                    }
                    
                    this.playlist.push({
                        file: file,
                        name: file.name,
                        title: metadata?.common?.title || file.name.replace(/\.[^/.]+$/, ''),
                        artist: metadata?.common?.artist || 'Unknown Artist',
                        duration: metadata?.format?.duration || 0,
                        albumArt: albumArt
                    });
                }
                
                this.isPlaylistMode = true;
                this.updatePlaylistUI();
                
                // Load first track
                if (this.playlist.length > 0) {
                    await this.loadTrack(0);
                }
            }
            
            async loadTrack(index) {
                if (index < 0 || index >= this.playlist.length) return;
                
                this.currentTrackIndex = index;
                const track = this.playlist[index];
                
                // Create object URL for the file
                const url = URL.createObjectURL(track.file);
                this.audioElement.src = url;
                
                // Update UI
                this.updateTrackInfo(track);
                this.updatePlaylistUI();
                
                // Create audio graph if needed
                if (!this.source) {
                    this.createAudioGraph();
                }
            }
            
            updateTrackInfo(track) {
                // Update now playing
                document.getElementById('trackTitleLarge').textContent = track.title;
                document.getElementById('trackArtistLarge').textContent = track.artist;
                
                // Update player bar
                document.getElementById('playerTrackTitle').textContent = track.title;
                document.getElementById('playerTrackArtist').textContent = track.artist;
                
                // Update album art
                const albumArtLarge = document.getElementById('albumArtLarge');
                const playerAlbumArt = document.getElementById('playerAlbumArt');
                
                if (track.albumArt) {
                    albumArtLarge.innerHTML = `<img src="${track.albumArt}" alt="Album Art">`;
                    playerAlbumArt.innerHTML = `<img src="${track.albumArt}" alt="Album Art">`;
                } else {
                    albumArtLarge.innerHTML = '<span>üéµ</span>';
                    playerAlbumArt.innerHTML = '<span>üéµ</span>';
                }
            }
            
            updatePlaylistUI() {
                const playlistItems = document.getElementById('playlistItems');
                playlistItems.innerHTML = '';
                
                this.playlist.forEach((track, index) => {
                    const li = document.createElement('li');
                    li.className = 'playlist-item';
                    if (index === this.currentTrackIndex) {
                        li.classList.add('active');
                    }
                    
                    const duration = track.duration ? this.formatTime(track.duration) : '--:--';
                    
                    li.innerHTML = `
                        <span class="playlist-item-index">${index + 1}</span>
                        <div class="playlist-item-thumb">
                            ${track.albumArt ? `<img src="${track.albumArt}" alt="">` : '<span>üéµ</span>'}
                        </div>
                        <div class="playlist-item-info">
                            <div class="playlist-item-title">${track.title}</div>
                            <div class="playlist-item-duration">${duration}</div>
                        </div>
                    `;
                    
                    li.addEventListener('click', () => this.loadTrack(index));
                    playlistItems.appendChild(li);
                });
            }
            
            togglePlayPause() {
                if (!this.audioElement.src) return;
                
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            }
            
            async play() {
                if (!this.audioElement.src) return;
                
                try {
                    // Resume audio context if suspended
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    await this.audioElement.play();
                    this.isPlaying = true;
                    
                    // Update play button icon
                    const playBtn = document.getElementById('playBtn');
                    playBtn.innerHTML = `
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    `;
                } catch (error) {
                    console.error('Error playing:', error);
                }
            }
            
            pause() {
                if (!this.audioElement) return;
                
                this.audioElement.pause();
                this.isPlaying = false;
                
                // Update play button icon
                const playBtn = document.getElementById('playBtn');
                playBtn.innerHTML = `
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                `;
            }
            
            async playNext() {
                if (!this.isPlaylistMode || this.playlist.length === 0) return;
                
                let nextIndex;
                
                if (this.shuffleMode) {
                    // Shuffle logic
                    if (this.shuffleQueue.length === 0) {
                        this.shuffleQueue = Array.from({length: this.playlist.length}, (_, i) => i)
                            .filter(i => i !== this.currentTrackIndex);
                        
                        // Shuffle the queue
                        for (let i = this.shuffleQueue.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [this.shuffleQueue[i], this.shuffleQueue[j]] = [this.shuffleQueue[j], this.shuffleQueue[i]];
                        }
                    }
                    
                    nextIndex = this.shuffleQueue.shift();
                    
                    if (nextIndex === undefined) {
                        if (this.repeatMode === 'all') {
                            this.shuffleQueue = Array.from({length: this.playlist.length}, (_, i) => i);
                            for (let i = this.shuffleQueue.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [this.shuffleQueue[i], this.shuffleQueue[j]] = [this.shuffleQueue[j], this.shuffleQueue[i]];
                            }
                            nextIndex = this.shuffleQueue.shift();
                        } else {
                            return;
                        }
                    }
                } else {
                    // Sequential playback
                    nextIndex = this.currentTrackIndex + 1;
                    if (nextIndex >= this.playlist.length) {
                        if (this.repeatMode === 'all') {
                            nextIndex = 0;
                        } else {
                            return;
                        }
                    }
                }
                
                await this.loadTrack(nextIndex);
                if (this.isPlaying) {
                    this.play();
                }
            }
            
            async playPrevious() {
                if (!this.isPlaylistMode || this.playlist.length === 0) return;
                
                let prevIndex = this.currentTrackIndex - 1;
                if (prevIndex < 0) {
                    if (this.repeatMode === 'all') {
                        prevIndex = this.playlist.length - 1;
                    } else {
                        prevIndex = 0;
                    }
                }
                
                await this.loadTrack(prevIndex);
                if (this.isPlaying) {
                    this.play();
                }
            }
            
            handleTrackEnded() {
                if (this.repeatMode === 'one') {
                    this.audioElement.currentTime = 0;
                    this.play();
                } else {
                    this.playNext();
                }
            }
            
            updateProgress() {
                if (!this.audioElement || !this.audioElement.duration) return;
                
                const currentTime = this.audioElement.currentTime;
                const duration = this.audioElement.duration;
                const progress = (currentTime / duration) * 100;
                
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('currentTime').textContent = this.formatTime(currentTime);
            }
            
            updateDuration() {
                if (!this.audioElement) return;
                
                const duration = this.audioElement.duration;
                document.getElementById('totalTime').textContent = this.formatTime(duration);
            }
            
            seekTo(event) {
                if (!this.audioElement || !this.audioElement.duration) return;
                
                const progressBar = event.currentTarget;
                const rect = progressBar.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const percentage = x / rect.width;
                const time = percentage * this.audioElement.duration;
                
                this.audioElement.currentTime = time;
            }
            
            formatTime(seconds) {
                if (!seconds || isNaN(seconds)) return '0:00';
                
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            toggleMute() {
                if (this.isMuted) {
                    // Unmute
                    document.getElementById('volumeSlider').value = this.previousVolume;
                    this.isMuted = false;
                    this.updateMuteIcon(false);
                } else {
                    // Mute
                    this.previousVolume = document.getElementById('volumeSlider').value;
                    document.getElementById('volumeSlider').value = 0;
                    this.isMuted = true;
                    this.updateMuteIcon(true);
                }
                this.updateMasterVolume();
            }
            
            updateMuteIcon(isMuted) {
                const volumeIcon = document.getElementById('volumeIcon');
                const volumeControl = document.querySelector('.volume-control');
                
                if (isMuted) {
                    volumeControl.classList.add('muted');
                    volumeIcon.innerHTML = '<path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>';
                } else {
                    volumeControl.classList.remove('muted');
                    volumeIcon.innerHTML = '<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>';
                }
            }
            
            toggleSmartVolume() {
                this.smartMode = !this.smartMode;
                this.updateSmartUI();
                
                if (this.smartMode) {
                    // Change slider to smart volume mode
                    const volumeSlider = document.getElementById('volumeSlider');
                    volumeSlider.classList.add('smart-mode');
                    volumeSlider.disabled = false; // Keep enabled for smart volume control
                    volumeSlider.value = this.snrTarget * 2; // Map 0-50 dB to 0-100 slider
                    volumeSlider.title = 'Smart Volume: +' + this.snrTarget + ' dB above noise';
                    this.updateMasterVolume();
                } else {
                    // Re-enable manual volume control
                    const volumeSlider = document.getElementById('volumeSlider');
                    volumeSlider.classList.remove('smart-mode');
                    volumeSlider.disabled = false;
                    volumeSlider.value = 100; // Reset to full volume
                    volumeSlider.title = 'Master Volume';
                }
                
                this.updateSmartFilters();
            }
            
            updateSmartUI() {
                const smartStatusInfo = document.getElementById('smartStatusInfo');
                const smartToggle = document.getElementById('smartVolumeToggle');
                
                // Update toggle state
                smartToggle.checked = this.smartMode && this.isListening;
                
                // Show/hide status info
                if (this.smartMode && this.isListening) {
                    smartStatusInfo.classList.add('active');
                    // Update status values
                    this.updateSmartStatusDisplay();
                } else {
                    smartStatusInfo.classList.remove('active');
                }
            }
            
            updateSmartStatusDisplay() {
                // Update noise level
                document.getElementById('noiseLevel').textContent = this.noiseLevel.toFixed(1) + ' dB';
                
                // Update headroom
                const effectiveLevel = this.targetPhon + this.autoGain;
                const headroomLUFS = -(effectiveLevel - 85);
                document.getElementById('headroom').textContent = (-headroomLUFS).toFixed(1) + ' dBFS';
                
                // Update EQ curve
                document.getElementById('eqCurve').textContent = 
                    `${effectiveLevel.toFixed(0)}‚Üí${this.referencePhon} phon`;
            }
            
            async toggleMicrophone(enable) {
                if (enable) {
                    await this.startMicrophone();
                } else {
                    this.stopMicrophone();
                }
            }
            
            async startMicrophone() {
                try {
                    this.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.micSource = this.audioContext.createMediaStreamSource(this.micStream);
                    this.micAnalyser = this.audioContext.createAnalyser();
                    this.micAnalyser.fftSize = 2048;
                    this.micAnalyser.smoothingTimeConstant = 0.8;
                    
                    this.micSource.connect(this.micAnalyser);
                    
                    this.isListening = true;
                    this.updateSmartUI();
                    
                    // Start noise monitoring
                    this.monitorNoise();
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    document.getElementById('micToggle').checked = false;
                }
            }
            
            stopMicrophone() {
                if (this.micStream) {
                    this.micStream.getTracks().forEach(track => track.stop());
                    this.micStream = null;
                }
                
                if (this.micSource) {
                    this.micSource.disconnect();
                    this.micSource = null;
                }
                
                this.isListening = false;
                this.updateSmartUI();
                document.getElementById('noiseLevel').textContent = '-- dB';
            }
            
            // Main monitoring loop - only handles scheduling
            monitorNoise() {
                if (!this.isListening || !this.micAnalyser) return;
                
                // Measure current noise level
                const currentDb = this.measureNoiseLevel();
                
                // Update smoothed noise level
                this.updateNoiseLevel(currentDb);
                
                // Handle smart volume updates if needed
                this.processNoiseUpdate();
                
                // Continue monitoring
                requestAnimationFrame(() => this.monitorNoise());
            }
            
            // Measure current noise level from microphone
            measureNoiseLevel() {
                const dataArray = new Float32Array(this.micAnalyser.fftSize);
                this.micAnalyser.getFloatTimeDomainData(dataArray);
                
                // Calculate RMS
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / dataArray.length);
                
                // Convert to dB with calibration
                const db = 20 * Math.log10(Math.max(rms, 1e-10)) + 94;
                return db * this.micSensitivity;
            }
            
            // Update smoothed noise level
            updateNoiseLevel(currentDb) {
                this.noiseLevel = this.noiseLevel * 0.9 + currentDb * 0.1;
            }
            
            // Process noise updates for smart volume
            processNoiseUpdate() {
                if (this.smartMode) {
                    this.updateSmartVolume();
                    this.updateSmartStatusDisplay();
                }
            }
            
            updateSmartVolume() {
                if (!this.smartMode) return;
                
                // Calculate target volume based on noise level
                const targetDb = this.noiseLevel + this.snrTarget;
                const newAutoGain = targetDb - this.targetPhon;
                
                // Only update if there's a significant change (0.5 dB threshold)
                if (Math.abs(newAutoGain - this.autoGain) > 0.5) {
                    this.autoGain = newAutoGain;
                    
                    // Update filters and volume
                    this.updateSmartFilters();
                    this.updateMasterVolume();
                }
            }
            
            toggleShuffle() {
                this.shuffleMode = !this.shuffleMode;
                const shuffleBtn = document.getElementById('shuffleBtn');
                
                if (this.shuffleMode) {
                    shuffleBtn.classList.add('active');
                    // Reset shuffle queue
                    this.shuffleQueue = [];
                } else {
                    shuffleBtn.classList.remove('active');
                }
            }
            
            toggleRepeat() {
                const repeatBtn = document.getElementById('repeatBtn');
                
                if (this.repeatMode === 'off') {
                    this.repeatMode = 'all';
                    repeatBtn.classList.add('active');
                } else if (this.repeatMode === 'all') {
                    this.repeatMode = 'one';
                    repeatBtn.classList.add('active');
                    repeatBtn.style.color = 'var(--accent)';
                } else {
                    this.repeatMode = 'off';
                    repeatBtn.classList.remove('active');
                    repeatBtn.style.color = '';
                }
            }
            
            togglePlaylistSidebar() {
                const sidebar = document.getElementById('playlistSidebar');
                sidebar.classList.toggle('open');
            }
            
            openSettings() {
                document.getElementById('settingsPanel').classList.add('open');
            }
            
            closeSettings() {
                document.getElementById('settingsPanel').classList.remove('open');
                this.saveSettings();
            }
            
            // Core DSP methods
            createAudioGraph() {
                if (!this.audioElement) return;
                
                console.log('Creating audio graph for smart playback...');
                
                const needsInitialSetup = !this.wetGainA || !this.wetGainB;
                
                try {
                    if (!this.source) {
                        this.source = this.audioContext.createMediaElementSource(this.audioElement);
                    }
                } catch (error) {
                    console.error('Error creating media source:', error);
                    return;
                }
                
                if (needsInitialSetup) {
                    // Create all audio nodes
                    this.dryGain = this.audioContext.createGain();
                    this.wetGainA = this.audioContext.createGain();
                    this.wetGainB = this.audioContext.createGain();
                    this.masterGain = this.audioContext.createGain();
                    this.compensationGain = this.audioContext.createGain();
                    
                    // Volume A/B nodes
                    this.volumeGainA = this.audioContext.createGain();
                    this.volumeGainB = this.audioContext.createGain();
                    this.volumeGainA.gain.value = 1.0;
                    this.volumeGainB.gain.value = 0.0;
                    
                    // Create FIR filters
                    this.firFilterA = this.audioContext.createConvolver();
                    this.firFilterA.normalize = false;
                    this.firFilterB = this.audioContext.createConvolver();
                    this.firFilterB.normalize = false;
                    
                    // Generate initial filter coefficients
                    const initialCoeffs = this.generateFlatResponse();
                    this.firCoeffsA = new Float32Array(initialCoeffs);
                    this.firCoeffsB = new Float32Array(initialCoeffs);
                    
                    const filterBufferA = this.audioContext.createBuffer(1, this.numTaps, this.audioContext.sampleRate);
                    filterBufferA.copyToChannel(this.firCoeffsA, 0);
                    this.firFilterA.buffer = filterBufferA;
                    
                    const filterBufferB = this.audioContext.createBuffer(1, this.numTaps, this.audioContext.sampleRate);
                    filterBufferB.copyToChannel(this.firCoeffsB, 0);
                    this.firFilterB.buffer = filterBufferB;
                    
                    // Connect audio graph
                    this.source.connect(this.dryGain);
                    this.dryGain.connect(this.compensationGain);
                    
                    this.source.connect(this.firFilterA);
                    this.firFilterA.connect(this.wetGainA);
                    this.wetGainA.connect(this.compensationGain);
                    
                    this.source.connect(this.firFilterB);
                    this.firFilterB.connect(this.wetGainB);
                    this.wetGainB.connect(this.compensationGain);
                    
                    this.compensationGain.connect(this.volumeGainA);
                    this.compensationGain.connect(this.volumeGainB);
                    this.volumeGainA.connect(this.masterGain);
                    this.volumeGainB.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Set initial gains - 100% wet to avoid phase issues
                    this.dryGain.gain.value = 0.0;  // No dry signal
                    this.wetGainA.gain.value = 1.0;  // 100% wet signal
                    this.wetGainB.gain.value = 0.0;
                    this.compensationGain.gain.value = 1.0;
                    this.masterGain.gain.value = 1.0;
                    
                    // Initialize volume
                    setTimeout(() => {
                        this.updateMasterVolume();
                    }, 100);
                } else {
                    // Reconnect for new track
                    try {
                        this.source.disconnect();
                    } catch (e) {}
                    
                    this.source.connect(this.dryGain);
                    this.source.connect(this.firFilterA);
                    this.source.connect(this.firFilterB);
                }
            }
            
            generateFlatResponse() {
                // Generate a flat frequency response (bypass filter)
                const coeffs = new Float32Array(this.numTaps);
                const center = Math.floor(this.numTaps / 2);
                coeffs[center] = 1.0;
                return coeffs;
            }
            
            updateSmartFilters() {
                if (!this.audioContext || !this.firFilterA || !this.firFilterB) return;
                
                // Generate new filter coefficients
                const newCoeffs = this.generateSmartLoudnessFilter();
                if (!newCoeffs) return;
                
                // Determine which filter to update
                const targetFilter = this.currentFilterNode === 'A' ? 'B' : 'A';
                const targetFilterNode = targetFilter === 'A' ? this.firFilterA : this.firFilterB;
                const targetWetGain = targetFilter === 'A' ? this.wetGainA : this.wetGainB;
                const currentWetGain = this.currentFilterNode === 'A' ? this.wetGainA : this.wetGainB;
                
                // Create new filter buffer
                const filterBuffer = this.audioContext.createBuffer(1, this.numTaps, this.audioContext.sampleRate);
                filterBuffer.copyToChannel(newCoeffs, 0);
                targetFilterNode.buffer = filterBuffer;
                
                // Smooth transition
                const now = this.audioContext.currentTime;
                targetWetGain.gain.setValueAtTime(0, now);
                targetWetGain.gain.linearRampToValueAtTime(1.0, now + 0.5);
                currentWetGain.gain.linearRampToValueAtTime(0, now + 0.5);
                
                // Update current filter reference
                setTimeout(() => {
                    this.currentFilterNode = targetFilter;
                }, 500);
            }
            
            generateSmartLoudnessFilter() {
                if (!this.audioContext) return null;
                
                // Initialize interpolated ISO data if not already done
                if (!this.fineGrainedISO226) {
                    this.fineGrainedISO226 = this.interpISO(ISO_CURVES_LOCAL, 0.1);
                }
                
                const nyquist = this.audioContext.sampleRate / 2;
                const numFreqs = 512;
                const frequencies = [];
                const amplitudes = [];
                
                // Generate log-spaced frequencies
                for (let i = 0; i < numFreqs; i++) {
                    const logFreq = Math.log10(20) + (i / (numFreqs - 1)) * (Math.log10(nyquist) - Math.log10(20));
                    frequencies.push(Math.pow(10, logFreq));
                }
                
                // Calculate compensation for each frequency
                const targetPhonData = this.fineGrainedISO226[this.findNearestPhon(this.targetPhon, this.fineGrainedISO226)];
                const referencePhonData = this.fineGrainedISO226[this.findNearestPhon(this.referencePhon, this.fineGrainedISO226)];
                
                for (const freq of frequencies) {
                    const targetSPL = this.interpolateISO(freq, ISO_FREQ_LOCAL, targetPhonData);
                    const referenceSPL = this.interpolateISO(freq, ISO_FREQ_LOCAL, referencePhonData);
                    
                    let compensation = targetSPL - referenceSPL;
                    
                    // Apply quietEnhancement scaling (0-100% of compensation)
                    compensation *= (this.quietEnhancement / 100);
                    
                    // Apply smart adjustments based on environment
                    if (this.smartMode && this.isListening) {
                        // Extra bass boost in noisy environments
                        if (freq < 200 && this.noiseLevel > this.manualThreshold) {
                            compensation += this.bassAdaptation * ((this.noiseLevel - this.manualThreshold) / 20);
                        }
                        
                        // Treble clarity enhancement
                        if (freq > 2000 && freq < 8000) {
                            compensation += this.trebleClarity * ((this.noiseLevel - 35) / 30);
                        }
                    }
                    
                    // Apply extra boost if enabled
                    if (this.extraBoostEnabled) {
                        if (freq < 100) compensation += 3; // Extra bass
                        if (freq > 8000) compensation += 2; // Extra treble
                    }
                    
                    // Convert dB to linear amplitude
                    amplitudes.push(Math.pow(10, compensation / 20));
                }
                
                // Add boundary frequencies
                frequencies.unshift(0);
                amplitudes.unshift(amplitudes[0]);
                frequencies.push(nyquist);
                amplitudes.push(amplitudes[amplitudes.length - 1]);
                
                // Design FIR filter
                return this.designFIR(this.numTaps, frequencies, amplitudes);
            }
            
            // ISO 226 interpolation methods
            interpISO(isoCurves, increment) {
                const result = {};
                const phonLevels = Object.keys(isoCurves).map(Number).sort((a, b) => a - b);
                
                for (let i = 0; i < phonLevels.length - 1; i++) {
                    const phon1 = phonLevels[i];
                    const phon2 = phonLevels[i + 1];
                    const curve1 = isoCurves[phon1];
                    const curve2 = isoCurves[phon2];
                    
                    result[phon1] = curve1;
                    
                    // Interpolate between phon1 and phon2
                    for (let phon = phon1 + increment; phon < phon2; phon += increment) {
                        const t = (phon - phon1) / (phon2 - phon1);
                        const interpolatedCurve = curve1.map((val1, idx) => {
                            const val2 = curve2[idx];
                            return val1 + t * (val2 - val1);
                        });
                        result[phon.toFixed(1)] = interpolatedCurve;
                    }
                }
                
                result[phonLevels[phonLevels.length - 1]] = isoCurves[phonLevels[phonLevels.length - 1]];
                return result;
            }
            
            findNearestPhon(targetPhon, fineGrainedISO) {
                const phonLevels = Object.keys(fineGrainedISO).map(Number);
                let nearest = phonLevels[0];
                let minDiff = Math.abs(targetPhon - nearest);
                
                for (const phon of phonLevels) {
                    const diff = Math.abs(targetPhon - phon);
                    if (diff < minDiff) {
                        minDiff = diff;
                        nearest = phon;
                    }
                }
                
                return nearest;
            }
            
            interpolateISO(freq, isoFreqs, isoData) {
                // Find surrounding frequency points
                for (let i = 0; i < isoFreqs.length - 1; i++) {
                    if (freq >= isoFreqs[i] && freq <= isoFreqs[i + 1]) {
                        const f1 = isoFreqs[i];
                        const f2 = isoFreqs[i + 1];
                        const spl1 = isoData[i];
                        const spl2 = isoData[i + 1];
                        
                        // Log-scale interpolation
                        const t = (Math.log10(freq) - Math.log10(f1)) / (Math.log10(f2) - Math.log10(f1));
                        return spl1 + t * (spl2 - spl1);
                    }
                }
                
                // Extrapolate if outside range
                if (freq < isoFreqs[0]) {
                    return isoData[0];
                }
                return isoData[isoData.length - 1];
            }
            
            // FIR filter design methods
            designFIR(numTaps, frequencies, amplitudes, windowType = 'hamming') {
                // Ensure odd number of taps for Type I FIR filter
                if (numTaps % 2 === 0) {
                    numTaps += 1;
                }
                
                const h = new Float32Array(numTaps);
                const M = numTaps - 1;
                const center = M / 2;
                
                // Design using frequency sampling method
                const N = 8192; // FFT size for frequency sampling
                const H = new Float32Array(N);
                
                // Interpolate the frequency response
                for (let k = 0; k < N/2 + 1; k++) {
                    const freq = k * (this.audioContext.sampleRate / 2) / (N/2);
                    H[k] = this.interpolateResponse(freq, frequencies, amplitudes);
                }
                
                // Mirror for negative frequencies (conjugate symmetry)
                for (let k = N/2 + 1; k < N; k++) {
                    H[k] = H[N - k];
                }
                
                // IFFT to get impulse response
                const impulse = this.ifft(H);
                
                // Extract and window the coefficients
                const window = this.getWindow(numTaps, windowType);
                for (let n = 0; n < numTaps; n++) {
                    const idx = (n - center + N) % N;
                    h[n] = impulse[idx] * window[n];
                }
                
                // Normalize for unity gain at DC
                let sum = 0;
                for (let i = 0; i < numTaps; i++) {
                    sum += h[i];
                }
                if (sum !== 0) {
                    for (let i = 0; i < numTaps; i++) {
                        h[i] /= sum;
                    }
                }
                
                return h;
            }
            
            interpolateResponse(freq, frequencies, amplitudes) {
                // Linear interpolation between frequency points
                for (let i = 0; i < frequencies.length - 1; i++) {
                    if (freq >= frequencies[i] && freq <= frequencies[i + 1]) {
                        const f1 = frequencies[i];
                        const f2 = frequencies[i + 1];
                        const a1 = amplitudes[i];
                        const a2 = amplitudes[i + 1];
                        
                        const t = (freq - f1) / (f2 - f1);
                        return a1 + t * (a2 - a1);
                    }
                }
                
                // Extrapolate if outside range
                if (freq < frequencies[0]) {
                    return amplitudes[0];
                }
                return amplitudes[amplitudes.length - 1];
            }
            
            getWindow(length, windowType) {
                const window = new Float32Array(length);
                
                switch (windowType) {
                    case 'hamming':
                        for (let n = 0; n < length; n++) {
                            window[n] = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (length - 1));
                        }
                        break;
                    case 'hann':
                        for (let n = 0; n < length; n++) {
                            window[n] = 0.5 * (1 - Math.cos(2 * Math.PI * n / (length - 1)));
                        }
                        break;
                    case 'blackman':
                        for (let n = 0; n < length; n++) {
                            window[n] = 0.42 - 0.5 * Math.cos(2 * Math.PI * n / (length - 1)) 
                                       + 0.08 * Math.cos(4 * Math.PI * n / (length - 1));
                        }
                        break;
                    default: // rectangular
                        window.fill(1.0);
                }
                
                return window;
            }
            
            // Simple IFFT implementation
            ifft(X) {
                const N = X.length;
                const x = new Float32Array(N);
                
                // Use naive DFT for simplicity (would use FFT library in production)
                for (let n = 0; n < N; n++) {
                    let real = 0;
                    for (let k = 0; k < N; k++) {
                        const angle = 2 * Math.PI * k * n / N;
                        real += X[k] * Math.cos(angle);
                    }
                    x[n] = real / N;
                }
                
                return x;
            }
            
            updateMasterVolume() {
                if (!this.masterGain || !this.volumeGainA || !this.volumeGainB) {
                    return;
                }
                
                const volumeSlider = document.getElementById('volumeSlider');
                let volume = parseInt(volumeSlider.value) / 100;
                
                // In smart mode, slider controls SNR instead of volume
                if (this.smartMode) {
                    // Slider value 0-100 maps to SNR 0-50 dB
                    this.snrTarget = Math.round(volumeSlider.value / 2);
                    volumeSlider.title = 'Smart Volume: +' + this.snrTarget + ' dB above noise';
                    
                    // Update SNR in settings
                    if (document.getElementById('snrSlider')) {
                        document.getElementById('snrSlider').value = this.snrTarget;
                        document.getElementById('snrValue').textContent = '+' + this.snrTarget + ' dB';
                    }
                    
                    // Fixed volume at 100% for smart mode
                    volume = 1.0;
                    
                    // Recalculate auto gain based on new SNR
                    if (this.isListening) {
                        const targetMusicLevel = this.noiseLevel + this.snrTarget;
                        this.autoGain = Math.max(0, targetMusicLevel - this.targetPhon);
                    }
                }
                
                // With 85dB calibration and volume at 100%, we want targetPhon output
                const baseAttenuation = this.targetPhon - 85;
                
                // Apply track normalization and auto gain
                const totalAttenuation = baseAttenuation + this.autoGain + this.normalizationOffset;
                
                // Convert to linear gain
                const calibratedGain = Math.pow(10, totalAttenuation / 20);
                
                // Apply user volume control (or fixed at 100% for smart mode)
                const finalGain = volume * calibratedGain;
                this.targetVolumeValue = finalGain;
                
                console.log(`Volume calc: base ${baseAttenuation}dB + auto ${this.autoGain}dB = ${totalAttenuation}dB, gain: ${finalGain.toFixed(3)}`);
                
                // Use A/B transition for smooth volume change
                const targetNode = this.currentVolumeNode === 'A' ? 'B' : 'A';
                const targetGainNode = targetNode === 'A' ? this.volumeGainA : this.volumeGainB;
                const currentGainNode = this.currentVolumeNode === 'A' ? this.volumeGainA : this.volumeGainB;
                
                const now = this.audioContext.currentTime;
                targetGainNode.gain.setValueAtTime(finalGain, now);
                currentGainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                targetGainNode.gain.linearRampToValueAtTime(finalGain, now + 0.2);
                
                setTimeout(() => {
                    this.currentVolumeNode = targetNode;
                }, 200);
            }
            
            updateUI() {
                // Update smart volume UI
                this.updateSmartUI();
                
                // Update settings values
                document.getElementById('snrValue').textContent = `+${this.snrTarget} dB`;
                document.getElementById('targetPhonValue').textContent = `${this.targetPhon} phon`;
                document.getElementById('referencePhonValue').textContent = `${this.referencePhon} phon`;
                document.getElementById('thresholdValue').textContent = `${this.manualThreshold} dB`;
                document.getElementById('micSensitivityValue').textContent = `${this.micSensitivity.toFixed(1)}x`;
                document.getElementById('quietEnhancementValue').textContent = `${this.quietEnhancement}%`;
                document.getElementById('bassAdaptationValue').textContent = `${this.bassAdaptation} dB`;
                document.getElementById('trebleClarityValue').textContent = `${this.trebleClarity} dB`;
            }
            
            saveSettings() {
                const settings = {
                    smartMode: this.smartMode,
                    targetPhon: this.targetPhon,
                    referencePhon: this.referencePhon,
                    snrTarget: this.snrTarget,
                    manualThreshold: this.manualThreshold,
                    micSensitivity: this.micSensitivity,
                    equalLoudnessEnabled: this.equalLoudnessEnabled,
                    extraBoostEnabled: this.extraBoostEnabled,
                    quietEnhancement: this.quietEnhancement,
                    bassAdaptation: this.bassAdaptation,
                    trebleClarity: this.trebleClarity
                };
                
                localStorage.setItem('smartMusicPlayerSettings', JSON.stringify(settings));
            }
            
            loadSettings() {
                const saved = localStorage.getItem('smartMusicPlayerSettings');
                if (!saved) return;
                
                try {
                    const settings = JSON.parse(saved);
                    
                    // Apply saved settings
                    this.smartMode = settings.smartMode || false;
                    this.targetPhon = settings.targetPhon || 60;
                    this.referencePhon = settings.referencePhon || 80;
                    this.snrTarget = settings.snrTarget || 20;
                    this.manualThreshold = settings.manualThreshold || 45;
                    this.micSensitivity = settings.micSensitivity || 2;
                    this.equalLoudnessEnabled = settings.equalLoudnessEnabled !== false;
                    this.extraBoostEnabled = settings.extraBoostEnabled || false;
                    this.quietEnhancement = settings.quietEnhancement || 100;
                    this.bassAdaptation = settings.bassAdaptation || 8;
                    this.trebleClarity = settings.trebleClarity || 4;
                    
                    // Update UI controls
                    document.getElementById('snrSlider').value = this.snrTarget;
                    document.getElementById('targetPhon').value = this.targetPhon;
                    document.getElementById('referencePhon').value = this.referencePhon;
                    document.getElementById('manualThreshold').value = this.manualThreshold;
                    document.getElementById('micSensitivity').value = this.micSensitivity;
                    document.getElementById('equalLoudnessToggle').checked = this.equalLoudnessEnabled;
                    document.getElementById('extraBoostToggle').checked = this.extraBoostEnabled;
                    document.getElementById('quietEnhancement').value = this.quietEnhancement;
                    document.getElementById('bassAdaptation').value = this.bassAdaptation;
                    document.getElementById('trebleClarity').value = this.trebleClarity;
                    
                } catch (error) {
                    console.error('Error loading settings:', error);
                }
            }
        }
        
        // Initialize player
        const player = new SmartMusicPlayer();
    </script>
</body>
</html>