<!DOCTYPE html>
<!--
Local Music Player with DSP
Copyright (c) 2024

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Technical Acknowledgments:
- FIR Filter Design based on SciPy's firwin2 algorithm
- BS2B Crossfeed inspired by libbs2b (Boris Mikhaylov)
- ISO 226:2003 Equal-Loudness Contours implementation
- Uses music-metadata-browser library (MIT License)
- Developed with Claude Code (Anthropic)
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Local Music Player with DSP</title>
    <!-- Music Metadata Browser for ID3 tag parsing - loaded as ES6 module below -->
    <style>
        :root {
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-dim: #666666;
            --accent-color: #00D4D4;
            --accent-hover: #00E8E8;
            --accent-active: #00B8B8;
            --header-height: 56px;
            --border-color: rgba(255, 255, 255, 0.05);
            --success: #4CAF50;
            --warning: #FFA500;
            --danger: #FF6B6B;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            position: fixed;
            width: 100%;
            padding-top: var(--safe-area-inset-top);
            padding-bottom: var(--safe-area-inset-bottom);
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Ensure SVG icons are always visible */
        button svg {
            pointer-events: none;
        }
        
        /* Fix play/pause button visibility in mini player */
        .mini-player-button svg,
        .mini-player-button svg path {
            fill: #ffffff !important;
        }
        
        .mini-player-button:hover svg,
        .mini-player-button:hover svg path {
            fill: #ffffff !important;
        }
        
        /* Fix play/pause button visibility in full screen player */
        .control-button.primary {
            background: var(--accent-color);
            color: #000000;
        }
        
        .control-button.primary:hover {
            background: #00c5c5;
            color: #000000;
            box-shadow: 0 0 20px rgba(0, 212, 212, 0.5);
        }
        
        .control-button.primary svg,
        .control-button.primary svg path {
            fill: #000000 !important;
        }
        
        .control-button.primary:hover svg,
        .control-button.primary:hover svg path {
            fill: #000000 !important;
        }
        
        .control-button.primary:active {
            background: #009999;
            transform: scale(0.95);
        }
        
        .control-button:not(.primary) svg,
        .control-button:not(.primary) svg path {
            fill: #ffffff !important;
        }
        
        .control-button:not(.primary):hover svg,
        .control-button:not(.primary):hover svg path {
            fill: #ffffff !important;
        }

        /* Main container */
        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            transition: background-color 0.2s;
        }

        /* Header */
        .header {
            position: fixed;
            top: var(--safe-area-inset-top);
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            z-index: 100;
        }

        .header-title {
            flex: 1;
            font-size: 20px;
            font-weight: 600;
            text-align: center;
        }

        .header-button {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 24px;
            padding: 8px;
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .header-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Content area */
        .content {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-top: calc(var(--header-height) + var(--safe-area-inset-top));
            padding-bottom: 120px;
        }

        /* Playlist controls row */
        .playlist-controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }

        .playlist-control-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 8px;
            padding: 8px;
            min-width: 60px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-primary);
            flex: 1;
        }

        .playlist-control-button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }

        .playlist-control-button:active {
            transform: translateY(0);
        }

        .playlist-control-button.active {
            background: var(--accent-color);
            color: #000;
        }

        .control-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .control-text {
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        .icon-button {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            padding: 8px;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .icon-button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .icon-button.active {
            color: var(--accent-color);
        }

        /* Track list */
        .track-list {
            list-style: none;
        }

        .track-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }

        .track-item:hover {
            background: var(--bg-tertiary);
        }

        .track-item.playing {
            background: rgba(0, 212, 212, 0.1);
            border: 1px solid var(--accent-color);
        }

        .track-item.selected {
            background: rgba(0, 212, 212, 0.05);
        }

        .track-handle {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            cursor: move;
            margin-right: 8px;
        }

        .track-handle:hover {
            color: var(--text-secondary);
        }

        .track-number {
            width: 30px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .track-item.playing .track-number {
            color: var(--accent-color);
            font-weight: 600;
        }

        .track-info {
            flex: 1;
            min-width: 0;
            padding: 0 12px;
        }

        .track-title {
            font-size: 16px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-artist {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }
        
        .track-artwork {
            width: 40px;
            height: 40px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            font-size: 16px;
            overflow: hidden;
            margin: 0 8px;
        }
        
        .track-artwork img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .track-duration {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .track-actions {
            display: flex;
            gap: 4px;
            margin-left: 8px;
        }
        
        .track-delete {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s;
            font-size: 16px;
        }
        
        .track-delete:hover {
            background: rgba(255, 107, 107, 0.1);
            color: var(--danger);
        }

        /* Mini player */
        .mini-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 200;
            cursor: pointer;
        }
        
        .mini-player-progress {
            position: relative;
            width: 100%;
            height: 3px;
            background: var(--bg-tertiary);
        }
        
        .mini-progress-bar {
            position: relative;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .mini-progress-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: var(--accent-color);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .mini-player-content {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            padding-bottom: calc(12px + var(--safe-area-inset-bottom));
        }

        .mini-player-artwork {
            width: 48px;
            height: 48px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            font-size: 20px;
            overflow: hidden;
        }

        .mini-player-artwork img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .mini-player-info {
            flex: 1;
            min-width: 0;
        }

        .mini-player-title {
            font-size: 16px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mini-player-artist {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mini-player-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mini-player-button {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 24px;
            padding: 8px;
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .mini-player-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Full screen player */
        .full-player {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            z-index: 300;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            overflow: hidden;
        }
        
        /* Blurred background */
        .full-player-background {
            position: absolute;
            top: -50px;
            left: -50px;
            right: -50px;
            bottom: -50px;
            background-size: cover;
            background-position: center;
            filter: blur(50px) brightness(0.3);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .full-player-background.visible {
            opacity: 1;
        }

        .full-player.show {
            transform: translateY(0);
        }

        .full-player-header {
            padding: var(--safe-area-inset-top) 16px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .full-player-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0 32px 50px;
            align-items: center;
            justify-content: center;
        }

        .full-player-artwork {
            width: 100%;
            max-width: 320px;
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: 16px;
            margin-bottom: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            font-size: 48px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .full-player-artwork img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .full-player-info {
            text-align: center;
            margin-bottom: 32px;
            width: 100%;
        }

        .full-player-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .full-player-artist {
            font-size: 18px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .full-player-progress {
            width: 100%;
            margin-bottom: 32px;
        }

        .progress-bar {
            position: relative;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
            margin: 16px 0;
        }

        .progress-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: var(--accent-color);
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .progress-times {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .full-player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            margin-bottom: 32px;
        }

        .control-button {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            padding: 12px;
            border-radius: 50%;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .control-button.primary {
            width: 64px;
            height: 64px;
            font-size: 32px;
        }

        .control-button:not(.primary) {
            font-size: 24px;
        }

        .control-button.active {
            color: var(--accent-color);
        }

        /* DSP Controls */
        .dsp-controls {
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
            margin: 16px;
        }

        .dsp-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .dsp-title {
            font-size: 18px;
            font-weight: 600;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: .3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--accent-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .slider-container {
            margin: 16px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .slider-value {
            color: var(--accent-color);
            font-weight: 500;
        }
        
        /* Bass reset button */
        .bass-reset-btn {
            margin-left: 10px;
            padding: 2px 8px;
            font-size: 11px;
            background: transparent;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .bass-reset-btn:hover {
            background: var(--accent-color);
            color: var(--bg-primary);
        }
        
        /* Disabled slider style */
        .slider.manual-disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .slider-label.manual-disabled span:first-child {
            color: var(--text-dim);
        }

        .slider {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            border-radius: 2px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid var(--bg-primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid var(--bg-primary);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* Loudness info display */
        .loudness-info {
            margin-top: 8px;
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.4;
        }
        
        .loudness-info span {
            display: inline-block;
        }

        /* Settings modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 400;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .modal.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
        }

        .modal-body {
            padding: 20px;
        }

        .settings-section {
            margin-bottom: 24px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .settings-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
        }

        .settings-label {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        /* DSP Info Display */
        .dsp-info-display {
            margin-top: 16px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .dsp-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .dsp-info-row:last-child {
            margin-bottom: 0;
        }
        
        .dsp-info-display span span {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        #advancedHeadroomDisplay {
            transition: color 0.3s;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: calc(100px + var(--safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 300px;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .toast-success {
            background: #28a745;
        }

        .toast-error {
            background: #dc3545;
        }

        .toast-warning {
            background: #ffc107;
            color: #000;
        }

        .toast-info {
            background: #17a2b8;
        }

        /* Empty states */
        .empty-playlist {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-text {
            font-size: 16px;
            margin-bottom: 8px;
        }
        
        /* Drag and drop styles */
        .container.drag-highlight {
            background-color: rgba(0, 212, 212, 0.1);
            border: 2px dashed var(--accent-color);
        }
        
        .container.drag-highlight::after {
            content: '♪ Drop audio files here';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: var(--accent-color);
            font-weight: 500;
            pointer-events: none;
            z-index: 10;
            background: var(--bg-primary);
            padding: 20px 40px;
            border-radius: 12px;
            border: 2px solid var(--accent-color);
        }

        .empty-subtext {
            font-size: 14px;
            color: var(--text-dim);
        }

        /* Responsive adjustments */
        @media (max-width: 375px) {
            .full-player-title {
                font-size: 20px;
            }
            
            .full-player-artist {
                font-size: 16px;
            }
            
            .control-button.primary {
                width: 56px;
                height: 56px;
                font-size: 28px;
            }
        }

        /* Loading state */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--bg-tertiary);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <button class="header-button" onclick="toggleSettings()">⚙️</button>
            <div class="header-title">Local Music Player</div>
            <button class="header-button" onclick="showAbout()">ℹ️</button>
        </div>

        <!-- Content -->
        <div class="content">

            <!-- DSP Controls -->
            <div class="dsp-controls">
                <div class="dsp-header">
                    <div class="dsp-title">🎛️ Auto Loudness EQ</div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="loudnessToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="slider-container" id="loudnessContainer">
                    <div class="slider-label">
                        <span>Loudness</span>
                        <span class="slider-value" id="loudnessValue">50</span>
                    </div>
                    <input type="range" class="slider" id="loudnessSlider" min="0" max="100" value="50">
                    <div class="loudness-info">
                        <span>Filter: <span id="filterDisplay">--</span></span>
                        <span> • </span>
                        <span>SPL: <span id="splDisplay">--</span></span>
                        <span> • </span>
                        <span>Gain: <span id="gainDisplay">--</span></span>
                        <span> • </span>
                        <span>Headroom: <span id="headroomDisplay">--</span></span>
                    </div>
                </div>
                
                <div class="slider-container hidden" id="dspOffGainContainer">
                    <div class="slider-label">
                        <span>Master Gain</span>
                        <span class="slider-value" id="dspOffGainValue">-40.0 dB</span>
                    </div>
                    <input type="range" class="slider" id="dspOffGainSlider" min="-60" max="0" step="0.1" value="-40">
                    <div class="loudness-info">
                        <span>SPL: <span id="splDisplayOff">--</span></span>
                        <span> • </span>
                        <span>Headroom: <span id="headroomDisplayOff">--</span></span>
                    </div>
                </div>
            </div>

            <!-- Playlist Controls -->
            <div class="dsp-controls" style="margin-top: 16px;">
                <div class="dsp-header">
                    <div class="dsp-title">📄 Playlist</div>
                    <div class="playlist-count" id="playlistCount" style="font-size: 14px; color: var(--text-secondary);">0 tracks</div>
                </div>
                
                <!-- File input controls -->
                <input type="file" id="audioFileInput" accept="audio/*" multiple style="display: none;">
                <input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;">
                <input type="file" id="playlistFileInput" accept=".json" style="display: none;">
                
                <!-- Control buttons row -->
                <div class="playlist-controls-row">
                    <button class="playlist-control-button" onclick="document.getElementById('audioFileInput').click()" title="Add Files">
                        <span class="control-icon">📁</span>
                        <span class="control-text">Add Files</span>
                    </button>
                    <button class="playlist-control-button" onclick="document.getElementById('folderInput').click()" title="Add Folder">
                        <span class="control-icon">📂</span>
                        <span class="control-text">Add Folder</span>
                    </button>
                    <button class="playlist-control-button" onclick="savePlaylist()" title="Save List">
                        <span class="control-icon">💾</span>
                        <span class="control-text">Save List</span>
                    </button>
                    <button class="playlist-control-button" onclick="document.getElementById('playlistFileInput').click()" title="Load List">
                        <span class="control-icon">📤</span>
                        <span class="control-text">Load List</span>
                    </button>
                    <button class="playlist-control-button" onclick="clearPlaylist()" title="Clear">
                        <span class="control-icon">🗑️</span>
                        <span class="control-text">Clear</span>
                    </button>
                    <button class="playlist-control-button" id="shuffleButton" onclick="toggleShuffle()" title="Shuffle">
                        <span class="control-icon">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="16 3 21 3 21 8"></polyline>
                                <line x1="4" y1="20" x2="21" y2="3"></line>
                                <polyline points="21 16 21 21 16 21"></polyline>
                                <line x1="15" y1="15" x2="21" y2="21"></line>
                                <line x1="4" y1="4" x2="9" y2="9"></line>
                            </svg>
                        </span>
                        <span class="control-text">Shuffle</span>
                    </button>
                    <button class="playlist-control-button" id="repeatButton" onclick="toggleRepeat()" title="Repeat">
                        <span class="control-icon">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>
                            </svg>
                        </span>
                        <span class="control-text">Repeat</span>
                    </button>
                </div>

                <!-- Track list -->
                <ul class="track-list" id="trackList">
                    <!-- Tracks will be inserted here -->
                </ul>

                <div class="empty-playlist" id="emptyPlaylist">
                    <div class="empty-icon"><svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg></div>
                    <div class="empty-text">No music added yet</div>
                    <div class="empty-subtext">Add files or folders to get started</div>
                </div>
            </div>
        </div>

        <!-- Mini Player -->
        <div class="mini-player hidden" id="miniPlayer" onclick="showFullPlayer()">
            <div class="mini-player-progress">
                <div class="mini-progress-bar" id="miniProgressBar">
                    <div class="mini-progress-fill" id="miniProgressFill"></div>
                </div>
            </div>
            <div class="mini-player-content">
                <div class="mini-player-artwork" id="miniPlayerArtwork">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
                </div>
                <div class="mini-player-info">
                    <div class="mini-player-title" id="miniPlayerTitle">No track playing</div>
                    <div class="mini-player-artist" id="miniPlayerArtist">--</div>
                </div>
                <div class="mini-player-controls">
                    <button class="mini-player-button" onclick="event.stopPropagation(); skipPrevious()">
                        <svg width="24" height="24" viewBox="0 0 24 24">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                        </svg>
                    </button>
                    <button class="mini-player-button" id="miniPlayPauseButton" onclick="event.stopPropagation(); togglePlayPause()">
                        <svg width="24" height="24" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </button>
                    <button class="mini-player-button" onclick="event.stopPropagation(); skipNext()">
                        <svg width="24" height="24" viewBox="0 0 24 24">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Full Screen Player -->
        <div class="full-player" id="fullPlayer">
            <div class="full-player-background" id="fullPlayerBackground"></div>
            <div class="full-player-header">
                <button class="header-button" onclick="hideFullPlayer()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path d="M19 14L12 21L5 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <div class="header-title">Now Playing</div>
                <button class="header-button" onclick="hideFullPlayer()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path d="M19 14L12 21L5 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            </div>

            <div class="full-player-content">
                <div class="full-player-artwork" id="fullPlayerArtwork">
                    🎵
                </div>

                <div class="full-player-info">
                    <div class="full-player-title" id="fullPlayerTitle">No track playing</div>
                    <div class="full-player-artist" id="fullPlayerArtist">--</div>
                </div>

                <div class="full-player-progress">
                    <div class="progress-bar" id="progressBar" onclick="seekTo(event)">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-times">
                        <span id="currentTime">0:00</span>
                        <span id="totalTime">0:00</span>
                    </div>
                </div>

                <div class="full-player-controls">
                    <button class="control-button" id="fullShuffleButton" onclick="toggleShuffle()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="16 3 21 3 21 8"></polyline>
                            <line x1="4" y1="20" x2="21" y2="3"></line>
                            <polyline points="21 16 21 21 16 21"></polyline>
                            <line x1="15" y1="15" x2="21" y2="21"></line>
                            <line x1="4" y1="4" x2="9" y2="9"></line>
                        </svg>
                    </button>
                    <button class="control-button" onclick="skipPrevious()">
                        <svg width="24" height="24" viewBox="0 0 24 24">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                        </svg>
                    </button>
                    <button class="control-button primary" id="fullPlayPauseButton" onclick="togglePlayPause()">
                        <svg width="32" height="32" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </button>
                    <button class="control-button" onclick="skipNext()">
                        <svg width="24" height="24" viewBox="0 0 24 24">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                        </svg>
                    </button>
                    <button class="control-button" id="fullRepeatButton" onclick="toggleRepeat()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>
                        </svg>
                    </button>
                </div>

                <!-- DSP Controls in Full Player -->
                <div class="slider-container" id="fullPlayerLoudnessContainer">
                    <div class="slider-label">
                        <span>Auto Loudness EQ</span>
                        <span class="slider-value" id="fullPlayerLoudnessValue">50</span>
                    </div>
                    <input type="range" class="slider" id="fullPlayerLoudnessSlider" min="0" max="100" value="50">
                    <div class="loudness-info">
                        <span>Filter: <span id="fullPlayerFilterDisplay">--</span></span>
                        <span> • </span>
                        <span>SPL: <span id="fullPlayerSplDisplay">--</span></span>
                        <span> • </span>
                        <span>Gain: <span id="fullPlayerGainDisplay">--</span></span>
                        <span> • </span>
                        <span>Headroom: <span id="fullPlayerHeadroomDisplay">--</span></span>
                    </div>
                </div>
                
                <div class="slider-container hidden" id="fullPlayerDspOffGainContainer">
                    <div class="slider-label">
                        <span>Master Gain</span>
                        <span class="slider-value" id="fullPlayerDspOffGainValue">-40.0 dB</span>
                    </div>
                    <input type="range" class="slider" id="fullPlayerDspOffGainSlider" min="-60" max="0" step="0.1" value="-40">
                    <div class="loudness-info">
                        <span>SPL: <span id="fullPlayerSplDisplayOff">--</span></span>
                        <span> • </span>
                        <span>Headroom: <span id="fullPlayerHeadroomDisplayOff">--</span></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div class="modal" id="settingsModal">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Settings</div>
                    <button class="header-button" onclick="hideSettings()">✕</button>
                </div>
                <div class="modal-body">
                    <div class="settings-section">
                        <div class="settings-title">DSP Settings</div>
                        <div class="settings-item">
                            <span class="settings-label">Auto Loudness EQ</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="loudnessToggleSettings" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="settings-item" id="easyModeContainer" style="margin-left: 20px;">
                            <span class="settings-label">Easy Mode</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="easyModeToggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="settings-section" id="advancedControls" style="display: none;">
                        <div class="settings-title">Advanced DSP Parameters</div>
                        <!-- Loudness Control in Advanced Mode -->
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Loudness Control</span>
                                <span class="slider-value" id="advancedLoudnessValue">50</span>
                                <button id="bassResetBtn" class="bass-reset-btn" style="display: none;" onclick="resetBassMode()">Reset</button>
                            </div>
                            <input type="range" class="slider" id="advancedLoudnessSlider" min="0" max="100" value="50">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Target Phon</span>
                                <span class="slider-value" id="targetPhonValue">70.0 phon</span>
                            </div>
                            <input type="range" class="slider" id="targetPhonSlider" min="20" max="100" step="0.1" value="70">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Reference Phon</span>
                                <span class="slider-value" id="referencePhonValue">80.0 phon</span>
                            </div>
                            <input type="range" class="slider" id="referencePhonSlider" min="20" max="100" step="0.1" value="80">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Bass Enhancement (K)</span>
                                <span class="slider-value" id="kParameterValue">20.0</span>
                            </div>
                            <input type="range" class="slider" id="kParameterSlider" min="0.1" max="26" step="0.1" value="20">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Max Bass Boost</span>
                                <span class="slider-value" id="deltaMaxValue">20 dB</span>
                            </div>
                            <input type="range" class="slider" id="deltaMaxSlider" min="0" max="80" value="20">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Master Gain</span>
                                <span class="slider-value" id="masterGainValue">-30.0 dB</span>
                            </div>
                            <input type="range" class="slider" id="masterGainSlider" min="-60" max="0" step="0.1" value="-30">
                        </div>
                        <!-- Advanced DSP Info Display -->
                        <div class="dsp-info-display">
                            <div class="dsp-info-row">
                                <span>Filter: <span id="advancedFilterDisplay">--</span></span>
                                <span>SPL: <span id="advancedSplDisplay">-- dB</span></span>
                            </div>
                            <div class="dsp-info-row">
                                <span>Gain: <span id="advancedGainDisplay">-- dB</span></span>
                                <span>Headroom: <span id="advancedHeadroomDisplay">-- dB</span></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <div class="settings-title">Headphone Settings</div>
                        <div class="settings-item">
                            <span class="settings-label">Crossfeed (BS2B)</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="crossfeedToggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="slider-container" id="crossfeedLevelContainer" style="display: none; margin-top: 12px;">
                            <div class="slider-label">
                                <span>Crossfeed Level</span>
                                <span class="slider-value" id="crossfeedLevelValue">Medium</span>
                            </div>
                            <input type="range" class="slider" id="crossfeedLevelSlider" min="1" max="3" value="2" step="1">
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <div class="settings-title">Headphone Correction</div>
                        <div class="settings-item">
                            <span class="settings-label">Enable Correction</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="headphoneEqToggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <label class="file-input-label" for="eqFileInput" style="margin-top: 12px;">
                            📁 Load EQ File (.wav)
                        </label>
                        <input type="file" id="eqFileInput" accept=".wav" style="display: none;">
                        <div class="settings-item" id="eqFileInfo" style="display: none; margin-top: 12px;">
                            <span class="settings-label" id="eqFileName">No EQ loaded</span>
                            <button class="action-button" onclick="clearEQ()" style="padding: 4px 12px; font-size: 12px;">Clear</button>
                        </div>
                    </div>

                    <div class="settings-section">
                        <div class="settings-title">Playback</div>
                        <div class="settings-item">
                            <span class="settings-label">Crossfade</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="crossfadeToggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="slider-container" id="crossfadeDuration" style="display: none;">
                            <div class="slider-label">
                                <span>Crossfade Duration</span>
                                <span class="slider-value" id="crossfadeValue">3s</span>
                            </div>
                            <input type="range" class="slider" id="crossfadeSlider" min="1" max="10" value="3">
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import music-metadata-browser as ES6 module
        import * as musicMetadataBrowser from 'https://cdn.jsdelivr.net/npm/music-metadata-browser@2.5.10/+esm';
        window.musicMetadataBrowser = musicMetadataBrowser;
    </script>
    
    <script>
        // Wait for musicMetadataBrowser to be available
        window.addEventListener('DOMContentLoaded', () => {
            // Check if musicMetadataBrowser is loaded
            const checkLibrary = setInterval(() => {
                if (window.musicMetadataBrowser) {
                    clearInterval(checkLibrary);
                    console.log('Music metadata browser loaded successfully');
                }
            }, 100);
        });
        
        // Local Music Player with DSP - All DSP code preserved from original
        
        // ISO 226:2003 data - PRESERVED EXACTLY AS IS
        const ISO_FREQ = [20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160,
                         200, 250, 315, 400, 500, 630, 800, 1000, 1250, 1600,
                         2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000];

        const ISO_CURVES = {
            20: [74.3,64.4,56.3,49.5,44.7,40.6,37.5,35.0,33.1,31.6,30.2,28.9,27.7,26.6,25.6,
                 24.7,23.8,22.5,21.2,20.3,19.1,18.1,17.2,16.3,15.0,13.4,11.5,10.4,10.1,11.2,13.4],
            30: [86.3,75.3,66.2,58.4,52.7,48.0,44.4,41.3,39.2,37.3,35.7,34.2,32.9,31.7,30.6,
                 29.5,28.4,27.1,25.8,24.7,23.3,22.1,21.0,19.9,18.2,16.1,14.6,13.6,13.3,14.6,17.1],
            40: [96.9,85.4,76.3,68.3,62.1,57.0,52.5,48.7,46.2,44.0,42.1,40.4,38.9,37.5,36.3,
                 35.1,33.9,32.6,31.2,29.9,28.4,27.1,25.9,24.7,22.9,20.7,19.0,17.8,17.3,18.6,21.4],
            50: [107.6,95.6,86.4,78.3,71.1,65.0,60.1,56.1,53.4,51.0,48.9,47.1,45.4,43.8,42.3,
                 40.9,39.4,38.1,36.6,35.1,33.4,32.0,30.6,29.2,27.4,25.1,23.4,22.1,21.6,22.8,25.8],
            60: [118.6,106.1,96.8,88.4,81.3,75.0,69.2,65.1,62.2,59.6,57.3,55.3,53.5,51.7,50.1,
                 48.6,47.0,45.6,44.0,42.3,40.5,38.9,37.3,35.6,33.7,31.3,29.6,28.3,27.9,29.1,32.3],
            70: [129.5,116.9,107.1,98.3,91.2,84.7,78.5,74.2,71.1,68.2,65.7,63.5,61.5,59.6,57.9,
                 56.2,54.5,53.0,51.3,49.5,47.6,45.8,44.1,42.3,40.1,37.7,35.9,34.6,34.3,35.4,38.7],
            80: [139.9,127.3,117.5,108.6,101.4,94.8,88.4,83.9,80.7,77.6,74.9,72.6,70.4,68.3,66.4,
                 64.6,62.8,61.1,59.3,57.4,55.3,53.4,51.4,49.5,47.2,44.8,43.0,41.7,41.2,42.2,45.6],
            90: [150.2,137.5,127.7,118.7,111.4,104.8,98.4,93.8,90.4,87.1,84.2,81.7,79.4,77.1,75.1,
                 73.3,71.4,69.6,67.6,65.6,63.5,61.5,59.5,57.4,55.1,52.7,50.8,49.4,48.8,49.8,53.2],
            100:[160.4,147.6,137.8,128.8,121.4,114.8,108.3,103.7,100.3,96.9,93.9,91.4,88.9,86.6,84.5,
                 82.5,80.5,78.6,76.6,74.5,72.4,70.3,68.3,66.2,63.9,61.4,59.5,58.1,57.5,58.5,62.0]
        };

        // Application state
        const state = {
            // Audio context and nodes - PRESERVED EXACTLY AS IS
            audioContext: null,
            sourceNode: null,
            gainNode: null,
            loudnessConvolver: null,
            eqFilters: [],
            eqPreampNode: null,
            
            // Headphone correction
            headphoneConvolver: null,
            headphoneEqBuffer: null,
            
            // Crossfeed nodes
            crossfeedSplitter: null,
            crossfeedMerger: null,
            crossfeedLowpassL: null,
            crossfeedLowpassR: null,
            crossfeedHighpassL: null,
            crossfeedHighpassR: null,
            crossfeedDelayL: null,
            crossfeedDelayR: null,
            crossfeedGainL: null,
            crossfeedGainR: null,
            
            // Playback state
            isPlaying: false,
            audioLoaded: false,
            audioElement: null,
            currentTrackIndex: -1,
            
            // Crossfade state
            nextAudioElement: null,
            nextSourceNode: null,
            crossfadeTimer: null,
            isCrossfading: false,
            
            // Playlist
            playlist: [],
            
            // Playback modes
            repeatMode: 'off', // 'off', 'all', 'one'
            shuffleEnabled: false,
            crossfadeEnabled: false,
            crossfadeDuration: 3,
            
            // Settings - PRESERVED EXACTLY AS IS
            easyMode: true,
            loudnessEnabled: true,
            headphoneEqEnabled: false,
            headphoneCorrectionMode: 'fir',
            autoPreampEnabled: true,
            crossfeedEnabled: false,
            crossfeedLevel: 2, // 1=Low, 2=Medium, 3=High
            
            // Calibration parameters - PRESERVED EXACTLY AS IS
            calibrationSPL: 80.0,
            desiredSPL: 70.0,
            systemOffset: 0.0,
            isCalibrated: false,
            
            // Loudness parameters - PRESERVED EXACTLY AS IS
            easyLoudness: 50,
            targetPhon: 70.0,
            referencePhon: 80.0,
            kParameter: 20,
            deltaMaxParameter: 20,
            manualBassMode: false,  // Manual K/Delta control mode
            
            // Gain compensation - PRESERVED EXACTLY AS IS
            masterGain: -30.0,
            preampGain: 0.0,
            
            // Interpolated ISO data - PRESERVED EXACTLY AS IS
            fineGrainedISO226: null,
            
            // Filter parameters - PRESERVED EXACTLY AS IS
            filterTaps: 4095,
            deltaMax: 20,
            k: 16
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize ISO data first - PRESERVED EXACTLY AS IS
            state.fineGrainedISO226 = interpISO(ISO_CURVES, 0.1);
            
            // Then initialize UI
            initializeUI();
            
            // Initialize audio on first user interaction
            document.addEventListener('touchstart', initAudioContext, { once: true });
            document.addEventListener('click', initAudioContext, { once: true });
            
            // Load saved playlist
            loadSavedPlaylist();
            
            // Initialize playlist file input
            document.getElementById('playlistFileInput').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                // Warning if current playlist exists
                if (state.playlist.length > 0) {
                    const confirmLoad = confirm(
                        `⚠️ Warning: Loading a playlist will show its contents.\n\n` +
                        `Your current playlist (${state.playlist.length} tracks) will remain unchanged.\n\n` +
                        `You'll need to manually clear the current playlist and add the audio files in the correct order.\n\n` +
                        `Continue?`
                    );
                    
                    if (!confirmLoad) {
                        e.target.value = '';
                        return;
                    }
                }
                
                try {
                    const text = await file.text();
                    const playlistData = JSON.parse(text);
                    
                    if (!playlistData.tracks || !Array.isArray(playlistData.tracks)) {
                        throw new Error('Invalid playlist format');
                    }
                    
                    // Show playlist info in a modal or prompt
                    const trackList = playlistData.tracks.map((track, index) => 
                        `${index + 1}. ${track.title} - ${track.artist}${track.album ? ' (' + track.album + ')' : ''}`
                    ).join('\n');
                    
                    const message = `Loaded playlist: ${playlistData.name || 'Unnamed'}\n` +
                                  `Created: ${new Date(playlistData.created).toLocaleDateString()}\n` +
                                  `Contains ${playlistData.tracks.length} tracks:\n\n${trackList}\n\n` +
                                  `To recreate this playlist:\n` +
                                  `1. Clear your current playlist\n` +
                                  `2. Add the audio files in the order shown above`;
                    
                    // For now, show in alert. In a real app, you'd use a proper modal
                    alert(message);
                    
                    // Store the loaded playlist info for reference
                    state.loadedPlaylistInfo = playlistData;
                    
                    showToast(`Loaded playlist info: ${playlistData.name || 'Unnamed'}`, 'success');
                    
                } catch (error) {
                    console.error('Failed to load playlist:', error);
                    showToast('Failed to load playlist', 'error');
                }
                
                // Reset the input
                e.target.value = '';
            });
        });

        // Initialize UI event listeners
        function initializeUI() {
            // File inputs
            document.getElementById('audioFileInput').addEventListener('change', handleAudioFileLoad);
            document.getElementById('folderInput').addEventListener('change', handleFolderLoad);
            
            // DSP Controls
            document.getElementById('loudnessToggle').addEventListener('change', (e) => {
                state.loudnessEnabled = e.target.checked;
                
                // Sync with Settings
                document.getElementById('loudnessToggleSettings').checked = e.target.checked;
                document.getElementById('easyModeContainer').style.display = state.loudnessEnabled ? 'flex' : 'none';
                
                // When turning off Auto Loudness EQ, also turn off Easy Mode
                if (!state.loudnessEnabled) {
                    state.easyMode = false;
                    document.getElementById('easyModeToggle').checked = false;
                    state.masterGain = -40.0;
                    // Update DSP off gain slider
                    document.getElementById('dspOffGainSlider').value = state.masterGain;
                    document.getElementById('dspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                    document.getElementById('fullPlayerDspOffGainSlider').value = state.masterGain;
                    document.getElementById('fullPlayerDspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                    updateMasterGain();
                    updateOffModeDisplay();
                } else {
                    // When turning on Loudness EQ, restore automatic gain calculation
                    updateLoudnessFromEasy();
                }
                
                updateAudioGraph();
                updateDSPControlsVisibility();
                updateUIMode();
            });
            
            document.getElementById('loudnessSlider').addEventListener('input', (e) => {
                state.easyLoudness = parseInt(e.target.value);
                document.getElementById('loudnessValue').textContent = state.easyLoudness;
                updateLoudnessFromEasy();
                updateLoudnessDisplay();
                // Sync with full player slider
                const fullPlayerSlider = document.getElementById('fullPlayerLoudnessSlider');
                if (fullPlayerSlider) {
                    fullPlayerSlider.value = state.easyLoudness;
                    document.getElementById('fullPlayerLoudnessValue').textContent = state.easyLoudness;
                }
                // Sync with advanced slider
                const advancedSlider = document.getElementById('advancedLoudnessSlider');
                if (advancedSlider) {
                    advancedSlider.value = state.easyLoudness;
                    document.getElementById('advancedLoudnessValue').textContent = state.easyLoudness;
                }
            });
            
            // Full player loudness slider
            const fullPlayerLoudnessSlider = document.getElementById('fullPlayerLoudnessSlider');
            if (fullPlayerLoudnessSlider) {
                fullPlayerLoudnessSlider.addEventListener('input', (e) => {
                    state.easyLoudness = parseInt(e.target.value);
                    document.getElementById('fullPlayerLoudnessValue').textContent = state.easyLoudness;
                    updateLoudnessFromEasy();
                    updateLoudnessDisplay();
                    // Sync with main slider
                    document.getElementById('loudnessSlider').value = state.easyLoudness;
                    document.getElementById('loudnessValue').textContent = state.easyLoudness;
                    // Sync with advanced slider
                    const advancedSlider = document.getElementById('advancedLoudnessSlider');
                    if (advancedSlider) {
                        advancedSlider.value = state.easyLoudness;
                        document.getElementById('advancedLoudnessValue').textContent = state.easyLoudness;
                    }
                });
            }
            
            // DSP Off Master Gain sliders
            document.getElementById('dspOffGainSlider').addEventListener('input', (e) => {
                state.masterGain = parseFloat(e.target.value);
                document.getElementById('dspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                updateMasterGain();
                // Sync with full player
                document.getElementById('fullPlayerDspOffGainSlider').value = state.masterGain;
                document.getElementById('fullPlayerDspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                // Sync with settings
                document.getElementById('masterGainSlider').value = state.masterGain;
                document.getElementById('masterGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                // Update display
                updateOffModeDisplay();
            });
            
            document.getElementById('fullPlayerDspOffGainSlider').addEventListener('input', (e) => {
                state.masterGain = parseFloat(e.target.value);
                document.getElementById('fullPlayerDspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                updateMasterGain();
                // Sync with main controls
                document.getElementById('dspOffGainSlider').value = state.masterGain;
                document.getElementById('dspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                // Sync with settings
                document.getElementById('masterGainSlider').value = state.masterGain;
                document.getElementById('masterGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                // Update display
                updateOffModeDisplay();
            });
            
            // Settings
            document.getElementById('loudnessToggleSettings').addEventListener('change', (e) => {
                state.loudnessEnabled = e.target.checked;
                document.getElementById('loudnessToggle').checked = e.target.checked;
                
                // Show/hide Easy Mode option
                document.getElementById('easyModeContainer').style.display = state.loudnessEnabled ? 'flex' : 'none';
                
                // If disabling loudness, also turn off Easy Mode and set master gain
                if (!state.loudnessEnabled) {
                    state.easyMode = false;
                    document.getElementById('easyModeToggle').checked = false;
                    state.masterGain = -40.0;
                    updateMasterGain();
                    updateOffModeDisplay();
                }
                
                updateAudioGraph();
                updateDSPControlsVisibility();
                updateUIMode();
            });
            
            document.getElementById('easyModeToggle').addEventListener('change', (e) => {
                state.easyMode = e.target.checked;
                updateUIMode();
            });
            
            document.getElementById('headphoneEqToggle').addEventListener('change', (e) => {
                state.headphoneEqEnabled = e.target.checked;
                updateAudioGraph();
            });
            
            document.getElementById('crossfadeToggle').addEventListener('change', (e) => {
                state.crossfadeEnabled = e.target.checked;
                document.getElementById('crossfadeDuration').style.display = state.crossfadeEnabled ? 'block' : 'none';
                
                if (state.crossfadeEnabled && state.isPlaying && state.audioElement) {
                    // Setup crossfade timer if enabling during playback
                    setupCrossfadeTimer();
                } else if (!state.crossfadeEnabled) {
                    // Cancel any pending crossfade if disabling
                    cancelCrossfade();
                }
            });
            
            document.getElementById('crossfadeSlider').addEventListener('input', (e) => {
                state.crossfadeDuration = parseInt(e.target.value);
                document.getElementById('crossfadeValue').textContent = state.crossfadeDuration + 's';
            });
            
            // Crossfeed controls
            document.getElementById('crossfeedToggle').addEventListener('change', (e) => {
                state.crossfeedEnabled = e.target.checked;
                document.getElementById('crossfeedLevelContainer').style.display = state.crossfeedEnabled ? 'block' : 'none';
                updateAudioGraph();
            });
            
            document.getElementById('crossfeedLevelSlider').addEventListener('input', (e) => {
                state.crossfeedLevel = parseInt(e.target.value);
                const levels = ['Low', 'Medium', 'High'];
                document.getElementById('crossfeedLevelValue').textContent = levels[state.crossfeedLevel - 1];
                if (state.crossfeedEnabled) {
                    updateCrossfeedParameters();
                }
            });
            
            // Advanced controls
            
            // Advanced Loudness slider
            document.getElementById('advancedLoudnessSlider').addEventListener('input', (e) => {
                const loudnessValue = parseInt(e.target.value);
                state.easyLoudness = loudnessValue;
                document.getElementById('advancedLoudnessValue').textContent = loudnessValue;
                
                // Update main loudness slider
                document.getElementById('loudnessSlider').value = loudnessValue;
                document.getElementById('loudnessValue').textContent = loudnessValue;
                
                // Update full player loudness slider
                const fullPlayerSlider = document.getElementById('fullPlayerLoudnessSlider');
                if (fullPlayerSlider) {
                    fullPlayerSlider.value = loudnessValue;
                    document.getElementById('fullPlayerLoudnessValue').textContent = loudnessValue;
                }
                
                // Don't reset manual bass mode - just update with current K/Delta values
                
                // Update all parameters based on loudness value
                updateLoudnessFromEasy();
                updateLoudnessDisplay();
            });
            
            document.getElementById('targetPhonSlider').addEventListener('input', (e) => {
                state.targetPhon = parseFloat(e.target.value);
                document.getElementById('targetPhonValue').textContent = state.targetPhon.toFixed(1) + ' phon';
                updateLoudnessFilter();
                updateLoudnessDisplay();
            });
            
            document.getElementById('referencePhonSlider').addEventListener('input', (e) => {
                state.referencePhon = parseFloat(e.target.value);
                document.getElementById('referencePhonValue').textContent = state.referencePhon.toFixed(1) + ' phon';
                updateLoudnessFilter();
                updateLoudnessDisplay();
            });
            
            document.getElementById('kParameterSlider').addEventListener('input', (e) => {
                state.kParameter = parseFloat(e.target.value);
                document.getElementById('kParameterValue').textContent = state.kParameter.toFixed(1);
                
                // Enter manual bass mode
                if (!state.manualBassMode) {
                    enterManualBassMode();
                }
                
                // Update filter but don't auto-calculate K/Delta
                updateLoudnessFilter();
                updateLoudnessDisplay();
            });
            
            document.getElementById('deltaMaxSlider').addEventListener('input', (e) => {
                state.deltaMaxParameter = parseFloat(e.target.value);
                document.getElementById('deltaMaxValue').textContent = state.deltaMaxParameter.toFixed(0) + ' dB';
                
                // Enter manual bass mode
                if (!state.manualBassMode) {
                    enterManualBassMode();
                }
                
                // Update filter but don't auto-calculate K/Delta
                updateLoudnessFilter();
                updateLoudnessDisplay();
            });
            
            document.getElementById('masterGainSlider').addEventListener('input', (e) => {
                state.masterGain = parseFloat(e.target.value);
                document.getElementById('masterGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                updateMasterGain();
                
                // Sync with main controls
                document.getElementById('dspOffGainSlider').value = state.masterGain;
                document.getElementById('dspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                document.getElementById('fullPlayerDspOffGainSlider').value = state.masterGain;
                document.getElementById('fullPlayerDspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                
                // Update SPL and headroom display
                updateOffModeDisplay();
                
                // Also update loudness display for advanced DSP info
                if (state.loudnessEnabled) {
                    updateLoudnessDisplay();
                }
            });
            
            // Headphone EQ file input
            document.getElementById('eqFileInput').addEventListener('change', handleEqFileLoad);
            
            // Progress bar
            document.getElementById('progressBar').addEventListener('click', seekTo);
            
            // Set initial UI state
            updateUIMode();
            updatePlaylistDisplay();
            updateDSPControlsVisibility();
            
            // Initialize loudness from easy mode
            updateLoudnessFromEasy();
            updateLoudnessDisplay();
            
            // Initialize button states
            updateShuffleButtons();
            updateRepeatButtons();
            
            // Initialize drag and drop for playlist
            initializeDragAndDrop();
            
            // Initialize keyboard shortcuts
            initializeKeyboardShortcuts();
            
            // Initialize mouse wheel support for sliders
            initializeSliderWheel();
        }
        
        // Initialize keyboard shortcuts (YouTube-style)
        function initializeKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                switch(e.key.toLowerCase()) {
                    case ' ':  // Spacebar - Play/Pause
                        e.preventDefault();
                        togglePlayPause();
                        break;
                        
                    case 'k':  // Play/Pause (YouTube style)
                        e.preventDefault();
                        togglePlayPause();
                        break;
                        
                    case 'j':  // Seek backward 10s
                        e.preventDefault();
                        seekRelative(-10);
                        break;
                        
                    case 'l':  // Seek forward 10s
                        e.preventDefault();
                        seekRelative(10);
                        break;
                        
                    case 'arrowleft':  // Seek backward 5s
                        e.preventDefault();
                        seekRelative(-5);
                        break;
                        
                    case 'arrowright':  // Seek forward 5s
                        e.preventDefault();
                        seekRelative(5);
                        break;
                        
                    case 'arrowup':  // Volume up
                        e.preventDefault();
                        adjustMasterGainRelative(1);
                        break;
                        
                    case 'arrowdown':  // Volume down
                        e.preventDefault();
                        adjustMasterGainRelative(-1);
                        break;
                        
                    case 'm':  // Mute/Unmute
                        e.preventDefault();
                        toggleMute();
                        break;
                        
                    case 'f':  // Fullscreen player
                        e.preventDefault();
                        showFullPlayer();
                        break;
                        
                    case 'escape':  // Exit fullscreen
                        hideFullPlayer();
                        hideSettings();
                        break;
                        
                    case ',':  // Slow down playback (with shift)
                        if (e.shiftKey) {
                            e.preventDefault();
                            adjustPlaybackRate(-0.25);
                        }
                        break;
                        
                    case '.':  // Speed up playback (with shift)
                        if (e.shiftKey) {
                            e.preventDefault();
                            adjustPlaybackRate(0.25);
                        }
                        break;
                        
                    case 'n':  // Next track (with shift)
                        if (e.shiftKey) {
                            e.preventDefault();
                            nextTrack();
                        }
                        break;
                        
                    case 'p':  // Previous track (with shift)
                        if (e.shiftKey) {
                            e.preventDefault();
                            previousTrack();
                        }
                        break;
                        
                    case '0':  // Jump to beginning
                    case 'home':
                        e.preventDefault();
                        seekToPosition(0);
                        break;
                        
                    case 'end':  // Jump to end
                        e.preventDefault();
                        seekToPosition(1);
                        break;
                        
                    // Number keys 1-9 for seeking (10%-90%)
                    case '1': case '2': case '3': case '4': case '5': 
                    case '6': case '7': case '8': case '9':
                        e.preventDefault();
                        seekToPosition(parseInt(e.key) * 0.1);
                        break;
                }
            });
        }
        
        // Initialize mouse wheel support for sliders
        function initializeSliderWheel() {
            const sliders = document.querySelectorAll('input[type="range"]');
            
            sliders.forEach(slider => {
                slider.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const step = parseFloat(slider.step) || 1;
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const currentValue = parseFloat(slider.value);
                    
                    // Determine scroll direction and amount
                    const delta = e.deltaY < 0 ? step : -step;
                    const multiplier = e.shiftKey ? 10 : (e.ctrlKey || e.metaKey) ? 0.1 : 1;
                    
                    // Calculate new value
                    let newValue = currentValue + (delta * multiplier);
                    newValue = Math.max(min, Math.min(max, newValue));
                    
                    // Update slider
                    slider.value = newValue;
                    
                    // Trigger input event to update the app state
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                });
            });
        }
        
        // Helper functions for keyboard shortcuts
        function seekRelative(seconds) {
            if (!state.audioElement || !state.audioElement.duration) return;
            const newTime = state.audioElement.currentTime + seconds;
            state.audioElement.currentTime = Math.max(0, Math.min(state.audioElement.duration, newTime));
        }
        
        function seekToPosition(fraction) {
            if (!state.audioElement || !state.audioElement.duration) return;
            state.audioElement.currentTime = state.audioElement.duration * fraction;
        }
        
        function adjustMasterGainRelative(delta) {
            const newGain = Math.max(-60, Math.min(0, state.masterGain + delta));
            state.masterGain = newGain;
            
            // Update all master gain sliders
            document.getElementById('masterGainSlider').value = newGain;
            document.getElementById('masterGainValue').textContent = newGain.toFixed(1) + ' dB';
            document.getElementById('dspOffGainSlider').value = newGain;
            document.getElementById('dspOffGainValue').textContent = newGain.toFixed(1) + ' dB';
            document.getElementById('fullPlayerDspOffGainSlider').value = newGain;
            document.getElementById('fullPlayerDspOffGainValue').textContent = newGain.toFixed(1) + ' dB';
            
            updateMasterGain();
            updateOffModeDisplay();
            if (state.loudnessEnabled) {
                updateLoudnessDisplay();
            }
        }
        
        function toggleMute() {
            if (state.audioElement) {
                state.audioElement.muted = !state.audioElement.muted;
                // Visual feedback could be added here
            }
        }
        
        function adjustPlaybackRate(delta) {
            if (!state.audioElement) return;
            const newRate = Math.max(0.25, Math.min(2, state.audioElement.playbackRate + delta));
            state.audioElement.playbackRate = newRate;
            showToast(`Playback speed: ${newRate}x`, 'info');
        }

        // Initialize audio context - PRESERVED EXACTLY AS IS FROM ORIGINAL
        async function initAudioContext() {
            if (state.audioContext) return;
            
            try {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create audio nodes
                state.gainNode = state.audioContext.createGain();
                updateMasterGain(); // Apply master gain setting
                
                // Create loudness convolver
                state.loudnessConvolver = state.audioContext.createConvolver();
                // CRITICAL: Disable automatic normalization to prevent ~30dB volume loss
                state.loudnessConvolver.normalize = false;
                
                // Create crossfeed nodes
                initializeCrossfeed();
                
                // Initial audio graph setup
                updateAudioGraph();
                
                // Create initial loudness filter if in easy mode
                if (state.easyMode && state.fineGrainedISO226) {
                    await updateLoudnessFilter();
                }
                
                showToast('Audio system initialized', 'success');
            } catch (error) {
                console.error('Failed to initialize audio:', error);
                showToast('Failed to initialize audio system', 'error');
            }
        }

        // Initialize drag and drop functionality
        function initializeDragAndDrop() {
            const trackList = document.getElementById('trackList');
            const mainContent = document.querySelector('.container');
            
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                mainContent.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Highlight drop area when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                mainContent.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                mainContent.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight(e) {
                mainContent.classList.add('drag-highlight');
            }
            
            function unhighlight(e) {
                mainContent.classList.remove('drag-highlight');
            }
            
            // Handle dropped files
            mainContent.addEventListener('drop', handleDrop, false);
            
            async function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                console.log('Files dropped:', files.length);
                
                if (files.length > 0) {
                    try {
                        await handleDroppedFiles(files);
                    } catch (error) {
                        console.error('Error handling dropped files:', error);
                        showToast('Error processing files', 'error');
                    }
                }
            }
        }
        
        // Handle dropped files
        async function handleDroppedFiles(files) {
            const fileArray = Array.from(files);
            console.log('Processing dropped files:', fileArray);
            
            // Filter for supported audio formats
            const supportedTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/x-wav', 
                                  'audio/flac', 'audio/x-flac', 'audio/ogg', 'audio/webm', 'audio/aac', 
                                  'audio/mp4', 'audio/x-m4a', 'audio/opus'];
            const audioFiles = fileArray.filter(file => {
                // Check by MIME type
                if (supportedTypes.includes(file.type)) return true;
                // Check by extension if MIME type is generic or missing
                const ext = file.name.toLowerCase().split('.').pop();
                const supportedExts = ['mp3', 'wav', 'flac', 'ogg', 'webm', 'aac', 'm4a', 'opus', 'mp4'];
                return supportedExts.includes(ext);
            });
            
            if (audioFiles.length === 0) {
                showToast('No audio files found', 'warning');
                return;
            }
            
            // Add files to playlist
            for (const file of audioFiles) {
                const track = {
                    id: Date.now() + Math.random(),
                    file: file,
                    title: file.name.replace(/\.[^/.]+$/, ''),
                    artist: 'Unknown Artist',
                    duration: 0,
                    url: URL.createObjectURL(file)
                };
                
                // Try to parse metadata
                try {
                    const metadata = await musicMetadataBrowser.parseBlob(file);
                    if (metadata.common) {
                        track.title = metadata.common.title || track.title;
                        track.artist = metadata.common.artist || track.artist;
                        track.album = metadata.common.album;
                        track.duration = metadata.format.duration || 0;
                        if (metadata.common.picture && metadata.common.picture.length > 0) {
                            const picture = metadata.common.picture[0];
                            const blob = new Blob([picture.data], { type: picture.format });
                            track.artwork = URL.createObjectURL(blob);
                        }
                    }
                } catch (error) {
                    console.warn('Error parsing metadata:', error);
                }
                
                state.playlist.push(track);
            }
            
            updatePlaylistDisplay();
            showToast(`Added ${audioFiles.length} track${audioFiles.length > 1 ? 's' : ''}`, 'success');
        }

        // Handle audio file selection
        async function handleAudioFileLoad(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            // Filter for supported audio formats
            const supportedTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/x-wav', 
                                  'audio/flac', 'audio/x-flac', 'audio/ogg', 'audio/webm', 'audio/aac', 
                                  'audio/mp4', 'audio/x-m4a', 'audio/opus'];
            const audioFiles = files.filter(file => {
                // Check by MIME type
                if (supportedTypes.includes(file.type)) return true;
                // Check by extension if MIME type is generic or missing
                const ext = file.name.toLowerCase().split('.').pop();
                const supportedExts = ['mp3', 'wav', 'flac', 'ogg', 'webm', 'aac', 'm4a', 'opus', 'mp4'];
                return supportedExts.includes(ext);
            });
            if (audioFiles.length === 0) {
                showToast('No audio files selected', 'warning');
                return;
            }
            
            // Add files to playlist
            for (const file of audioFiles) {
                const track = {
                    id: Date.now() + Math.random(),
                    file: file,
                    title: file.name.replace(/\.[^/.]+$/, ''),
                    artist: 'Unknown Artist',
                    duration: 0,
                    url: URL.createObjectURL(file)
                };
                
                // Try to get metadata
                await getAudioMetadata(track);
                
                state.playlist.push(track);
            }
            
            updatePlaylistDisplay();
            savePlaylistToStorage();
            
            showToast(`Added ${audioFiles.length} track${audioFiles.length > 1 ? 's' : ''}`, 'success');
        }

        // Handle folder selection
        async function handleFolderLoad(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            // Filter for supported audio formats
            const supportedTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/x-wav', 
                                  'audio/flac', 'audio/x-flac', 'audio/ogg', 'audio/webm', 'audio/aac', 
                                  'audio/mp4', 'audio/x-m4a', 'audio/opus'];
            const audioFiles = files.filter(file => {
                // Check by MIME type
                if (supportedTypes.includes(file.type)) return true;
                // Check by extension if MIME type is generic or missing
                const ext = file.name.toLowerCase().split('.').pop();
                const supportedExts = ['mp3', 'wav', 'flac', 'ogg', 'webm', 'aac', 'm4a', 'opus', 'mp4'];
                return supportedExts.includes(ext);
            });
            if (audioFiles.length === 0) {
                showToast('No audio files found in folder', 'warning');
                return;
            }
            
            // Sort files by name
            audioFiles.sort((a, b) => a.name.localeCompare(b.name));
            
            // Add files to playlist
            for (const file of audioFiles) {
                const track = {
                    id: Date.now() + Math.random(),
                    file: file,
                    title: file.name.replace(/\.[^/.]+$/, ''),
                    artist: 'Unknown Artist',
                    duration: 0,
                    url: URL.createObjectURL(file)
                };
                
                // Try to get metadata
                await getAudioMetadata(track);
                
                state.playlist.push(track);
            }
            
            updatePlaylistDisplay();
            savePlaylistToStorage();
            
            showToast(`Added ${audioFiles.length} track${audioFiles.length > 1 ? 's' : ''} from folder`, 'success');
        }

        // Get audio metadata and album art
        async function getAudioMetadata(track) {
            try {
                // Parse metadata using music-metadata-browser
                const metadata = await window.musicMetadataBrowser.parseBlob(track.file);
                
                // Extract basic metadata
                if (metadata.common) {
                    track.title = metadata.common.title || track.title;
                    track.artist = metadata.common.artist || 'Unknown Artist';
                    track.album = metadata.common.album || 'Unknown Album';
                    track.year = metadata.common.year || null;
                    track.genre = metadata.common.genre ? metadata.common.genre[0] : null;
                }
                
                // Extract duration
                if (metadata.format && metadata.format.duration) {
                    track.duration = metadata.format.duration;
                }
                
                // Extract album art
                if (metadata.common.picture && metadata.common.picture.length > 0) {
                    const picture = metadata.common.picture[0];
                    const blob = new Blob([picture.data], { type: picture.format });
                    track.albumArtUrl = URL.createObjectURL(blob);
                    track.hasAlbumArt = true;
                } else {
                    track.hasAlbumArt = false;
                }
                
                // Fallback to get duration from audio element if not in metadata
                if (!track.duration) {
                    const audio = new Audio(track.url);
                    await new Promise((resolve) => {
                        audio.addEventListener('loadedmetadata', () => {
                            track.duration = audio.duration;
                            resolve();
                        });
                    });
                }
            } catch (error) {
                console.error('Failed to get metadata:', error);
                
                // Fallback: just get duration
                try {
                    const audio = new Audio(track.url);
                    await new Promise((resolve) => {
                        audio.addEventListener('loadedmetadata', () => {
                            track.duration = audio.duration;
                            resolve();
                        });
                    });
                } catch (e) {
                    console.error('Failed to get duration:', e);
                }
            }
        }

        // Play a specific track
        async function playTrack(index) {
            if (index < 0 || index >= state.playlist.length) return;
            
            // Initialize audio context if needed
            await initAudioContext();
            
            const track = state.playlist[index];
            state.currentTrackIndex = index;
            
            // Cancel any ongoing crossfade
            cancelCrossfade();
            
            // Stop current playback
            if (state.audioElement) {
                state.audioElement.pause();
                if (state.sourceNode) {
                    state.sourceNode.disconnect();
                }
            }
            
            try {
                // Create new audio element
                state.audioElement = new Audio(track.url);
                state.audioElement.crossOrigin = 'anonymous';
                
                // Create media element source
                state.sourceNode = state.audioContext.createMediaElementSource(state.audioElement);
                
                // Reconnect audio graph
                updateAudioGraph();
                
                // Update UI
                updateNowPlaying(track);
                updatePlaylistDisplay();
                
                // Set up event listeners
                state.audioElement.addEventListener('ended', handleTrackEnded);
                state.audioElement.addEventListener('timeupdate', updateProgress);
                state.audioElement.addEventListener('loadedmetadata', () => {
                    document.getElementById('totalTime').textContent = formatTime(state.audioElement.duration);
                    // Setup crossfade timer when metadata is loaded
                    if (state.crossfadeEnabled) {
                        setupCrossfadeTimer();
                    }
                });
                
                // Start playback
                await state.audioElement.play();
                state.isPlaying = true;
                updatePlayPauseButtons();
                
                // Show mini player
                document.getElementById('miniPlayer').classList.remove('hidden');
                
            } catch (error) {
                console.error('Failed to play track:', error);
                showToast('Failed to play track', 'error');
            }
        }

        // Handle track ended
        function handleTrackEnded() {
            if (state.repeatMode === 'one') {
                // Repeat current track
                state.audioElement.currentTime = 0;
                state.audioElement.play();
            } else if (state.crossfadeEnabled && state.playlist.length > 1) {
                // Start crossfade before track ends
                // This function is called when track actually ends, 
                // but we should start crossfade earlier. See setupCrossfadeTimer()
                skipNext();
            } else {
                // Play next track normally
                skipNext();
            }
        }
        
        // Setup crossfade timer to start before track ends
        function setupCrossfadeTimer() {
            if (!state.audioElement || !state.crossfadeEnabled || state.playlist.length <= 1) return;
            
            // Clear existing timer
            if (state.crossfadeTimer) {
                clearTimeout(state.crossfadeTimer);
            }
            
            // Calculate when to start crossfade
            const currentDuration = state.audioElement.duration;
            if (isNaN(currentDuration)) return;
            
            const timeUntilCrossfade = (currentDuration - state.crossfadeDuration - state.audioElement.currentTime) * 1000;
            
            if (timeUntilCrossfade > 0) {
                state.crossfadeTimer = setTimeout(() => {
                    // Determine next track index
                    let nextIndex = getNextTrackIndex();
                    if (nextIndex !== -1) {
                        startCrossfade(nextIndex);
                    }
                }, timeUntilCrossfade);
            }
        }
        
        // Get next track index based on current playback mode
        function getNextTrackIndex() {
            if (state.playlist.length === 0) return -1;
            
            let nextIndex;
            
            if (state.repeatMode === 'one') {
                return state.currentTrackIndex; // Same track
            }
            
            if (state.shuffleEnabled && state.playlist.length > 1) {
                // In shuffle mode, pick a random track (but not the current one)
                const availableIndices = [];
                for (let i = 0; i < state.playlist.length; i++) {
                    if (i !== state.currentTrackIndex) {
                        availableIndices.push(i);
                    }
                }
                
                if (availableIndices.length > 0) {
                    nextIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                } else {
                    nextIndex = 0;
                }
            } else {
                // Normal sequential playback
                nextIndex = state.currentTrackIndex + 1;
                
                if (nextIndex >= state.playlist.length) {
                    if (state.repeatMode === 'all') {
                        nextIndex = 0;
                    } else {
                        return -1; // No next track
                    }
                }
            }
            
            return nextIndex;
        }

        // Start crossfade to next track
        async function startCrossfade(nextIndex) {
            if (state.isCrossfading || !state.audioElement || nextIndex < 0 || nextIndex >= state.playlist.length) return;
            
            state.isCrossfading = true;
            const track = state.playlist[nextIndex];
            
            try {
                // Create next audio element
                state.nextAudioElement = new Audio(track.url);
                state.nextAudioElement.crossOrigin = 'anonymous';
                state.nextAudioElement.volume = 0; // Start at 0 volume
                
                // Create media element source for next track
                state.nextSourceNode = state.audioContext.createMediaElementSource(state.nextAudioElement);
                
                // Connect next source to audio graph
                connectSourceToGraph(state.nextSourceNode);
                
                // Preload and prepare next track
                await state.nextAudioElement.play();
                
                // Perform crossfade
                const fadeSteps = 50;
                const fadeInterval = (state.crossfadeDuration * 1000) / fadeSteps;
                let step = 0;
                
                const crossfadeInterval = setInterval(() => {
                    step++;
                    const progress = step / fadeSteps;
                    
                    // Fade out current track
                    if (state.audioElement) {
                        state.audioElement.volume = 1 - progress;
                    }
                    
                    // Fade in next track
                    if (state.nextAudioElement) {
                        state.nextAudioElement.volume = progress;
                    }
                    
                    if (step >= fadeSteps) {
                        clearInterval(crossfadeInterval);
                        finishCrossfade(nextIndex);
                    }
                }, fadeInterval);
                
            } catch (error) {
                console.error('Failed to start crossfade:', error);
                state.isCrossfading = false;
                // Fallback to normal track change
                playTrack(nextIndex);
            }
        }
        
        // Finish crossfade and cleanup
        function finishCrossfade(nextIndex) {
            // Stop and cleanup current track
            if (state.audioElement) {
                state.audioElement.pause();
                if (state.sourceNode) {
                    state.sourceNode.disconnect();
                }
            }
            
            // Switch to next track
            state.audioElement = state.nextAudioElement;
            state.sourceNode = state.nextSourceNode;
            state.currentTrackIndex = nextIndex;
            state.nextAudioElement = null;
            state.nextSourceNode = null;
            state.isCrossfading = false;
            
            // Update UI
            const track = state.playlist[nextIndex];
            updateNowPlaying(track);
            updatePlaylistDisplay();
            
            // Setup event listeners
            state.audioElement.addEventListener('ended', handleTrackEnded);
            state.audioElement.addEventListener('timeupdate', updateProgress);
            state.audioElement.addEventListener('loadedmetadata', () => {
                document.getElementById('totalTime').textContent = formatTime(state.audioElement.duration);
            });
        }
        
        // Connect source node to audio graph (helper function)
        function connectSourceToGraph(sourceNode) {
            let currentNode = sourceNode;
            
            // Apply loudness compensation if enabled
            if (state.loudnessEnabled) {
                currentNode.connect(state.loudnessConvolver);
                currentNode = state.loudnessConvolver;
            }
            
            // Apply crossfeed if enabled
            if (state.crossfeedEnabled && state.crossfeedSplitter) {
                currentNode.connect(state.crossfeedSplitter);
                // ... crossfeed connections ...
                currentNode = state.crossfeedMerger;
            }
            
            // Apply headphone EQ if enabled
            if (state.headphoneEqEnabled && state.headphoneConvolver && state.headphoneEqBuffer) {
                currentNode.connect(state.headphoneConvolver);
                currentNode = state.headphoneConvolver;
            }
            
            // Connect to gain node
            currentNode.connect(state.gainNode);
        }
        
        // Cancel any ongoing crossfade
        function cancelCrossfade() {
            // Clear crossfade timer
            if (state.crossfadeTimer) {
                clearTimeout(state.crossfadeTimer);
                state.crossfadeTimer = null;
            }
            
            // Stop and cleanup next track if crossfading
            if (state.isCrossfading && state.nextAudioElement) {
                state.nextAudioElement.pause();
                if (state.nextSourceNode) {
                    state.nextSourceNode.disconnect();
                }
                state.nextAudioElement = null;
                state.nextSourceNode = null;
                state.isCrossfading = false;
            }
            
            // Reset current track volume
            if (state.audioElement) {
                state.audioElement.volume = 1;
            }
        }

        // Toggle play/pause
        function togglePlayPause() {
            if (!state.audioElement) return;
            
            if (state.isPlaying) {
                state.audioElement.pause();
                state.isPlaying = false;
            } else {
                state.audioElement.play();
                state.isPlaying = true;
            }
            
            updatePlayPauseButtons();
        }

        // Skip to next track
        function skipNext() {
            if (state.playlist.length === 0) return;
            
            let nextIndex;
            
            if (state.shuffleEnabled && state.playlist.length > 1) {
                // In shuffle mode, pick a random track (but not the current one)
                const availableIndices = [];
                for (let i = 0; i < state.playlist.length; i++) {
                    if (i !== state.currentTrackIndex) {
                        availableIndices.push(i);
                    }
                }
                
                if (availableIndices.length > 0) {
                    nextIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                } else {
                    // Only one track in playlist
                    nextIndex = 0;
                }
            } else {
                // Normal sequential playback
                nextIndex = state.currentTrackIndex + 1;
                
                if (nextIndex >= state.playlist.length) {
                    if (state.repeatMode === 'all') {
                        nextIndex = 0;
                    } else {
                        // Stop playback
                        state.isPlaying = false;
                        updatePlayPauseButtons();
                        return;
                    }
                }
            }
            
            playTrack(nextIndex);
        }

        // Skip to previous track
        function skipPrevious() {
            if (state.playlist.length === 0) return;
            
            // If more than 3 seconds into the track, restart it
            if (state.audioElement && state.audioElement.currentTime > 3) {
                state.audioElement.currentTime = 0;
                return;
            }
            
            if (state.shuffleEnabled && state.playlist.length > 1) {
                // In shuffle mode, pick a random track
                const availableIndices = [];
                for (let i = 0; i < state.playlist.length; i++) {
                    if (i !== state.currentTrackIndex) {
                        availableIndices.push(i);
                    }
                }
                
                if (availableIndices.length > 0) {
                    const prevIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)];
                    playTrack(prevIndex);
                }
            } else {
                // Normal sequential playback
                let prevIndex = state.currentTrackIndex - 1;
                
                if (prevIndex < 0) {
                    if (state.repeatMode === 'all') {
                        prevIndex = state.playlist.length - 1;
                    } else {
                        return;
                    }
                }
                
                playTrack(prevIndex);
            }
        }

        // Toggle shuffle mode
        function toggleShuffle() {
            state.shuffleEnabled = !state.shuffleEnabled;
            
            updateShuffleButtons();
            showToast(state.shuffleEnabled ? 'Shuffle on' : 'Shuffle off', 'info');
        }

        // Toggle repeat mode
        function toggleRepeat() {
            const modes = ['off', 'all', 'one'];
            const currentIndex = modes.indexOf(state.repeatMode);
            state.repeatMode = modes[(currentIndex + 1) % modes.length];
            
            updateRepeatButtons();
            
            const messages = {
                'off': 'Repeat off',
                'all': 'Repeat all',
                'one': 'Repeat one'
            };
            showToast(messages[state.repeatMode], 'info');
        }

        // Update shuffle button states
        function updateShuffleButtons() {
            const buttons = [
                document.getElementById('shuffleButton'),
                document.getElementById('fullShuffleButton')
            ];
            
            buttons.forEach(button => {
                if (button) {
                    button.classList.toggle('active', state.shuffleEnabled);
                    
                    // Update text if it exists
                    const text = button.querySelector('.control-text');
                    if (text) {
                        text.textContent = state.shuffleEnabled ? 'Shuffle On' : 'Shuffle';
                    }
                }
            });
        }

        // Update repeat button states
        function updateRepeatButtons() {
            const buttons = [
                document.getElementById('repeatButton'),
                document.getElementById('fullRepeatButton')
            ];
            
            buttons.forEach(button => {
                if (button) {
                    button.classList.toggle('active', state.repeatMode !== 'off');
                    
                    // Update icon and text based on repeat mode
                    const icon = button.querySelector('.control-icon');
                    const text = button.querySelector('.control-text');
                    
                    // SVG icons are used now, no need to update textContent
                    /*if (icon) {
                        if (state.repeatMode === 'one') {
                            icon.textContent = '🔂';
                        } else {
                            icon.textContent = '🔁';
                        }
                    }*/
                    
                    if (text) {
                        if (state.repeatMode === 'off') {
                            text.textContent = 'Repeat';
                        } else if (state.repeatMode === 'one') {
                            text.textContent = 'Repeat One';
                        } else {
                            text.textContent = 'Repeat All';
                        }
                    }
                }
            });
        }

        // Update play/pause button states
        function updatePlayPauseButtons() {
            const miniButton = document.getElementById('miniPlayPauseButton');
            const fullButton = document.getElementById('fullPlayPauseButton');
            
            const playIcon = '<svg width="24" height="24" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
            const pauseIcon = '<svg width="24" height="24" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>';
            
            if (miniButton) {
                miniButton.innerHTML = state.isPlaying ? pauseIcon : playIcon;
            }
            
            if (fullButton) {
                fullButton.innerHTML = state.isPlaying ? pauseIcon.replace('24', '32') : playIcon.replace('24', '32');
            }
        }

        // Update now playing UI
        function updateNowPlaying(track) {
            // Mini player
            document.getElementById('miniPlayerTitle').textContent = track.title;
            document.getElementById('miniPlayerArtist').textContent = track.artist;
            
            // Full player
            document.getElementById('fullPlayerTitle').textContent = track.title;
            document.getElementById('fullPlayerArtist').textContent = track.artist;
            
            // Update album art
            const miniArtwork = document.getElementById('miniPlayerArtwork');
            const fullArtwork = document.getElementById('fullPlayerArtwork');
            const fullPlayerBackground = document.getElementById('fullPlayerBackground');
            
            if (track.hasAlbumArt && track.albumArtUrl) {
                miniArtwork.innerHTML = `<img src="${track.albumArtUrl}" alt="Album Art">`;
                fullArtwork.innerHTML = `<img src="${track.albumArtUrl}" alt="Album Art">`;
                // Update blurred background
                fullPlayerBackground.style.backgroundImage = `url(${track.albumArtUrl})`;
                fullPlayerBackground.classList.add('visible');
            } else {
                miniArtwork.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>';
                fullArtwork.innerHTML = '<svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>';
                // Remove background if no album art
                fullPlayerBackground.style.backgroundImage = '';
                fullPlayerBackground.classList.remove('visible');
            }
        }

        // Update progress bar
        function updateProgress() {
            if (!state.audioElement) return;
            
            const currentTime = state.audioElement.currentTime;
            const duration = state.audioElement.duration;
            
            if (!isNaN(duration)) {
                const progress = (currentTime / duration) * 100;
                // Update full player progress
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('currentTime').textContent = formatTime(currentTime);
                
                // Update mini player progress
                document.getElementById('miniProgressFill').style.width = progress + '%';
            }
        }

        // Seek to position
        function seekTo(event) {
            if (!state.audioElement || !state.audioElement.duration) return;
            
            const progressBar = document.getElementById('progressBar');
            const rect = progressBar.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const percentage = x / rect.width;
            const time = percentage * state.audioElement.duration;
            
            state.audioElement.currentTime = time;
        }

        // Format time in MM:SS
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        // Update playlist display
        function updatePlaylistDisplay() {
            const trackList = document.getElementById('trackList');
            const emptyPlaylist = document.getElementById('emptyPlaylist');
            const playlistCount = document.getElementById('playlistCount');
            
            playlistCount.textContent = `${state.playlist.length} track${state.playlist.length !== 1 ? 's' : ''}`;
            
            if (state.playlist.length === 0) {
                trackList.innerHTML = '';
                emptyPlaylist.style.display = 'block';
                return;
            }
            
            emptyPlaylist.style.display = 'none';
            
            trackList.innerHTML = state.playlist.map((track, index) => `
                <li class="track-item ${index === state.currentTrackIndex ? 'playing' : ''}" data-index="${index}">
                    <div class="track-handle" title="Drag to reorder">☰</div>
                    <div class="track-number" onclick="playTrack(${index})">${index === state.currentTrackIndex ? '▶' : index + 1}</div>
                    <div class="track-artwork" onclick="playTrack(${index})">
                        ${track.hasAlbumArt && track.albumArtUrl ? 
                            `<img src="${track.albumArtUrl}" alt="Album Art">` : 
                            '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>'}
                    </div>
                    <div class="track-info" onclick="playTrack(${index})">
                        <div class="track-title">${track.title}</div>
                        <div class="track-artist">${track.artist}${track.album ? ' • ' + track.album : ''}</div>
                    </div>
                    <div class="track-duration">${formatTime(track.duration)}</div>
                    <div class="track-actions">
                        <button class="track-delete" onclick="event.stopPropagation(); removeTrack(${index})" title="Remove">✕</button>
                    </div>
                </li>
            `).join('');
        }

        // Remove track from playlist
        function removeTrack(index) {
            if (index === state.currentTrackIndex) {
                // If removing current track, stop playback
                if (state.audioElement) {
                    state.audioElement.pause();
                    state.audioElement = null;
                    state.sourceNode = null;
                }
                state.currentTrackIndex = -1;
                state.isPlaying = false;
                updatePlayPauseButtons();
                document.getElementById('miniPlayer').classList.add('hidden');
            } else if (index < state.currentTrackIndex) {
                // Adjust current index if removing a track before it
                state.currentTrackIndex--;
            }
            
            // Revoke URLs to free memory
            URL.revokeObjectURL(state.playlist[index].url);
            if (state.playlist[index].albumArtUrl) {
                URL.revokeObjectURL(state.playlist[index].albumArtUrl);
            }
            
            state.playlist.splice(index, 1);
            updatePlaylistDisplay();
            savePlaylistToStorage();
            
            showToast('Track removed', 'info');
        }

        // Clear playlist
        function clearPlaylist() {
            if (state.playlist.length === 0) return;
            
            if (!confirm('Clear all tracks from playlist?')) return;
            
            // Stop playback
            if (state.audioElement) {
                state.audioElement.pause();
                state.audioElement = null;
                state.sourceNode = null;
            }
            
            // Revoke all URLs
            state.playlist.forEach(track => {
                URL.revokeObjectURL(track.url);
                if (track.albumArtUrl) {
                    URL.revokeObjectURL(track.albumArtUrl);
                }
            });
            
            state.playlist = [];
            state.currentTrackIndex = -1;
            state.isPlaying = false;
            
            updatePlaylistDisplay();
            updatePlayPauseButtons();
            document.getElementById('miniPlayer').classList.add('hidden');
            
            localStorage.removeItem('localMusicPlaylist');
            
            showToast('Playlist cleared', 'info');
        }

        // Save playlist to localStorage
        function savePlaylistToStorage() {
            // Note: We can't save the actual File objects, just metadata
            const playlistData = state.playlist.map(track => ({
                title: track.title,
                artist: track.artist,
                duration: track.duration
            }));
            
            localStorage.setItem('localMusicPlaylist', JSON.stringify(playlistData));
        }

        // Load saved playlist (metadata only)
        function loadSavedPlaylist() {
            try {
                const saved = localStorage.getItem('localMusicPlaylist');
                if (saved) {
                    const playlistData = JSON.parse(saved);
                    // Note: We can't restore the actual files, just show what was there
                    console.log('Previous playlist had', playlistData.length, 'tracks');
                }
            } catch (error) {
                console.error('Failed to load saved playlist:', error);
            }
        }

        // Save playlist to file
        function savePlaylist() {
            if (state.playlist.length === 0) {
                showToast('No tracks to save', 'warning');
                return;
            }
            
            const playlistData = {
                name: 'My Playlist',
                created: new Date().toISOString(),
                tracks: state.playlist.map(track => ({
                    title: track.title,
                    artist: track.artist,
                    album: track.album || null,
                    duration: track.duration,
                    genre: track.genre || null,
                    year: track.year || null
                }))
            };
            
            const blob = new Blob([JSON.stringify(playlistData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `playlist-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Playlist saved', 'success');
        }


        // Show/hide full player
        function showFullPlayer() {
            document.getElementById('fullPlayer').classList.add('show');
        }

        function hideFullPlayer() {
            document.getElementById('fullPlayer').classList.remove('show');
        }

        // Show/hide settings
        function toggleSettings() {
            document.getElementById('settingsModal').classList.toggle('show');
        }

        function hideSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }

        // Show about dialog
        function showAbout() {
            const aboutText = 
                'Local Music Player with DSP\n' +
                'Version 1.0\n\n' +
                
                'Features:\n' +
                '• ISO 226:2003 Equal-Loudness Compensation\n' +
                '• BS2B Crossfeed (Bauer stereophonic-to-binaural DSP)\n' +
                '• Local file playback with metadata extraction\n' +
                '• Playlist management (save/load)\n' +
                '• Shuffle & repeat modes\n' +
                '• Advanced DSP controls\n\n' +
                
                'Technical Credits:\n' +
                '• FIR Filter Design: Based on SciPy firwin2 algorithm\n' +
                '• BS2B Algorithm: Inspired by libbs2b (Boris Mikhaylov)\n' +
                '• ISO 226:2003: International standard for equal-loudness contours\n' +
                '• Metadata Parser: music-metadata-browser library\n' +
                '• Development: Created with Claude Code (Anthropic)\n\n' +
                
                'License:\n' +
                'This software is released under the MIT License.\n' +
                'You are free to use, modify, and distribute this software\n' +
                'provided that the original copyright notice is retained.\n\n' +
                
                'Third-party libraries used:\n' +
                '• music-metadata-browser (MIT License)\n' +
                '• Web Audio API (W3C Standard)\n\n' +
                
                '© 2024 Local Music Player with DSP\n' +
                'All rights reserved.';
            
            alert(aboutText);
        }

        // Enter manual bass mode
        function enterManualBassMode() {
            state.manualBassMode = true;
            
            // Show reset button
            document.getElementById('bassResetBtn').style.display = 'inline-block';
            
            // Disable Target/Reference/Master sliders
            const slidersToDisable = [
                { id: 'targetPhonSlider', labelId: 'targetPhonValue' },
                { id: 'referencePhonSlider', labelId: 'referencePhonValue' },
                { id: 'masterGainSlider', labelId: 'masterGainValue' }
            ];
            
            slidersToDisable.forEach(slider => {
                const sliderEl = document.getElementById(slider.id);
                const labelEl = document.getElementById(slider.labelId).parentElement.parentElement;
                
                sliderEl.disabled = true;
                sliderEl.classList.add('manual-disabled');
                labelEl.classList.add('manual-disabled');
            });
        }
        
        // Reset bass mode
        function resetBassMode() {
            state.manualBassMode = false;
            
            // Hide reset button
            document.getElementById('bassResetBtn').style.display = 'none';
            
            // Re-enable sliders
            const slidersToEnable = [
                { id: 'targetPhonSlider', labelId: 'targetPhonValue' },
                { id: 'referencePhonSlider', labelId: 'referencePhonValue' },
                { id: 'masterGainSlider', labelId: 'masterGainValue' }
            ];
            
            slidersToEnable.forEach(slider => {
                const sliderEl = document.getElementById(slider.id);
                const labelEl = document.getElementById(slider.labelId).parentElement.parentElement;
                
                sliderEl.disabled = false;
                sliderEl.classList.remove('manual-disabled');
                labelEl.classList.remove('manual-disabled');
            });
            
            // Recalculate all values
            updateLoudnessFromEasy();
            updateLoudnessDisplay();
        }
        
        // Global function for onclick
        window.resetBassMode = resetBassMode;
        
        // Show toast notification
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 10);
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Update UI mode
        function updateUIMode() {
            const advancedControls = document.getElementById('advancedControls');
            // Show advanced controls only when loudness is on and easy mode is off
            advancedControls.style.display = (state.loudnessEnabled && !state.easyMode) ? 'block' : 'none';
            
            // Sync advanced loudness slider with current value
            if (!state.easyMode && state.loudnessEnabled) {
                const advancedSlider = document.getElementById('advancedLoudnessSlider');
                if (advancedSlider) {
                    advancedSlider.value = state.easyLoudness;
                    document.getElementById('advancedLoudnessValue').textContent = state.easyLoudness;
                }
            }
            
            // Update the display when switching modes
            if (state.loudnessEnabled) {
                updateLoudnessDisplay();
            }
        }
        
        // Update DSP controls visibility
        function updateDSPControlsVisibility() {
            const loudnessContainer = document.getElementById('loudnessContainer');
            const dspOffGainContainer = document.getElementById('dspOffGainContainer');
            const fullPlayerLoudnessContainer = document.getElementById('fullPlayerLoudnessContainer');
            const fullPlayerDspOffGainContainer = document.getElementById('fullPlayerDspOffGainContainer');
            
            if (state.loudnessEnabled) {
                // Show loudness controls, hide master gain
                loudnessContainer.classList.remove('hidden');
                dspOffGainContainer.classList.add('hidden');
                fullPlayerLoudnessContainer.classList.remove('hidden');
                fullPlayerDspOffGainContainer.classList.add('hidden');
            } else {
                // Hide loudness controls, show master gain
                loudnessContainer.classList.add('hidden');
                dspOffGainContainer.classList.remove('hidden');
                fullPlayerLoudnessContainer.classList.add('hidden');
                fullPlayerDspOffGainContainer.classList.remove('hidden');
                
                // Update master gain slider values to current state
                document.getElementById('dspOffGainSlider').value = state.masterGain;
                document.getElementById('dspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                document.getElementById('fullPlayerDspOffGainSlider').value = state.masterGain;
                document.getElementById('fullPlayerDspOffGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                
                // Update SPL and headroom display for DSP Off mode
                updateOffModeDisplay();
            }
        }

        // Update loudness display info
        function updateLoudnessDisplay() {
            // Use appropriate phon value based on mode
            const phon = state.easyMode ? easyToPhon(state.easyLoudness) : state.targetPhon;
            const spl = phonToSPL(phon);
            const params = state.easyMode ? calculateLoudnessAwareParameters(phon) : {
                targetPhon: state.targetPhon,
                referencePhon: state.referencePhon,
                masterGain: state.masterGain,
                gap: state.referencePhon - state.targetPhon
            };
            
            // Calculate total gain for headroom
            const loudnessPreamp = state.loudnessEnabled ? calculateSPLPreamp(state.targetPhon) : 0;
            const bassBoost = state.loudnessEnabled ? 
                (state.deltaMaxParameter * Math.exp(-(state.targetPhon - 40) / state.kParameter)) : 0;
            const totalLoudnessGain = loudnessPreamp + (bassBoost > 1 ? Math.log10(bassBoost) * 20 : 0);
            const totalGain = state.masterGain + totalLoudnessGain;
            const headroom = -totalGain; // Negative of total gain = headroom to 0dBFS
            
            // Update filter display
            const filterDisplay = document.getElementById('filterDisplay');
            if (phon >= 85) {
                filterDisplay.textContent = 'OFF';
                filterDisplay.style.color = 'var(--text-secondary)';
            } else {
                filterDisplay.textContent = `${phon.toFixed(0)}→${params.referencePhon.toFixed(0)} phon`;
                filterDisplay.style.color = 'var(--accent-color)';
            }
            
            // Update SPL display
            document.getElementById('splDisplay').textContent = `${spl.toFixed(0)} dB`;
            
            // Update gain display
            document.getElementById('gainDisplay').textContent = `${state.masterGain.toFixed(1)} dB`;
            
            // Update headroom display with color
            const headroomDisplay = document.getElementById('headroomDisplay');
            headroomDisplay.textContent = `${headroom > 0 ? '-' : '+'}${Math.abs(headroom).toFixed(1)} dB`;
            
            // Color based on headroom
            if (headroom < 3) {
                headroomDisplay.style.color = 'var(--danger)'; // Red - clipping risk
            } else if (headroom < 6) {
                headroomDisplay.style.color = 'var(--warning)'; // Yellow - caution
            } else {
                headroomDisplay.style.color = 'var(--success)'; // Green - safe
            }
            
            // Update full player display
            const fullPlayerFilterDisplay = document.getElementById('fullPlayerFilterDisplay');
            if (fullPlayerFilterDisplay) {
                if (phon >= 85) {
                    fullPlayerFilterDisplay.textContent = 'OFF';
                    fullPlayerFilterDisplay.style.color = 'var(--text-secondary)';
                } else {
                    fullPlayerFilterDisplay.textContent = `${phon.toFixed(0)}→${params.referencePhon.toFixed(0)} phon`;
                    fullPlayerFilterDisplay.style.color = 'var(--accent-color)';
                }
            }
            
            const fullPlayerSplDisplay = document.getElementById('fullPlayerSplDisplay');
            if (fullPlayerSplDisplay) {
                fullPlayerSplDisplay.textContent = `${spl.toFixed(0)} dB`;
            }
            
            const fullPlayerGainDisplay = document.getElementById('fullPlayerGainDisplay');
            if (fullPlayerGainDisplay) {
                fullPlayerGainDisplay.textContent = `${state.masterGain.toFixed(1)} dB`;
            }
            
            const fullPlayerHeadroomDisplay = document.getElementById('fullPlayerHeadroomDisplay');
            if (fullPlayerHeadroomDisplay) {
                fullPlayerHeadroomDisplay.textContent = `${headroom > 0 ? '-' : '+'}${Math.abs(headroom).toFixed(1)} dB`;
                
                // Color based on headroom
                if (headroom < 3) {
                    fullPlayerHeadroomDisplay.style.color = 'var(--danger)';
                } else if (headroom < 6) {
                    fullPlayerHeadroomDisplay.style.color = 'var(--warning)';
                } else {
                    fullPlayerHeadroomDisplay.style.color = 'var(--success)';
                }
            }
            
            // Update Advanced DSP Info Display
            const advancedFilterDisplay = document.getElementById('advancedFilterDisplay');
            const advancedSplDisplay = document.getElementById('advancedSplDisplay');
            const advancedGainDisplay = document.getElementById('advancedGainDisplay');
            const advancedHeadroomDisplay = document.getElementById('advancedHeadroomDisplay');
            
            if (advancedFilterDisplay && state.loudnessEnabled && !state.easyMode) {
                // Filter display
                if (phon >= 85) {
                    advancedFilterDisplay.textContent = 'OFF';
                    advancedFilterDisplay.style.color = 'var(--text-secondary)';
                } else {
                    advancedFilterDisplay.textContent = `${phon.toFixed(0)}→${params.referencePhon.toFixed(0)} phon`;
                    advancedFilterDisplay.style.color = 'var(--accent-color)';
                }
                
                // SPL display
                advancedSplDisplay.textContent = `${spl.toFixed(0)} dB`;
                
                // Gain display
                advancedGainDisplay.textContent = `${state.masterGain.toFixed(1)} dB`;
                
                // Headroom display with color
                advancedHeadroomDisplay.textContent = `${headroom > 0 ? '-' : '+'}${Math.abs(headroom).toFixed(1)} dB`;
                
                // Color based on headroom
                if (headroom < 3) {
                    advancedHeadroomDisplay.style.color = 'var(--danger)';
                } else if (headroom < 6) {
                    advancedHeadroomDisplay.style.color = 'var(--warning)';
                } else {
                    advancedHeadroomDisplay.style.color = 'var(--success)';
                }
            }
        }
        
        // Update DSP Off mode display
        function updateOffModeDisplay() {
            // Assume calibration SPL of 80dB (typical for home listening)
            const calibrationSPL = 80.0;
            const spl = calibrationSPL + state.masterGain;
            const headroom = -state.masterGain;
            
            // Update SPL display - main
            document.getElementById('splDisplayOff').textContent = `${spl.toFixed(0)} dB`;
            
            // Update headroom display with color - main
            const headroomDisplay = document.getElementById('headroomDisplayOff');
            headroomDisplay.textContent = `${headroom > 0 ? '-' : '+'}${Math.abs(headroom).toFixed(1)} dB`;
            
            // Update SPL display - full player
            const fullPlayerSplDisplayOff = document.getElementById('fullPlayerSplDisplayOff');
            if (fullPlayerSplDisplayOff) {
                fullPlayerSplDisplayOff.textContent = `${spl.toFixed(0)} dB`;
            }
            
            // Update headroom display - full player
            const fullPlayerHeadroomDisplayOff = document.getElementById('fullPlayerHeadroomDisplayOff');
            if (fullPlayerHeadroomDisplayOff) {
                fullPlayerHeadroomDisplayOff.textContent = `${headroom > 0 ? '-' : '+'}${Math.abs(headroom).toFixed(1)} dB`;
            }
            
            // Color based on headroom
            const color = headroom < 3 ? 'var(--danger)' : headroom < 6 ? 'var(--warning)' : 'var(--success)';
            headroomDisplay.style.color = color;
            if (fullPlayerHeadroomDisplayOff) {
                fullPlayerHeadroomDisplayOff.style.color = color;
            }
        }
        
        // Clear headphone EQ
        function clearEQ() {
            state.headphoneEqEnabled = false;
            document.getElementById('headphoneEqToggle').checked = false;
            document.getElementById('eqFileInfo').style.display = 'none';
            updateAudioGraph();
            showToast('Headphone EQ cleared', 'info');
        }


        // ============ DSP FUNCTIONS - PRESERVED EXACTLY AS IS FROM ORIGINAL ============
        
        // Interpolate ISO curves - PRESERVED EXACTLY AS IS
        function interpISO(curves, step) {
            const phons = Object.keys(curves).map(Number).sort((a, b) => a - b);
            const freqs = ISO_FREQ;
            const result = {};
            
            for (let phon = phons[0]; phon <= phons[phons.length - 1]; phon += step) {
                const lowerPhon = Math.floor(phon / 10) * 10;
                const upperPhon = Math.ceil(phon / 10) * 10;
                
                if (lowerPhon === upperPhon || lowerPhon < phons[0] || upperPhon > phons[phons.length - 1]) {
                    result[phon] = curves[lowerPhon] || curves[upperPhon];
                } else {
                    const lowerCurve = curves[lowerPhon];
                    const upperCurve = curves[upperPhon];
                    const t = (phon - lowerPhon) / (upperPhon - lowerPhon);
                    
                    result[phon] = lowerCurve.map((lower, i) => {
                        const upper = upperCurve[i];
                        return lower + t * (upper - lower);
                    });
                }
            }
            
            return result;
        }

        // Convert phon to SPL - PRESERVED EXACTLY AS IS
        function phonToSPL(phon, freq) {
            const freqIndex = findClosestIndex(ISO_FREQ, freq);
            const phonLevels = Object.keys(state.fineGrainedISO226).map(Number);
            const closestPhon = phonLevels.reduce((prev, curr) => 
                Math.abs(curr - phon) < Math.abs(prev - phon) ? curr : prev
            );
            
            return state.fineGrainedISO226[closestPhon][freqIndex];
        }

        // Find closest index - PRESERVED EXACTLY AS IS
        function findClosestIndex(arr, target) {
            return arr.reduce((prev, curr, index) => 
                Math.abs(curr - target) < Math.abs(arr[prev] - target) ? index : prev, 0
            );
        }

        // Design FIR filter - PRESERVED EXACTLY AS IS
        function designFIR(targetGains, sampleRate, numTaps) {
            const N = numTaps;
            const M = (N - 1) / 2;
            const h = new Float32Array(N);
            
            // Create frequency array from 0 to Nyquist
            const numFreqs = 2048;
            const freqs = new Float32Array(numFreqs);
            const gains = new Float32Array(numFreqs);
            
            for (let i = 0; i < numFreqs; i++) {
                freqs[i] = (i / (numFreqs - 1)) * (sampleRate / 2);
                gains[i] = interpolateGain(targetGains, freqs[i]);
            }
            
            // Apply frequency sampling method
            for (let n = 0; n < N; n++) {
                h[n] = 0;
                for (let k = 0; k < numFreqs; k++) {
                    const omega = 2 * Math.PI * freqs[k] / sampleRate;
                    h[n] += gains[k] * Math.cos(omega * (n - M)) / numFreqs;
                }
            }
            
            // Apply window function (Hamming)
            for (let n = 0; n < N; n++) {
                const window = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1));
                h[n] *= window;
            }
            
            // Normalize
            const sum = h.reduce((a, b) => a + b, 0);
            if (Math.abs(sum) > 1e-10) {
                for (let n = 0; n < N; n++) {
                    h[n] /= sum;
                }
            }
            
            // **** APPLY -0.5dB CORRECTION TO MATCH PYTHON VERSION EXACTLY ****
            const correction = Math.pow(10, -0.5 / 20); // -0.5dB in linear
            for (let n = 0; n < N; n++) {
                h[n] *= correction;
            }
            
            return h;
        }

        // Interpolate gain - PRESERVED EXACTLY AS IS
        function interpolateGain(targetGains, freq) {
            const freqs = Object.keys(targetGains).map(Number).sort((a, b) => a - b);
            
            if (freq <= freqs[0]) return targetGains[freqs[0]];
            if (freq >= freqs[freqs.length - 1]) return targetGains[freqs[freqs.length - 1]];
            
            for (let i = 0; i < freqs.length - 1; i++) {
                if (freq >= freqs[i] && freq <= freqs[i + 1]) {
                    const f1 = freqs[i], f2 = freqs[i + 1];
                    const g1 = targetGains[f1], g2 = targetGains[f2];
                    
                    // Log interpolation for frequency
                    const logF = Math.log10(freq);
                    const logF1 = Math.log10(f1);
                    const logF2 = Math.log10(f2);
                    const t = (logF - logF1) / (logF2 - logF1);
                    
                    return g1 + t * (g2 - g1);
                }
            }
            
            return 1.0;
        }

        // Convert Easy slider value (0-100) to phon
        function easyToPhon(easyValue) {
            // Desktop enhanced parameters
            const Lmin = 40;  // Minimum SPL 
            const Lmax = 90;  // Maximum SPL
            
            // Linear mapping from slider to phon range
            const targetPhon = Lmin + (easyValue / 100) * (Lmax - Lmin);
            return targetPhon;
        }

        // Convert phon to calibrated SPL
        function phonToSPL(phon) {
            // Use calibration: if we're at calibrationSPL phon, output should be calibrationSPL dB SPL
            // This accounts for the user's specific listening setup
            return phon;
        }

        // Calculate SPL-based preamp for calibration
        function calculateSPLPreamp(targetPhon) {
            if (!state.isCalibrated) return 0;
            
            // Calculate the preamp needed based on calibration
            // If we measured 85 dB when expecting 80 dB, systemOffset = +5 dB
            // If user wants to listen at 70 dB, we need to reduce by additional amount
            const targetSPL = state.desiredSPL;
            const referenceSPL = state.calibrationSPL;
            
            // Basic SPL difference
            const splDifference = targetSPL - referenceSPL;
            
            // Apply system offset correction
            const preamp = splDifference - state.systemOffset;
            
            console.log(`[SPL Preamp] Target SPL: ${targetSPL}, Reference SPL: ${referenceSPL}, System Offset: ${state.systemOffset}, Preamp: ${preamp}`);
            
            return preamp;
        }

        // Calculate loudness parameters using enhanced bass algorithm with adjustable k
        function calculateLoudnessAwareParameters(targetPhon) {
            // Enhanced bass parameters (ChatGPT-o3 recommendation)
            const Lmin = 40;      // Minimum SPL
            const Lmax = 90;      // Maximum SPL  
            const k = state.kParameter;  // User-adjustable fall-off rate (0.1-26)
            const deltaMax = state.deltaMaxParameter;  // User-adjustable max bass boost (0-80 dB)
            const deltaMin = 1;   // Minimum phon gap
            
            const L = targetPhon;
            
            // Option A + B Combined: Adaptive parameters + headroom protection
            let adaptiveK, adaptiveDeltaMax;
            
            // Check if in manual bass mode
            if (state.manualBassMode) {
                // Use the manually set k and deltaMax values
                adaptiveK = state.kParameter;
                adaptiveDeltaMax = state.deltaMaxParameter;
            } else {
                // Step 1: Adjust k and deltaMax based on phon range (Option A)
                adaptiveK = k;
                adaptiveDeltaMax = deltaMax;
                
                if (L < 55) {
                    adaptiveK = 18;
                    adaptiveDeltaMax = 20;
                } else if (L < 60) {
                    adaptiveK = 18;
                    adaptiveDeltaMax = 16;
                } else if (L < 65) {
                    adaptiveK = 26;
                    adaptiveDeltaMax = 8;
                } else if (L < 70) {
                    adaptiveK = 30;
                    adaptiveDeltaMax = 6;
                } else if (L < 80) {
                    adaptiveK = 35;
                    adaptiveDeltaMax = 4;
                } else {
                    // 80+ phon: rapid fade out
                    adaptiveK = 40;
                    adaptiveDeltaMax = 3;
                }
            }
            
            // Enhanced exponential decay with adaptive parameters
            const gapRaw = deltaMin + (adaptiveDeltaMax - deltaMin) * Math.exp(-(L - Lmin) / adaptiveK);
            
            // Step 2: Apply headroom protection (Option B)
            const crest = 6;    // Programme peaks in dB (worst case)
            const safety = 1;   // True-peak guard in dB
            const masterGainMagnitude = Math.abs(state.masterGain); // e.g., 30 for -30 dB
            const maxAllowedBoost = masterGainMagnitude - crest - safety; // e.g., 30-6-1 = 23 dB
            
            // Scale down the gap if it would exceed headroom
            const headroomScale = Math.min(1, maxAllowedBoost / gapRaw);
            
            // Step 3: Smooth fade-out for high SPL (80-85 phon)
            let fadeScale = 1;
            if (L >= 80) {
                // Smooth fade from 80 to 85 phon (complete off at 85)
                fadeScale = Math.max(0, 1 - (L - 80) / 5);
            }
            
            // Apply both scales
            const gap = gapRaw * headroomScale * fadeScale;
            
            // Log detailed info
            if (headroomScale < 1 || fadeScale < 1) {
                console.log(`[Adaptive Loudness] L=${L.toFixed(1)}, k=${adaptiveK}, δMax=${adaptiveDeltaMax}, ` +
                           `Raw=${gapRaw.toFixed(1)}dB, Headroom=${headroomScale.toFixed(2)}, ` +
                           `Fade=${fadeScale.toFixed(2)}, Final=${gap.toFixed(1)}dB`);
            }
            
            // Calculate reference phon
            let referencePhon = L + gap;
            
            // Desktop-style master gain calculation (bypasses auto preamp)
            const targetMasterGain = targetPhon - state.calibrationSPL + state.systemOffset;
            
            // Log bass enhancement level for debugging
            console.log(`[Bass Enhancement] k=${k.toFixed(1)}, Target=${L.toFixed(1)} phon, Gap=${gap.toFixed(1)} phon`);
            
            return {
                targetPhon: targetPhon,
                referencePhon: referencePhon,
                masterGain: targetMasterGain,
                gap: gap
            };
        }

        // Update loudness from easy mode - PRESERVED EXACTLY AS IS
        function updateLoudnessFromEasy() {
            // Always calculate from loudness slider value
            const targetPhon = easyToPhon(state.easyLoudness);
            
            // Only update k and deltaMax if not in manual mode
            if (!state.manualBassMode) {
                // Get adaptive k and deltaMax based on targetPhon
                let adaptiveK = 20;
                let adaptiveDeltaMax = 20;
                
                if (targetPhon < 55) {
                    adaptiveK = 18;
                    adaptiveDeltaMax = 20;
                } else if (targetPhon < 60) {
                    adaptiveK = 18;
                    adaptiveDeltaMax = 16;
                } else if (targetPhon < 65) {
                    adaptiveK = 22;
                    adaptiveDeltaMax = 12;
                } else if (targetPhon < 70) {
                    adaptiveK = 24;
                    adaptiveDeltaMax = 10;
                } else if (targetPhon < 80) {
                    adaptiveK = 30;
                    adaptiveDeltaMax = 6;
                } else {
                    adaptiveK = 40;
                    adaptiveDeltaMax = 3;
                }
                
                // Update k and deltaMax sliders dynamically
                state.kParameter = adaptiveK;
                state.deltaMaxParameter = adaptiveDeltaMax;
                
                // Update UI sliders
                const kSlider = document.getElementById('kParameterSlider');
                const deltaMaxSlider = document.getElementById('deltaMaxSlider');
                if (kSlider) {
                    kSlider.value = adaptiveK;
                    document.getElementById('kParameterValue').textContent = adaptiveK.toFixed(1);
                }
                if (deltaMaxSlider) {
                    deltaMaxSlider.value = adaptiveDeltaMax;
                    document.getElementById('deltaMaxValue').textContent = adaptiveDeltaMax + ' dB';
                }
            }
                
                const params = calculateLoudnessAwareParameters(targetPhon);
                
                // Update state with calculated parameters
                state.targetPhon = params.targetPhon;
                state.referencePhon = params.referencePhon;
                
                // Desktop-style: disable auto preamp, use direct master gain calculation
                state.autoPreampEnabled = false;
                state.masterGain = params.masterGain;
                
                // Update master gain slider and display
                document.getElementById('masterGainSlider').value = state.masterGain;
                document.getElementById('masterGainValue').textContent = state.masterGain.toFixed(1) + ' dB';
                
                // Update displays
                document.getElementById('targetPhonValue').textContent = state.targetPhon.toFixed(1) + ' phon';
                document.getElementById('targetPhonSlider').value = state.targetPhon;
                document.getElementById('referencePhonValue').textContent = state.referencePhon.toFixed(1) + ' phon';
                document.getElementById('referencePhonSlider').value = state.referencePhon;
                
                // Update master gain
                updateMasterGain();
                
                // Recalculate loudness filter
                updateLoudnessFilter();
                
                // Update display
                updateLoudnessDisplay();
        }

        // Update loudness filter - PRESERVED EXACTLY AS IS
        async function updateLoudnessFilter() {
            if (!state.audioContext || !state.loudnessConvolver) return;
            
            try {
                // Calculate target gains
                const targetGains = {};
                
                for (const freq of ISO_FREQ) {
                    const refSPL = phonToSPL(state.referencePhon, freq);
                    const targetSPL = phonToSPL(state.targetPhon, freq);
                    let diff = refSPL - targetSPL;
                    
                    // Apply bass enhancement
                    if (freq < 500 && diff > 0) {
                        const enhancement = diff * Math.exp(-freq / (state.k * 20));
                        diff = Math.min(diff + enhancement, state.deltaMax);
                    }
                    
                    targetGains[freq] = Math.pow(10, diff / 20);
                }
                
                // Design FIR filter
                const sampleRate = state.audioContext.sampleRate;
                const impulseResponse = designFIR(targetGains, sampleRate, state.filterTaps);
                
                // Create buffer for convolver
                const buffer = state.audioContext.createBuffer(1, impulseResponse.length, sampleRate);
                buffer.getChannelData(0).set(impulseResponse);
                
                state.loudnessConvolver.buffer = buffer;
                
            } catch (error) {
                console.error('Failed to update loudness filter:', error);
            }
        }

        // Initialize crossfeed (BS2B)
        function initializeCrossfeed() {
            if (!state.audioContext) return;
            
            // Create splitter and merger for stereo processing
            state.crossfeedSplitter = state.audioContext.createChannelSplitter(2);
            state.crossfeedMerger = state.audioContext.createChannelMerger(2);
            
            // Create filters for each channel
            // Low-pass filters for cross-fed signal
            state.crossfeedLowpassL = state.audioContext.createBiquadFilter();
            state.crossfeedLowpassL.type = 'lowpass';
            
            state.crossfeedLowpassR = state.audioContext.createBiquadFilter();
            state.crossfeedLowpassR.type = 'lowpass';
            
            // High-pass filters for direct signal
            state.crossfeedHighpassL = state.audioContext.createBiquadFilter();
            state.crossfeedHighpassL.type = 'highpass';
            
            state.crossfeedHighpassR = state.audioContext.createBiquadFilter();
            state.crossfeedHighpassR.type = 'highpass';
            
            // Delay nodes for ITD (Interaural Time Difference)
            state.crossfeedDelayL = state.audioContext.createDelay(0.001); // Max 1ms delay
            state.crossfeedDelayR = state.audioContext.createDelay(0.001);
            
            // Gain nodes for ILD (Interaural Level Difference)
            state.crossfeedGainL = state.audioContext.createGain();
            state.crossfeedGainR = state.audioContext.createGain();
            
            // Set initial parameters
            updateCrossfeedParameters();
        }
        
        // Update crossfeed parameters based on level
        function updateCrossfeedParameters() {
            if (!state.audioContext) return;
            
            // BS2B presets
            const presets = {
                1: { // Low (30° 700Hz)
                    cutoff: 700,
                    feed: 0.45,
                    delay: 0.00025 // 0.25ms
                },
                2: { // Medium (30° 650Hz) - Default
                    cutoff: 650,
                    feed: 0.5,
                    delay: 0.00032 // 0.32ms
                },
                3: { // High (30° 600Hz)
                    cutoff: 600,
                    feed: 0.6,
                    delay: 0.00040 // 0.40ms
                }
            };
            
            const preset = presets[state.crossfeedLevel];
            
            // Update filter frequencies
            state.crossfeedLowpassL.frequency.value = preset.cutoff;
            state.crossfeedLowpassR.frequency.value = preset.cutoff;
            state.crossfeedHighpassL.frequency.value = preset.cutoff;
            state.crossfeedHighpassR.frequency.value = preset.cutoff;
            
            // Update delays
            state.crossfeedDelayL.delayTime.value = preset.delay;
            state.crossfeedDelayR.delayTime.value = preset.delay;
            
            // Update cross-feed gains
            state.crossfeedGainL.gain.value = preset.feed;
            state.crossfeedGainR.gain.value = preset.feed;
        }

        // Update audio graph - PRESERVED EXACTLY AS IS
        function updateAudioGraph() {
            if (!state.audioContext || !state.sourceNode) return;
            
            // Disconnect all nodes
            state.sourceNode.disconnect();
            state.loudnessConvolver.disconnect();
            state.gainNode.disconnect();
            
            // Disconnect headphone convolver if it exists
            if (state.headphoneConvolver) {
                state.headphoneConvolver.disconnect();
            }
            
            // Disconnect crossfeed nodes if they exist
            if (state.crossfeedSplitter) {
                state.crossfeedSplitter.disconnect();
                state.crossfeedMerger.disconnect();
                state.crossfeedLowpassL.disconnect();
                state.crossfeedLowpassR.disconnect();
                state.crossfeedHighpassL.disconnect();
                state.crossfeedHighpassR.disconnect();
                state.crossfeedDelayL.disconnect();
                state.crossfeedDelayR.disconnect();
                state.crossfeedGainL.disconnect();
                state.crossfeedGainR.disconnect();
            }
            
            let currentNode = state.sourceNode;
            
            // Apply loudness compensation if enabled
            if (state.loudnessEnabled) {
                currentNode.connect(state.loudnessConvolver);
                currentNode = state.loudnessConvolver;
            }
            
            // Apply crossfeed if enabled
            if (state.crossfeedEnabled && state.crossfeedSplitter) {
                // Split stereo signal
                currentNode.connect(state.crossfeedSplitter);
                
                // Left channel processing
                // Direct path (high frequencies)
                state.crossfeedSplitter.connect(state.crossfeedHighpassL, 0);
                state.crossfeedHighpassL.connect(state.crossfeedMerger, 0, 0);
                
                // Cross-feed path (low frequencies to opposite channel)
                state.crossfeedSplitter.connect(state.crossfeedLowpassL, 0);
                state.crossfeedLowpassL.connect(state.crossfeedDelayL);
                state.crossfeedDelayL.connect(state.crossfeedGainL);
                state.crossfeedGainL.connect(state.crossfeedMerger, 0, 1); // L to R
                
                // Right channel processing
                // Direct path (high frequencies)
                state.crossfeedSplitter.connect(state.crossfeedHighpassR, 1);
                state.crossfeedHighpassR.connect(state.crossfeedMerger, 0, 1);
                
                // Cross-feed path (low frequencies to opposite channel)
                state.crossfeedSplitter.connect(state.crossfeedLowpassR, 1);
                state.crossfeedLowpassR.connect(state.crossfeedDelayR);
                state.crossfeedDelayR.connect(state.crossfeedGainR);
                state.crossfeedGainR.connect(state.crossfeedMerger, 0, 0); // R to L
                
                currentNode = state.crossfeedMerger;
            }
            
            // Apply headphone EQ if enabled
            if (state.headphoneEqEnabled && state.headphoneConvolver && state.headphoneEqBuffer) {
                currentNode.connect(state.headphoneConvolver);
                currentNode = state.headphoneConvolver;
            }
            
            // Connect to gain node
            currentNode.connect(state.gainNode);
            state.gainNode.connect(state.audioContext.destination);
            
            // Update master gain
            updateMasterGain();
        }

        // Update master gain - PRESERVED EXACTLY AS IS
        function updateMasterGain() {
            if (!state.gainNode) return;
            
            const totalGain = state.masterGain + state.preampGain;
            state.gainNode.gain.value = Math.pow(10, totalGain / 20);
        }

        // Handle EQ file load - PRESERVED EXACTLY AS IS
        async function handleEqFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await state.audioContext.decodeAudioData(arrayBuffer);
                
                // Store the buffer
                state.headphoneEqBuffer = audioBuffer;
                
                // Create or update the convolver
                if (!state.headphoneConvolver) {
                    state.headphoneConvolver = state.audioContext.createConvolver();
                    state.headphoneConvolver.normalize = false;
                }
                
                // Set the buffer
                state.headphoneConvolver.buffer = audioBuffer;
                
                // Update the audio graph if headphone EQ is enabled
                if (state.headphoneEqEnabled) {
                    updateAudioGraph();
                }
                
                document.getElementById('eqFileName').textContent = file.name;
                document.getElementById('eqFileInfo').style.display = 'flex';
                
                showToast('Headphone EQ loaded', 'success');
            } catch (error) {
                console.error('Failed to load EQ file:', error);
                showToast('Failed to load EQ file', 'error');
            }
        }
    </script>
    
    <!-- Firebase SDK (Optional - for analytics) -->
    <script type="module">
        // Only initialize Firebase if you want analytics
        // Comment out this section if you don't need it
        /*
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyBfx0h4HWb-A3jQKVIHHWi_pdZj9kzywXI",
            authDomain: "webtidalloudness.firebaseapp.com",
            projectId: "webtidalloudness",
            storageBucket: "webtidalloudness.firebasestorage.app",
            messagingSenderId: "1072743340488",
            appId: "1:1072743340488:web:64daa2195600c7da3248fd",
            measurementId: "G-P8JV9LTDYT"
        };
        
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        */
    </script>
</body>
</html>